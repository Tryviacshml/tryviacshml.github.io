<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <title>Customer Health Score</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;700&family=Roboto:wght@400;700&display=swap"
    rel="stylesheet">
  <!-- Font Awesome para Ã­cones -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --tryvia-dark: #3a383b;
      --tryvia-dark2: #2a2829;
      --tryvia-white: #fff;
      --tryvia-gray: #f8f9fa;
      --tryvia-gray2: #e9ecef;
      --tryvia-border: #e0e6ed;
      --tryvia-cyan: #00d4ff;
      --tryvia-green: #00d084;
      --tryvia-yellow: #ffc107;
      --tryvia-red: #ff4757;
      --tryvia-blue: #0066ff;
      --tryvia-shadow: 0 12px 40px rgba(0, 0, 0, 0.08);
      --tryvia-card-shadow: 0 8px 32px rgba(0, 212, 255, 0.12);
      --tryvia-cyan-bg: linear-gradient(135deg, rgba(0, 212, 255, 0.04) 0%, rgba(0, 212, 255, 0.01) 100%);
      --tryvia-gradient: linear-gradient(135deg, #f0f4ff 0%, #e8f4fc 25%, #f5f0ff 50%, #e8fcf8 75%, #f0f4ff 100%);
      --tryvia-accent-gradient: linear-gradient(135deg, #00d4ff 0%, #00b8d4 50%, #00e4ff 100%);
      --tryvia-glass: rgba(255, 255, 255, 0.92);
      --tryvia-glass-border: rgba(255, 255, 255, 0.4);
      --tryvia-transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      --tryvia-transition-smooth: 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      --tryvia-transition-bounce: 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    html,
    body {
      background: var(--tryvia-gradient);
      background-attachment: fixed;
      font-family: 'Roboto', Arial, sans-serif !important;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      color: var(--tryvia-dark);
      width: 100vw;
      overflow-x: hidden;
      min-height: 100vh;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 6px;
    }

    /* Global transitions */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    a,
    button,
    input,
    select,
    .btn {
      transition: all var(--tryvia-transition-fast);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 28px rgba(0, 212, 255, 0.25);
    }

    .btn:active {
      transform: translateY(0);
    }

    /* Header */
    header {
      width: 100vw;
      padding: 0.35rem 1rem;
      position: relative;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(0, 212, 255, 0.1);
    }

    .header-inner {
      width: 100%;
      max-width: 100% !important;
      margin: 0 auto;
      display: flex;
      align-items: center;
      gap: 1rem;
      justify-content: center;
      position: relative;
      min-height: 64px;
      padding: 0 28px;
    }

    .header-inner .left {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header-inner .right {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .title-wrapper {
      text-align: center;
    }

    .logo-wrap {
      width: auto;
      height: auto;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      border: 1px solid var(--tryvia-border);
      padding: 4px;
    }

    .logo {
      max-height: 48px;
      width: auto;
      display: block;
      vertical-align: middle;
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.08));
    }

    #siteTitle {
      font-family: 'Poppins', 'Roboto', Arial, sans-serif;
      font-weight: 700;
      font-size: 42px;
      color: var(--tryvia-dark);
      letter-spacing: 0.2px;
      margin: 0 0 6px 0;
      text-align: center;
      line-height: 1;
    }

    #siteSubtitle {
      font-family: 'Poppins', 'Roboto', Arial, sans-serif;
      font-weight: 700;
      font-size: 15px;
      color: var(--tryvia-cyan);
      margin: 0;
      text-transform: uppercase;
    }

    .search-input {
      padding: .5rem .8rem;
      border-radius: 14px;
      font-size: 0.95rem;
      width: 260px;
      border: 2px solid rgba(0, 212, 255, 0.3);
      background: rgba(255, 255, 255, 0.95);
      color: var(--tryvia-dark);
      box-shadow: 0 4px 20px rgba(0, 212, 255, 0.1), inset 0 1px 2px rgba(255, 255, 255, 0.8);
      outline: none;
      position: relative;
      z-index: 10;
      transition: all var(--tryvia-transition-fast);
    }

    .search-input:focus {
      border-color: var(--tryvia-cyan);
      box-shadow: 0 6px 28px rgba(0, 212, 255, 0.2), 0 0 0 4px rgba(0, 212, 255, 0.1);
    }

    .search-input::placeholder {
      color: #7eaeb9;
    }

    /* Make readonly search inputs look like a button (since they open a selector) */
    .search-input[readonly] {
      cursor: pointer;
      background: linear-gradient(135deg, #ffffff 0%, #f8feff 100%);
      border: 2px solid var(--tryvia-cyan);
      font-weight: 700;
    }

    .search-input[readonly]::placeholder {
      color: #00a3c7;
      font-weight: 700;
    }

    .mes-select,
    .client-modal-mes,
    .date-select {
      padding: .42rem .8rem;
      border-radius: 12px;
      font-size: 0.95rem;
      border: 2px solid var(--tryvia-cyan);
      background: var(--tryvia-white);
      color: var(--tryvia-dark);
      outline: none;
      box-shadow: var(--tryvia-card-shadow);
      appearance: none;
    }

    .btn {
      font-family: inherit;
      font-weight: 700;
      border-radius: 12px;
      padding: .5rem .9rem;
      background: linear-gradient(135deg, #ffffff 0%, #f8faff 100%);
      color: var(--tryvia-dark);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
      border: 1px solid rgba(0, 212, 255, 0.15);
      cursor: pointer;
      transition: all var(--tryvia-transition-fast);
    }

    .btn-primary {
      background: var(--tryvia-green);
      color: #fff;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    /* Toggle extra charts button */
    .toggle-graficos-btn {
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: .6rem 1rem;
      margin: 0 0 28px 0;
      cursor: pointer;
      box-shadow: var(--tryvia-card-shadow);
      transition: background-color .2s ease, opacity .2s ease;
    }

    .toggle-graficos-btn:hover {
      background: #0069d9;
    }

    /* Collapsible container for extra charts */
    #graficosIndividuais.collapsible {
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transform: translateY(-8px);
      transition: max-height .36s ease, opacity .36s ease, transform .36s ease;
    }

    #graficosIndividuais.expanded {
      max-height: 2000px;
      opacity: 1;
      transform: translateY(0);
      overflow: visible;
    }

    .cliente-modal-header {
      margin-bottom: 10px;
    }

    .planilha-toggle-btn {
      background: var(--tryvia-cyan);
      color: var(--tryvia-white);
      border: none;
      font-weight: bold;
      border-radius: 14px;
      padding: 0.6rem 0.8rem;
      cursor: pointer;
      box-shadow: var(--tryvia-card-shadow);
      font-size: 1.25rem;
      width: 44px;
      height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* smaller ranking order button */
    #rankingOrderBtn {
      padding: .28rem .46rem;
      font-size: 0.85rem;
      height: 30px;
      min-width: 30px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* trend toggle button (Em Queda / Em Alta / Reset) small */
    #rankingTrendBtn {
      padding: .28rem .46rem;
      font-size: 0.85rem;
      height: 30px;
      min-width: 36px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--tryvia-white);
      border: 1px solid rgba(0, 0, 0, 0.06);
      cursor: pointer;
    }

    .container {
      width: 100%;
      max-width: 100% !important;
      margin: 10px auto 40px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 24px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08), 0 0 0 1px rgba(0, 212, 255, 0.08);
      padding: 24px 44px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      box-sizing: border-box;
      transition: box-shadow var(--tryvia-transition-smooth);
    }

    .container:hover {
      box-shadow: 0 24px 70px rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 212, 255, 0.12);
    }

    .planilha-box {
      background: var(--tryvia-cyan-bg);
      border-radius: 16px;
      padding: 2.1rem 1.6rem;
      margin-bottom: 1.8rem;
      border: 2px solid var(--tryvia-cyan);
      width: 100%;
      max-width: 820px;
      box-sizing: border-box;
      text-align: center;
      box-shadow: var(--tryvia-card-shadow);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transform: translateY(-12px);
      transition: all .36s ease;
    }

    .planilha-box.show {
      display: flex;
      opacity: 1;
      transform: translateY(0);
    }

    .filters-bar {
      width: 100%;
      max-width: 1200px;
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 18px;
      justify-content: flex-start;
      flex-wrap: wrap;
    }

    .filters-left {
      display: flex;
      align-items: center;
      gap: 10px;
      position: relative;
    }

    /* relative to position suggestions */
    .filters-left .header-search {
      position: relative;
    }

    .filters-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }

    .date-field {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .date-field .calendar-icon {
      position: absolute;
      left: 10px;
      font-size: 0.95rem;
      color: var(--tryvia-dark2);
      pointer-events: none;
    }

    .date-field select,
    .date-field .mes-select {
      padding-left: 34px;
    }

    /* Suggestions dropdown */
    .suggestions {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      min-width: 260px;
      width: auto;
      max-width: 420px;
      background: var(--tryvia-white);
      border: 1px solid var(--tryvia-border);
      border-radius: 12px;
      box-shadow: 0 12px 34px rgba(0, 0, 0, 0.14);
      z-index: 16000;
      display: none;
      flex-direction: column;
      overflow: auto;
      max-height: 360px;
      font-weight: 700;
      text-align: left;
      padding: 8px 8px;
      box-sizing: border-box;
    }

    .suggestions.show {
      display: flex;
    }

    .suggestion-item {
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--tryvia-dark2);
      font-size: 0.95rem;
    }

    .suggestion-item:hover,
    .suggestion-item.active {
      background: linear-gradient(90deg, rgba(0, 207, 255, 0.06), rgba(0, 207, 255, 0.04));
    }

    .suggestion-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .suggestion-chs {
      font-weight: 800;
      color: #006f5a;
      background: linear-gradient(90deg, #e5fbff, #f0fdff);
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--tryvia-cyan);
    }

    /* Subtle style for inline multi-select content inside suggestions */
    .suggestions .modal-search {
      width: 100%;
      padding: .45rem .6rem;
      border-radius: 10px;
      border: 1px solid var(--tryvia-border);
      margin: 2px 0 6px;
      font-weight: 600;
    }

    .suggestions .btn {
      padding: .35rem .6rem;
      border-radius: 8px;
      font-size: .9rem;
    }

    .suggestions .compare-selector-item {
      background: var(--tryvia-white);
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.06);
      box-shadow: var(--tryvia-card-shadow);
      padding: 6px 8px;
    }

    .suggestions .compare-selector-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
    }

    /* Floating filters container */
    .floating-filters {
      display: none;
      position: fixed;
      left: 50%;
      top: 12px;
      transform: translateX(-50%);
      width: calc(1200px - 200px);
      max-width: 1000px;
      z-index: 12000;
      pointer-events: auto;
      transition: all var(--tryvia-transition-smooth);
    }

    .floating-filters .filters-inner {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: flex-start;
      background: rgba(255, 255, 255, 0.92);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 10px 14px;
      border-radius: 18px;
      border: 1px solid rgba(0, 212, 255, 0.2);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(255, 255, 255, 0.5) inset;
      transition: all var(--tryvia-transition-smooth);
      overflow: visible;
    }

    .floating-filters.show {
      display: block;
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .floating-filters.hide {
      opacity: 0;
      transform: translateX(-50%) translateY(-8px);
      display: none;
    }

    .summary-wrapper {
      width: 100%;
      margin: 0 0 20px 0;
      display: block;
    }

    .summary {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 16px;
      align-items: stretch;
    }

    .summary .box {
      background: linear-gradient(165deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 50%, rgba(240, 250, 255, 0.92) 100%);
      border-radius: 20px;
      padding: 16px 12px;
      font-size: 13px;
      text-align: center;
      border: 1px solid rgba(0, 212, 255, 0.08);
      box-shadow:
        0 4px 6px rgba(0, 0, 0, 0.02),
        0 8px 24px rgba(0, 0, 0, 0.04),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      font-weight: 700;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 80px;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .summary .box::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--tryvia-cyan) 0%, #00e4ff 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .summary .box:hover::before {
      opacity: 1;
    }

    .summary .box b {
      font-size: 1.8em;
      background: linear-gradient(135deg, var(--tryvia-dark) 0%, #444 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-top: 4px;
    }

    .summary .box:hover {
      transform: translateY(-8px);
      box-shadow:
        0 8px 16px rgba(0, 0, 0, 0.04),
        0 20px 50px rgba(0, 212, 255, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        0 0 0 1px rgba(0, 212, 255, 0.15);
    }

    .box.saude {
      color: var(--tryvia-green);
      background: linear-gradient(165deg, #e7faee 0%, #d4f4dd 50%, #c8f0d0 100%);
      border-color: rgba(0, 208, 132, 0.2);
    }

    .box.saude::before {
      background: linear-gradient(90deg, var(--tryvia-green) 0%, #00e4a0 100%);
    }

    .box.atencao {
      color: var(--tryvia-yellow);
      background: linear-gradient(165deg, #fffbe7 0%, #fff3c6 50%, #ffecb3 100%);
      border-color: rgba(255, 193, 7, 0.2);
    }

    .box.atencao::before {
      background: linear-gradient(90deg, var(--tryvia-yellow) 0%, #ffb300 100%);
    }

    .box.critico {
      color: var(--tryvia-red);
      background: linear-gradient(165deg, #ffeaea 0%, #ffd1d1 50%, #ffc4c4 100%);
      border-color: rgba(255, 71, 87, 0.2);
    }

    .box.critico::before {
      background: linear-gradient(90deg, var(--tryvia-red) 0%, #ff6b6b 100%);
    }

    .chs-geral-row {
      width: 100%;
      max-width: 1200px;
      display: flex;
      justify-content: center;
      margin-bottom: 18px;
    }

    .box.geral {
      background: linear-gradient(135deg, #e7faee 0%, #d4f4dd 100%);
      color: var(--tryvia-green);
      border-color: var(--tryvia-green);
    }

    /* Emphasis variables per status */
    #chsGeralBox {
      --chs-glow: rgba(16, 185, 129, 0.28);
    }

    #chsGeralBox.atencao {
      --chs-glow: rgba(245, 158, 11, 0.30);
    }

    #chsGeralBox.critico {
      --chs-glow: rgba(239, 68, 68, 0.30);
    }

    .box.geral .chs-heart {
      font-size: 1.6rem;
      display: inline-block;
      padding: 6px;
      border-radius: 50%;
      background: var(--tryvia-white);
      box-shadow: var(--tryvia-card-shadow);
      line-height: 1;
    }

    /* heart/icon color will follow parent status class: */
    .box.geral.saude {
      background: linear-gradient(135deg, #e7faee 0%, #d4f4dd 100%);
      border-color: var(--tryvia-green);
      color: var(--tryvia-green);
    }

    .box.geral.saude .chs-heart {
      color: var(--tryvia-green);
    }

    .box.geral.atencao {
      background: linear-gradient(135deg, #fffbe7 0%, #fff3c6 100%);
      border-color: var(--tryvia-yellow);
      color: var(--tryvia-yellow);
    }

    .box.geral.atencao .chs-heart {
      color: var(--tryvia-yellow);
    }

    .box.geral.critico {
      background: linear-gradient(135deg, #ffeaea 0%, #ffd1d1 100%);
      border-color: var(--tryvia-red);
      color: var(--tryvia-red);
    }

    .box.geral.critico .chs-heart {
      color: var(--tryvia-red);
    }

    @keyframes pulse-health {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.03);
      }
    }

    /* Neon heartbeat glow behind CHS Geral value */
    #chsGeralBox {
      position: relative;
      overflow: visible;
    }

    #chsGeralBox::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 58%;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(closest-side, var(--chs-glow), rgba(0, 0, 0, 0) 70%);
      filter: blur(8px);
      transform: translate(-50%, -50%) scale(0.95);
      opacity: .75;
      pointer-events: none;
      animation: heart-glow 1.6s ease-in-out infinite;
    }

    @keyframes heart-glow {

      0%,
      100% {
        transform: translate(-50%, -50%) scale(0.92);
        opacity: .6;
      }

      50% {
        transform: translate(-50%, -50%) scale(1.06);
        opacity: 1;
      }
    }

    @keyframes glowPulse {

      0%,
      100% {
        box-shadow: var(--tryvia-card-shadow), 0 0 0 0 var(--chs-glow);
      }

      50% {
        box-shadow: var(--tryvia-card-shadow), 0 0 0 10px var(--chs-glow);
      }
    }

    .dashboard-charts-row {
      width: 100%;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 24px;
      margin: 20px 0;
    }

    .dashboard-chart-container {
      background: linear-gradient(165deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 50%, rgba(240, 250, 255, 0.92) 100%);
      border-radius: 24px;
      box-shadow:
        0 4px 6px rgba(0, 0, 0, 0.02),
        0 12px 40px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      border: 3px solid transparent;
      background-image:
        linear-gradient(165deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 50%, rgba(240, 250, 255, 0.92) 100%),
        linear-gradient(135deg, #00d4ff 0%, #0066ff 25%, #00e4ff 50%, #0099ff 75%, #00d4ff 100%);
      background-origin: border-box;
      background-clip: padding-box, border-box;
      padding: 20px;
      height: 440px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      box-sizing: border-box;
      position: relative;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }

    .dashboard-chart-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--tryvia-cyan) 0%, #00e4ff 50%, var(--tryvia-green) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .dashboard-chart-container:hover::before {
      opacity: 1;
    }

    .dashboard-chart-container:hover {
      transform: translateY(-6px);
      box-shadow:
        0 8px 16px rgba(0, 0, 0, 0.04),
        0 24px 60px rgba(0, 212, 255, 0.18),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        0 0 0 2px rgba(0, 212, 255, 0.3);
      border-width: 3px;
    }

    .dashboard-chart-container h3 {
      color: var(--tryvia-dark);
      font-weight: 800;
      font-size: 13px;
      margin: 0 0 16px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      text-align: center;
      white-space: normal;
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .dashboard-chart-container h3 i {
      font-size: 1rem;
      background: linear-gradient(135deg, var(--tryvia-cyan) 0%, #00b8d4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .chart-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 8px;
      min-height: 0;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 16px;
      margin-top: 4px;
    }

    .chart-wrapper canvas {
      width: 100% !important;
      height: 100% !important;
      max-width: 100% !important;
      max-height: 100% !important;
    }

    .chart-toggle-btn,
    .fullscreen-btn {
      position: absolute;
      top: 12px;
      width: 32px;
      height: 32px;
      min-width: 32px;
      min-height: 32px;
      border-radius: 10px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.9) 100%);
      border: 1px solid rgba(0, 212, 255, 0.1);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04), 0 4px 16px rgba(0, 212, 255, 0.08);
      transition: all 0.25s ease;
      z-index: 3;
      font-size: 0.75rem;
      padding: 0;
      opacity: 0;
      pointer-events: none;
    }

    /* Show buttons on chart/ranking container hover */
    .dashboard-chart-container:hover .chart-toggle-btn,
    .dashboard-chart-container:hover .fullscreen-btn,
    .dashboard-ranking-container:hover .fullscreen-btn {
      opacity: 1;
      pointer-events: auto;
    }

    .chart-toggle-btn:hover,
    .fullscreen-btn:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06), 0 8px 24px rgba(0, 212, 255, 0.15);
      border-color: rgba(0, 212, 255, 0.25);
    }

    .fullscreen-btn {
      left: 8px;
    }

    .chart-toggle-btn {
      left: calc(8px + 32px + 4px);
    }

    /* 8px + btn width + gap */
    .dashboard-chart-container .chart-wrapper+.chart-wrapper {
      margin-top: 12px;
    }

    .dashboard-chart-container:fullscreen,
    .dashboard-ranking-container:fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      max-width: none !important;
      max-height: none !important;
      border-radius: 0;
      padding: 48px;
      box-shadow: none;
      background: #fff;
    }

    .dashboard-ranking-container:fullscreen {
      overflow: auto;
    }

    .dashboard-ranking-container:fullscreen .dashboard-ranking-list,
    .dashboard-ranking-container:fullscreen #rankingGeralList {
      max-height: calc(100vh - 160px) !important;
      overflow-y: auto;
      gap: 16px;
    }

    .dashboard-ranking-container:fullscreen h3 {
      font-size: 2.5rem !important;
      margin-bottom: 32px !important;
      position: relative !important;
      left: auto !important;
      top: auto !important;
      transform: none !important;
    }

    .dashboard-ranking-container:fullscreen .ranking-card-header h3 {
      position: relative !important;
      left: auto !important;
      top: auto !important;
      transform: none !important;
      font-size: 2.5rem !important;
    }

    /* Estilos fullscreen para todos os rankings incluindo ranking geral */
    .dashboard-ranking-container:fullscreen .dashboard-ranking-list li,
    .dashboard-ranking-container:fullscreen #rankingGeralList li {
      font-size: 1.4rem;
      padding: 1.4em 2em;
      border-radius: 20px;
      margin-bottom: 0;
      height: auto !important;
      min-height: 70px;
    }

    .dashboard-ranking-container:fullscreen .dashboard-ranking-list .rank,
    .dashboard-ranking-container:fullscreen #rankingGeralList .rank {
      min-width: 70px;
      font-size: 1.5rem !important;
      padding: .7em 1em;
      border-radius: 16px;
    }

    .dashboard-ranking-container:fullscreen .dashboard-ranking-list .client,
    .dashboard-ranking-container:fullscreen #rankingGeralList .client {
      font-size: 1.5rem !important;
    }

    .dashboard-ranking-container:fullscreen .dashboard-ranking-list .score,
    .dashboard-ranking-container:fullscreen #rankingGeralList .score {
      font-size: 1.4rem !important;
      padding: .7em 1.2em;
      border-radius: 14px;
      min-width: 80px;
    }

    .dashboard-ranking-container:fullscreen .dashboard-ranking-list .delta-badge,
    .dashboard-ranking-container:fullscreen #rankingGeralList .delta-badge {
      font-size: 1.1rem !important;
      padding: .5em 1em;
    }

    .ranking-pagination {
      display: flex;
      align-items: center;
      gap: 2px;
      justify-content: center;
      margin-top: 4px;
    }

    .ranking-pagination #rankingPageInfo {
      font-weight: 800;
      color: #000;
      font-size: .75rem;
    }

    .ranking-pagination .btn {
      padding: .15rem .3rem;
      font-size: .7rem;
      border-radius: 6px;
      min-width: 24px;
      height: 24px;
    }

    .dashboard-ranking-container:fullscreen .ranking-pagination {
      margin-top: 16px;
    }

    .dashboard-ranking-container:fullscreen .ranking-pagination .btn {
      padding: .3rem .6rem;
      font-size: 1rem;
      min-width: 40px;
      height: 40px;
    }

    .dashboard-ranking-container:fullscreen .ranking-pagination #rankingPageInfo {
      font-size: 1rem;
    }

    body.dark-theme .ranking-pagination #rankingPageInfo {
      color: #fff;
    }

    /* Ranking titles - all use the same positioning */
    .dashboard-ranking-container h3 {
      margin: 0;
      position: absolute;
      left: 50%;
      top: 14px;
      transform: translateX(-50%);
      font-size: 13px;
      color: var(--tryvia-dark);
      font-weight: 800;
      text-align: center;
      white-space: nowrap;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dashboard-ranking-container h3 i {
      font-size: 1rem;
      background: linear-gradient(135deg, var(--tryvia-cyan) 0%, #667eea 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    body.dark-theme #rankingPiores h3,
    body.dark-theme #rankingMelhores h3,
    body.dark-theme .dashboard-ranking-container.ranking-geral h3,
    body.dark-theme .dashboard-chart-container h3,
    body.dark-theme h1,
    body.dark-theme h2 {
      color: #fff !important;
    }

    body.dark-theme .ranking-pagination #rankingPageInfo {
      color: #fff;
    }

    body.dark-theme .btn {
      color: #f8fafc;
    }

    body.dark-theme .help-btn,
    body.dark-theme .fullscreen-btn,
    body.dark-theme .chart-toggle-btn {
      color: #fff;
    }

    .dashboard-rankings-row {
      width: 100%;
      display: flex;
      gap: 24px;
      margin: 20px 0;
      align-items: stretch;
    }

    .dashboard-ranking-container {
      background: linear-gradient(165deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 50%, rgba(240, 250, 255, 0.92) 100%);
      border-radius: 24px;
      box-shadow:
        0 4px 6px rgba(0, 0, 0, 0.02),
        0 12px 40px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      border: 3px solid transparent;
      background-image:
        linear-gradient(165deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 50%, rgba(240, 250, 255, 0.92) 100%),
        linear-gradient(135deg, #00d4ff 0%, #0066ff 25%, #667eea 50%, #0099ff 75%, #00d4ff 100%);
      background-origin: border-box;
      background-clip: padding-box, border-box;
      padding: 20px;
      display: flex;
      flex-direction: column;
      height: 380px;
      box-sizing: border-box;
      position: relative;
      flex: 1;
      min-width: 0;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }

    .dashboard-ranking-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--tryvia-cyan) 0%, #667eea 50%, #764ba2 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .dashboard-ranking-container:hover::before {
      opacity: 1;
    }

    .dashboard-ranking-container:hover {
      transform: translateY(-6px);
      box-shadow:
        0 8px 16px rgba(0, 0, 0, 0.04),
        0 24px 60px rgba(0, 212, 255, 0.18),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        0 0 0 2px rgba(0, 212, 255, 0.3);
      border-width: 3px;
    }

    .dashboard-ranking-container .dashboard-ranking-list {
      flex: 1 1 auto;
      width: 100%;
      overflow: hidden;
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }

    .dashboard-ranking-container .fullscreen-btn {
      position: absolute;
      top: 14px;
      left: 14px;
      width: 40px;
      height: 40px;
      border-radius: 14px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.9) 100%);
      border: 1px solid rgba(0, 212, 255, 0.1);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04), 0 4px 16px rgba(0, 212, 255, 0.08);
      z-index: 3;
      transition: all 0.25s ease;
    }

    .dashboard-ranking-container .fullscreen-btn:hover {
      transform: translateY(-2px) scale(1.08);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06), 0 8px 24px rgba(0, 212, 255, 0.18);
      border-color: rgba(0, 212, 255, 0.25);
    }

    .dashboard-ranking-container.ranking-geral {
      background: linear-gradient(165deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 50%, rgba(240, 250, 255, 0.92) 100%);
      border: 3px solid transparent;
      background-image:
        linear-gradient(165deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 50%, rgba(240, 250, 255, 0.92) 100%),
        linear-gradient(135deg, #00d4ff 0%, #0066ff 25%, #667eea 50%, #0099ff 75%, #00d4ff 100%);
      background-origin: border-box;
      background-clip: padding-box, border-box;
      height: 380px;
      padding: 20px;
      flex: 1;
      min-width: 0;
    }

    .dashboard-ranking-container.ranking-geral .dashboard-ranking-list {
      flex: 1 1 auto;
      width: 100%;
      overflow: hidden;
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }

    .dashboard-ranking-container.ranking-geral h3 {
      visibility: visible !important;
      opacity: 1 !important;
      z-index: 10 !important;
    }

    .dashboard-ranking-container.ranking-geral .dashboard-ranking-list {
      flex: 1 1 auto;
      width: 100%;
      overflow: auto;
      margin-top: 40px;
    }

    /* Ranking list polish + medals */


    /* header inside ranking card to align title and small button horizontally */
    .ranking-card-header {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
      margin-bottom: 10px;
      position: relative;
    }

    /* Plano de AÃ§Ã£o overlay */
    .plano-acao-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      z-index: 20010;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: auto;
      min-height: 100vh;
      padding: 24px 20px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .plano-acao-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .plano-acao-box {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.96) 100%);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 24px;
      border: 1px solid rgba(0, 212, 255, 0.2);
      box-shadow: 0 30px 90px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(0, 212, 255, 0.12);
      width: 92%;
      max-width: 820px;
      max-height: none;
      overflow: visible;
      padding: 32px;
      text-align: left;
      position: relative;
      animation: modalSlideUp 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .plano-acao-box h3 {
      margin: 0 0 8px 0;
      color: #000;
      font-size: 1.15rem;
    }

    .plano-acao-box h4 {
      margin: 10px 0 6px 0;
      color: var(--tryvia-cyan);
      font-size: 1.02rem;
    }

    .plano-acao-box ul {
      margin: 6px 0 10px 18px;
      padding: 0;
    }

    .plano-acao-box li {
      margin: 4px 0;
    }

    .plano-acao-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 10px;
    }

    .plano-acao-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
      color: #fff;
      border: none;
      border-radius: 10px;
      padding: 0;
      width: 36px;
      height: 36px;
      font-weight: 900;
      font-size: 1.1rem;
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);
      transition: all 0.25s ease;
      z-index: 10;
    }

    .plano-acao-close:hover {
      background: linear-gradient(135deg, #ff5252 0%, #e53935 100%);
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 71, 87, 0.45);
    }

    .plano-acao-trigger {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }

    .plano-acao-trigger .btn {
      padding: .65rem 1.1rem;
      font-size: 1.05rem;
      min-width: 200px;
    }

    /* Help modal */
    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      z-index: 20020;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .help-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .help-box {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.96) 100%);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(0, 212, 255, 0.2);
      border-radius: 24px;
      width: 96%;
      max-width: 980px;
      max-height: 86vh;
      overflow: auto;
      padding: 32px;
      box-shadow: 0 30px 90px rgba(0, 0, 0, 0.22), 0 0 0 1px rgba(0, 212, 255, 0.12);
      position: relative;
      text-align: left;
      transform: translateY(30px) scale(0.95);
      opacity: 0;
      transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease;
    }

    .help-overlay.show .help-box {
      transform: translateY(0) scale(1);
      opacity: 1;
    }

    .help-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
      color: #fff;
      border: none;
      border-radius: 10px;
      padding: 0;
      width: 36px;
      height: 36px;
      font-size: 1.1rem;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);
      transition: all 0.25s ease;
      z-index: 10;
    }

    .help-close:hover {
      background: linear-gradient(135deg, #ff5252 0%, #e53935 100%);
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 71, 87, 0.45);
    }

    .help-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      font-weight: 900;
      background: #e9eef0;
      color: #000;
      border: 1px solid var(--tryvia-border);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    /* Help content layout */
    .help-hero {
      display: flex;
      align-items: stretch;
      gap: 16px;
      background: linear-gradient(90deg, #f0fdff, #e5fbff);
      border: 1px solid var(--tryvia-cyan);
      border-radius: 14px;
      padding: 14px;
    }

    .help-hero .hero-left {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .help-hero .hero-title {
      font-size: 1.4rem;
      font-weight: 900;
      color: #000;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .help-hero .hero-sub {
      color: #0b63b7;
      font-weight: 700;
    }

    .help-hero .pill-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: .35rem .55rem;
      border-radius: 999px;
      border: 2px solid var(--tryvia-border);
      font-weight: 800;
      background: #fff;
    }

    .pill .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .pill.saude {
      border-color: #009f42;
    }

    .pill.saude .dot {
      background: #009f42;
    }

    .pill.atencao {
      border-color: #ffc900;
    }

    .pill.atencao .dot {
      background: #ffc900;
    }

    .pill.critico {
      border-color: #e53935;
    }

    .pill.critico .dot {
      background: #e53935;
    }

    .help-hero .hero-right {
      flex: 0 0 260px;
      width: 260px;
      min-width: 220px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: #fff;
      border: 1px dashed var(--tryvia-cyan);
      border-radius: 12px;
      padding: 10px;
      box-sizing: border-box;
    }

    .help-hero .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      font-weight: 700;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: .2rem .45rem;
      border-radius: 999px;
      background: #f7fafb;
      border: 1px solid var(--tryvia-border);
    }

    .legend-item .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .legend-sla .dot {
      background: #0b63b7;
    }

    .legend-nps .dot {
      background: #6b43b8;
    }

    .legend-neg .dot {
      background: #e53935;
    }

    .legend-cs .dot {
      background: #009f42;
    }

    .help-hero .hero-right canvas {
      width: 200px !important;
      height: 200px !important;
      max-width: 200px;
      max-height: 200px;
      display: block;
    }

    .help-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
    }

    .help-tile {
      background: #fff;
      border: 2px solid var(--tryvia-cyan);
      border-radius: 12px;
      box-shadow: var(--tryvia-card-shadow);
      padding: 12px;
      display: flex;
      gap: 10px;
      align-items: flex-start;
    }

    .help-tile .tile-icon {
      font-size: 1.4rem;
    }

    .help-tile h4 {
      margin: 0 0 6px 0;
      color: #000;
    }

    .help-tile p {
      margin: 0;
    }

    .help-section {
      background: #fff;
      border: 1px solid var(--tryvia-border);
      border-radius: 12px;
      padding: 12px;
      margin-top: 12px;
    }

    .help-section h4 {
      margin: 0 0 8px 0;
      color: #0b63b7;
    }

    @media (max-width:900px) {
      .help-box {
        width: 96%;
        padding: 12px;
      }

      .help-hero {
        flex-direction: column;
      }

      .help-hero .hero-right {
        width: 100%;
      }

      .help-grid {
        grid-template-columns: 1fr;
      }
    }

    /* CHS top badge and chart title */
    .chs-top-badge {
      display: inline-block;
      background: linear-gradient(90deg, #e5fbff, #f0fdff);
      border: 2px solid var(--tryvia-cyan);
      color: #000;
      font-weight: 800;
      padding: .4rem .7rem;
      border-radius: 12px;
      box-shadow: var(--tryvia-card-shadow);
      margin: 4px 0 8px 0;
    }

    .chart-title {
      font-weight: 800;
      color: #000;
      font-size: .95rem;
      margin: 0 0 6px 0;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .chart-title .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--tryvia-cyan);
      display: inline-block;
    }

    /* Chart help icon with tooltip */
    .chart-help {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      margin-right: 8px;
      border-radius: 50%;
      background: var(--tryvia-white);
      color: var(--tryvia-cyan);
      font-weight: 900;
      font-size: 0.9rem;
      border: 2px solid var(--tryvia-cyan);
      cursor: default;
      position: relative;
    }

    .chart-help::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translate(-50%, -8px);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 8px 10px;
      border-radius: 10px;
      white-space: normal;
      max-width: 340px;
      width: max-content;
      pointer-events: none;
      opacity: 0;
      transition: opacity .12s ease, transform .12s ease;
      z-index: 21000;
      box-shadow: 0 8px 26px rgba(0, 0, 0, 0.36);
    }

    .chart-help:hover::after {
      opacity: 1;
      transform: translate(-50%, -12px);
    }

    .chart-help-btn {
      position: absolute;
      top: 10px;
      left: 12px;
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: var(--tryvia-white);
      color: var(--tryvia-cyan);
      border: 1px solid rgba(0, 0, 0, 0.06);
      cursor: default;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      box-shadow: var(--tryvia-card-shadow);
    }

    .chart-help-btn::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translate(-50%, -8px);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 8px 10px;
      border-radius: 10px;
      white-space: normal;
      max-width: 340px;
      width: max-content;
      pointer-events: none;
      opacity: 0;
      transition: opacity .12s ease, transform .12s ease;
      z-index: 21000;
      box-shadow: 0 8px 26px rgba(0, 0, 0, 0.36);
    }

    .chart-help-btn:hover::after {
      opacity: 1;
      transform: translate(-50%, -12px);
    }

    /* PDCA styling */
    .pdca-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }

    .pdca-card {
      background: var(--tryvia-white);
      border: 2px solid var(--tryvia-cyan);
      border-radius: 12px;
      padding: 10px;
      box-shadow: var(--tryvia-card-shadow);
    }

    .pdca-card .pdca-head {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 800;
      color: #000;
      margin-bottom: 6px;
    }

    .pdca-icon {
      font-size: 1.1rem;
    }

    .pdca-plan {
      border-color: #0b63b7;
    }

    .pdca-do {
      border-color: #009f42;
    }

    .pdca-check {
      border-color: #ffc900;
    }

    .pdca-act {
      border-color: #e53935;
    }

    /* Center the h3 horizontally inside the card using absolute centering so it aligns in middle of card horizontally */
    .ranking-card-header {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
      margin-bottom: 10px;
      position: relative;
      height: 40px;
    }

    .ranking-card-header h3 {
      margin: 0;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      top: 10px;
    }

    #indicadorTitle {
      top: 0px !important;
    }

    /* Chart titles with 16px font size */
    .dashboard-chart-container h3 {
      font-size: 16px !important;
    }

    /* Icones cinza estilo okokok.html */
    .dashboard-chart-container h3 i,
    .dashboard-ranking-container h3 i {
      color: var(--tryvia-dark2);
      margin-right: 8px;
      font-size: 0.9em;
    }

    /* Icones cinza para calendÃ¡rio e busca */
    .calendar-icon {
      color: var(--tryvia-dark2);
      font-size: 0.9em;
    }

    .search-icon {
      color: var(--tryvia-dark2);
      font-size: 0.9em;
    }

    /* Icones para botÃµes */
    .chart-toggle-btn i,
    .chart-help-btn i,
    .fullscreen-btn i {
      color: var(--tryvia-dark2);
      font-size: 0.9em;
    }

    /* Icones para botÃ£o de tema */
    #themeToggleBtn i {
      color: var(--tryvia-dark2);
      font-size: 0.9em;
    }

    /* Icones para botÃ£o de ajuda */
    .help-btn i {
      color: var(--tryvia-dark2);
      font-size: 0.9em;
    }

    /* Icones para setas de navegaÃ§Ã£o */
    .nav-arrow-btn i {
      color: var(--tryvia-dark2);
      font-size: 0.9em;
    }

    .ranking-order-wrap {
      display: flex;
      align-items: center;
      gap: 4px;
      position: absolute;
      right: 12px;
      top: -2px;
      z-index: 2;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    /* Show filter buttons on ranking container hover */
    .dashboard-ranking-container:hover .ranking-order-wrap {
      opacity: 1;
      pointer-events: auto;
    }

    .dashboard-ranking-container.ranking-geral .ranking-order-wrap {
      top: -6px;
    }

    .ranking-order-wrap .btn {
      padding: 0 12px;
      font-size: 0.85rem;
      border-radius: 10px;
      height: 36px;
      min-width: 60px;
      font-weight: 700;
      background: var(--tryvia-white);
      border: 1px solid rgba(0, 0, 0, 0.06);
      box-shadow: var(--tryvia-card-shadow);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* Filters dropdown (for Ranking Geral) */
    .filters-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 6px;
      background: var(--tryvia-white);
      border: 1px solid var(--tryvia-border);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      padding: 6px;
      display: none;
      min-width: 160px;
      z-index: 10;
    }

    .filters-item {
      display: block;
      width: 100%;
      text-align: left;
      background: transparent;
      border: none;
      padding: 8px 10px;
      border-radius: 8px;
      font-weight: 700;
      color: var(--tryvia-dark2);
      cursor: pointer;
    }

    .filters-item:hover {
      background: linear-gradient(90deg, rgba(0, 207, 255, 0.06), rgba(0, 207, 255, 0.04));
    }

    .filters-menu .separator {
      height: 1px;
      background: var(--tryvia-gray2);
      margin: 4px 0;
      border-radius: 1px;
    }

    /* small delta badge to indicate change from previous month */
    .delta-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 800;
      font-size: 0.82rem;
      padding: .18rem .5rem;
      border-radius: 999px;
      color: #fff;
      min-width: 36px;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      margin-left: 8px;
    }

    .delta-up {
      background: linear-gradient(90deg, #0fb06a, #007a33);
      color: #fff;
    }

    .delta-down {
      background: linear-gradient(90deg, #ff7b7b, #e53935);
      color: #fff;
    }

    .delta-neutral {
      background: linear-gradient(90deg, #e9eef0, #dfeef4);
      color: #006f5a;
    }

    #rankingGeralList {
      width: 100%;
      list-style: none;
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: 8px;
    }

    .dashboard-ranking-list {
      width: 100%;
      list-style: none;
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .dashboard-ranking-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 252, 255, 0.9) 100%);
      border-radius: 14px;
      padding: 10px 14px;
      margin-bottom: 0;
      font-weight: 700;
      cursor: pointer;
      border: 1px solid rgba(0, 212, 255, 0.1);
      height: 48px;
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.02), 0 4px 16px rgba(0, 212, 255, 0.04);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .dashboard-ranking-list .perf-meter {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0;
      background: linear-gradient(90deg,
          rgba(0, 212, 255, 0.15) 0%,
          rgba(0, 208, 132, 0.12) 50%,
          rgba(0, 208, 132, 0.06) 100%);
      z-index: 0;
      border-radius: 14px;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* DegradÃª baseado na saÃºde do cliente */
    .dashboard-ranking-list li.status-saude .perf-meter {
      background: linear-gradient(90deg,
          rgba(0, 208, 132, 0.25) 0%,
          rgba(0, 208, 132, 0.15) 40%,
          rgba(0, 228, 160, 0.08) 100%);
    }

    .dashboard-ranking-list li.status-atencao .perf-meter {
      background: linear-gradient(90deg,
          rgba(255, 193, 7, 0.25) 0%,
          rgba(255, 193, 7, 0.15) 40%,
          rgba(255, 215, 64, 0.08) 100%);
    }

    .dashboard-ranking-list li.status-critico .perf-meter {
      background: linear-gradient(90deg,
          rgba(255, 71, 87, 0.25) 0%,
          rgba(255, 71, 87, 0.15) 40%,
          rgba(255, 107, 107, 0.08) 100%);
    }

    .dashboard-ranking-list li>* {
      position: relative;
      z-index: 1;
    }

    .dashboard-ranking-list li:hover {
      transform: translateX(4px);
      border-color: rgba(0, 212, 255, 0.25);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04), 0 8px 24px rgba(0, 212, 255, 0.1);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(240, 252, 255, 0.95) 100%);
    }

    /* Ranking navigation arrows - minimal and discrete */
    .ranking-nav-arrows {
      display: flex;
      justify-content: center;
      gap: 4px;
      margin-top: 2px;
      padding: 2px 4px;
    }

    .nav-arrow-btn {
      width: 20px;
      height: 20px;
      border: 1px solid var(--tryvia-cyan);
      background: var(--tryvia-white);
      color: var(--tryvia-cyan);
      font-size: 10px;
      cursor: pointer;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: all 0.2s ease;
    }

    .nav-arrow-btn:hover:not(:disabled) {
      background: var(--tryvia-cyan);
      color: white;
      opacity: 1;
    }

    .nav-arrow-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .dashboard-ranking-list .rank {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.9) 100%);
      color: var(--tryvia-cyan);
      border-radius: 12px;
      padding: 6px 10px;
      border: 1px solid rgba(0, 212, 255, 0.15);
      font-weight: 800;
      font-size: 0.85rem;
      min-width: 38px;
      text-align: center;
      margin-right: 12px;
      box-shadow: 0 2px 6px rgba(0, 212, 255, 0.08);
    }

    .dashboard-ranking-list li:nth-child(1) .rank {
      background: linear-gradient(135deg, #ffd700 0%, #ffb800 100%);
      color: #fff;
      border-color: rgba(255, 184, 0, 0.3);
      box-shadow: 0 2px 8px rgba(255, 184, 0, 0.25);
    }

    .dashboard-ranking-list li:nth-child(2) .rank {
      background: linear-gradient(135deg, #c0c0c0 0%, #a8a8a8 100%);
      color: #fff;
      border-color: rgba(168, 168, 168, 0.3);
      box-shadow: 0 2px 8px rgba(168, 168, 168, 0.25);
    }

    .dashboard-ranking-list li:nth-child(3) .rank {
      background: linear-gradient(135deg, #cd7f32 0%, #b8722d 100%);
      color: #fff;
      border-color: rgba(184, 114, 45, 0.3);
      box-shadow: 0 2px 8px rgba(184, 114, 45, 0.25);
    }

    .dashboard-ranking-list .client {
      flex: 1;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
      color: var(--tryvia-dark);
    }

    .dashboard-ranking-list .score {
      margin-left: 8px;
      font-size: 0.85rem;
      color: #fff;
      font-weight: 800;
      padding: 6px 12px;
      border-radius: 10px;
      min-width: 50px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* efeitos hover - jÃ¡ definidos acima com mais detalhes */



    /* Modal-centered overlay styles (ensure select/compare open as overlay, centered) */
    .compare-selector-modal,
    .compare-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 15000;
      font-family: 'Roboto', Arial, sans-serif !important;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .compare-selector-modal.show,
    .compare-modal.show {
      opacity: 1;
    }

    .compare-selector-box,
    .compare-modal-box,
    .compare-selector-box .compare-selector-list {
      box-sizing: border-box;
    }

    .compare-selector-box,
    .compare-modal-box {
      width: 95%;
      max-width: 760px;
      background: rgba(255, 255, 255, 0.98);
      border-radius: 24px;
      padding: 20px;
      box-shadow: 0 30px 100px rgba(0, 0, 0, 0.18), 0 0 0 1px rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.15);
      display: flex;
      flex-direction: column;
      gap: 14px;
      animation: modalSlideUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    /* Standardized modal header/body for select/compare */
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(0, 212, 255, 0.15);
    }

    .modal-title {
      font-size: 1.2rem;
      font-weight: 800;
      color: var(--tryvia-cyan);
      white-space: normal;
      line-height: 1.3;
      max-width: 280px;
    }

    .modal-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .modal-controls .btn {
      white-space: nowrap;
    }

    .modal-body {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }

    .modal-body .list-area {
      flex: 1;
      min-width: 220px;
      max-height: 380px;
      overflow: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      border-radius: 16px;
      background: rgba(0, 212, 255, 0.02);
    }

    .modal-body .info-area {
      width: 320px;
      max-width: 40%;
      min-width: 220px;
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.06) 0%, rgba(0, 212, 255, 0.02) 100%);
      border-radius: 16px;
      padding: 14px;
      border: 1px solid rgba(0, 212, 255, 0.15);
      box-shadow: 0 8px 32px rgba(0, 212, 255, 0.08);
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-start;
      justify-content: flex-start;
    }

    .compare-selector-list,
    #selectModalList {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .compare-selector-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: var(--tryvia-white);
      border: 1px solid rgba(0, 0, 0, 0.06);
      box-shadow: var(--tryvia-card-shadow);
      font-weight: 700;
      cursor: pointer;
    }

    .compare-selector-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.06);
    }

    .compare-selector-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
      margin: 0;
      accent-color: var(--tryvia-cyan);
    }

    .compare-selector-item span.client-name {
      flex: 1;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .compare-selector-item .chs-badge {
      font-weight: 800;
      color: #006f5a;
      padding: .25rem .6rem;
      border-radius: 8px;
      background: linear-gradient(90deg, #e5fbff, #f0fdff);
      border: 1px solid var(--tryvia-cyan);
      min-width: 56px;
      text-align: center;
    }

    /* Make modal action buttons consistent */
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding-top: 6px;
      border-top: 1px solid transparent;
    }

    .modal-actions .btn {
      min-width: 110px;
    }

    /* Improve text smoothing and rendering across UI (including modals) */
    body,
    .cliente-modal-box,
    .compare-modal-box,
    .plano-acao-box {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }

    /* Hint sharper canvas rendering */
    .cliente-modal-box canvas {
      image-rendering: -webkit-optimize-contrast;
    }

    /* Compare chart modal - standardized */
    .compare-modal-box {
      max-width: 880px;
      width: 92%;
      padding: 14px;
    }

    .compare-modal-box .modal-body {
      flex-direction: column;
    }

    .compare-modal-box canvas {
      width: 100% !important;
      height: 360px !important;
    }

    .cliente-modal-right>div {
      overflow: hidden;
    }

    .cliente-modal-right canvas {
      display: block;
      max-width: 100%;
      animation: none !important;
    }

    /* client modal overlay - smooth open/close without flicker */
    .details-modal,
    .edit-modal,
    .call-modal,
    .cliente-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 13000;
      font-family: 'Roboto', Arial, sans-serif !important;
      overflow: auto;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .cliente-modal.modal-open {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .cliente-modal-box {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.97) 0%, rgba(248, 252, 255, 0.95) 100%);
      border-radius: 28px;
      max-width: 780px;
      width: 94vw;
      padding: 1.8rem 2rem;
      border: 1px solid rgba(0, 212, 255, 0.18);
      box-shadow:
        0 32px 80px rgba(0, 0, 0, 0.18),
        0 0 0 1px rgba(0, 212, 255, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      max-height: 88vh;
      overflow: visible;
      text-align: left;
      position: relative;
      transform: translateY(40px) scale(0.94);
      opacity: 0;
      transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.35s ease;
      will-change: transform, opacity;
      backface-visibility: hidden;
    }

    .cliente-modal.modal-open .cliente-modal-box {
      transform: translateY(0) scale(1);
      opacity: 1;
    }

    .cliente-modal.modal-closing .cliente-modal-box {
      transform: translateY(20px) scale(0.97);
      opacity: 0;
      transition: transform 0.28s cubic-bezier(0.4, 0, 1, 1), opacity 0.25s ease;
    }

    .cliente-modal-box .close-modal {
      position: absolute;
      top: 16px;
      right: 16px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(240, 240, 240, 0.95) 100%);
      color: #666;
      border: 1px solid rgba(0, 0, 0, 0.08);
      font-size: 0.9rem;
      font-weight: 600;
      border-radius: 12px;
      padding: .5rem 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .cliente-modal-box .close-modal:hover {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
      color: #fff;
      border-color: transparent;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 71, 87, 0.35);
    }

    .modal-search {
      width: 100%;
      padding: .6rem .8rem;
      border-radius: 14px;
      border: 1px solid rgba(0, 212, 255, 0.2);
      margin-bottom: .7rem;
      background: rgba(255, 255, 255, 0.9);
      transition: all var(--tryvia-transition-fast);
    }

    .modal-search:focus {
      border-color: var(--tryvia-cyan);
      box-shadow: 0 4px 20px rgba(0, 212, 255, 0.15);
      outline: none;
    }

    @keyframes modalSlideIn {
      from {
        transform: translateY(-8px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Modern animations - kept for other modals */
    @keyframes overlayFadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes modalSlideUp {
      from {
        transform: translateY(30px) scale(0.95);
        opacity: 0;
      }

      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    @keyframes modalSlideDown {
      from {
        transform: translateY(0) scale(1);
        opacity: 1;
      }

      to {
        transform: translateY(20px) scale(0.97);
        opacity: 0;
      }
    }

    /* Enhanced cliente-modal styling */
    .cliente-modal-header h2 {
      font-size: 1.35rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--tryvia-cyan) 0%, #00b8d4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .cliente-modal-body {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }

    .cliente-modal-left {
      flex: 1;
      min-width: 240px;
    }

    .cliente-modal-right {
      flex: 1;
      min-width: 240px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .cliente-modal-right>div {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 100%);
      border-radius: 18px;
      padding: 16px;
      border: 1px solid rgba(0, 212, 255, 0.1);
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.03), inset 0 1px 0 rgba(255, 255, 255, 0.9);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }

    .cliente-modal-right>div:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 40px rgba(0, 212, 255, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.9);
      border-color: rgba(0, 212, 255, 0.2);
    }

    .cliente-modal-right h4 {
      font-size: 1rem;
      font-weight: 700;
      margin: 0 0 12px 0;
      background: linear-gradient(135deg, var(--tryvia-cyan) 0%, #00b8d4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .cliente-modal-right .chart-title {
      font-size: 0.85rem;
      font-weight: 700;
      color: #555;
      margin: 0 0 10px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .cliente-modal-right .chart-title .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--tryvia-cyan) 0%, #00b8d4 100%);
      box-shadow: 0 0 8px rgba(0, 212, 255, 0.4);
    }

    .cliente-modal-right canvas {
      border-radius: 12px;
    }

    .cliente-notas {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px !important;
    }

    .nota-rect {
      padding: 14px 10px !important;
      min-width: 0 !important;
      border-radius: 14px !important;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 252, 255, 0.95) 100%) !important;
      border: 2px solid rgba(0, 212, 255, 0.2) !important;
      box-shadow: 0 4px 16px rgba(0, 212, 255, 0.08), inset 0 1px 0 rgba(255, 255, 255, 0.9) !important;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1) !important;
    }

    .nota-rect:hover {
      transform: translateY(-3px) !important;
      border-color: var(--tryvia-cyan) !important;
      box-shadow: 0 8px 28px rgba(0, 212, 255, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.9) !important;
    }

    .cliente-dados-gestor {
      background: linear-gradient(145deg, rgba(0, 212, 255, 0.06) 0%, rgba(0, 212, 255, 0.02) 100%) !important;
      border: 1px solid rgba(0, 212, 255, 0.15) !important;
      border-radius: 14px !important;
      padding: 14px 16px !important;
      font-size: 0.92rem !important;
      line-height: 1.6;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
    }

    .status-large {
      border-radius: 16px !important;
      padding: 14px 16px !important;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
    }

    .plano-acao-trigger .btn {
      border-radius: 14px !important;
      padding: 12px 24px !important;
      font-weight: 700;
      box-shadow: 0 4px 16px rgba(0, 208, 132, 0.25);
      transition: all 0.25s ease;
    }

    .plano-acao-trigger .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 28px rgba(0, 208, 132, 0.35);
    }

    @keyframes pulseGlow {

      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(0, 212, 255, 0.4);
      }

      50% {
        box-shadow: 0 0 0 8px rgba(0, 212, 255, 0);
      }
    }

    /* Smooth global animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    @keyframes slideUpIn {
      from {
        transform: translateY(10px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes slideDownOut {
      from {
        transform: translateY(0);
        opacity: 1;
      }

      to {
        transform: translateY(8px);
        opacity: 0;
      }
    }

    @keyframes scaleIn {
      from {
        transform: scale(0.96);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .fade-in {
      animation: fadeIn .24s ease both;
    }

    .fade-out {
      animation: fadeOut .22s ease both;
    }

    .slide-up-in {
      animation: slideUpIn .26s ease both;
    }

    .slide-down-out {
      animation: slideDownOut .22s ease both;
    }

    .scale-in {
      animation: scaleIn .24s ease both;
    }

    .chart-anim {
      will-change: opacity, transform;
    }

    /* Additional floating collapse/expand styles (subtle, site-standard) */
    .floating-filters .header-search {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }

    .floating-filters .header-search .search-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: var(--tryvia-cyan);
      color: var(--tryvia-white);
      box-shadow: var(--tryvia-card-shadow);
      font-size: 1.05rem;
    }

    .floating-filters .filters-inner .collapse-btn {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: var(--tryvia-white);
      border: 1px solid rgba(0, 0, 0, 0.06);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: var(--tryvia-card-shadow);
      color: var(--tryvia-cyan);
      font-weight: 800;
      transition: transform .18s ease;
    }

    .floating-filters .filters-inner .collapse-btn:active {
      transform: scale(.98);
    }

    /* collapsed state: keep only icon + collapse button and move to right edge (logo stays alone on left) */
    .floating-filters.collapsed {
      right: 12px !important;
      left: auto !important;
      top: 12px !important;
      transform: none !important;
      width: auto !important;
    }

    .floating-filters.collapsed .filters-inner {
      width: 56px !important;
      padding: 6px !important;
      gap: 6px !important;
      justify-content: center;
    }

    .floating-filters .filters-inner.collapsed {
      width: 56px !important;
      padding: 6px !important;
      gap: 6px !important;
      justify-content: center;
    }

    .floating-filters .filters-inner.collapsed .search-input {
      display: none !important;
    }

    .floating-filters .filters-inner.collapsed .date-field {
      display: none !important;
    }

    .floating-filters .filters-inner.collapsed>div[style*="display:flex"] {
      display: none !important;
    }

    /* hides last buttons block */
    .floating-filters .filters-inner.collapsed .search-icon {
      margin-right: 0;
    }

    /* small fade/slide for expand transition */
    .floating-filters .filters-inner {
      transition: width .22s ease, padding .22s ease, gap .18s ease, left .25s ease;
    }

    .floating-filters .filters-inner .search-input {
      transition: opacity .18s ease;
    }

    .floating-filters .filters-inner .date-field {
      transition: opacity .18s ease;
    }

    /* keep little pill look consistent on hover */
    .floating-filters .filters-inner:hover .collapse-btn {
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
    }

    /* accessibility focus */
    .floating-filters .filters-inner .collapse-btn:focus {
      outline: 3px solid rgba(0, 207, 255, 0.18);
      outline-offset: 2px;
    }

    /* Ensure when collapsed the floating bar is above other items */
    .floating-filters.collapsed {
      z-index: 14000;
    }

    /* ---------- Tooltip for nota-rect ---------- */
    .nota-rect {
      position: relative;
      overflow: visible;
    }

    /* Tooltip: show above the note and allow overflow beyond modal */
    .nota-tooltip {
      display: inline-block;
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translate(-50%, -100%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 0.92rem;
      line-height: 1.25;
      white-space: nowrap;
      /* keep single line for horizontal growth */
      max-width: none;
      /* let it overflow horizontally */
      overflow: visible;
      overflow-wrap: normal;
      word-break: normal;
      pointer-events: none;
      opacity: 0;
      transition: opacity .12s ease, transform .12s ease;
      z-index: 15000;
      box-shadow: 0 8px 26px rgba(0, 0, 0, 0.36);
    }

    .nota-rect:hover .nota-tooltip {
      opacity: 1;
      transform: translate(-50%, calc(-100% - 8px));
    }

    /* Prevent text cutoff in modals */
    .cliente-modal-box,
    .compare-selector-box,
    .compare-modal-box,
    .plano-acao-box {
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    @media (max-width:900px) {
      .cliente-modal-box {
        max-width: 95%;
        padding: 1rem;
      }

      .cliente-modal-body {
        flex-direction: column;
      }

      .cliente-modal-box canvas {
        height: 180px !important;
      }

      .compare-selector-box {
        max-width: 94%;
      }

      .compare-modal-box {
        max-width: 95%;
      }

      .modal-body {
        flex-direction: column;
      }

      .modal-body .info-area {
        width: 100%;
      }

      .header-inner .left,
      .header-inner .right {
        position: static;
        transform: none;
        margin: 4px;
      }

      #siteTitle {
        position: static;
        transform: none;
        margin: 0 auto 6px;
        font-size: 1.25rem;
      }

      .logo-wrap {
        margin: 0 auto 8px;
      }

      #siteSubtitle {
        position: static;
        transform: none;
        margin: 0 auto 4px;
        font-size: 0.95rem;
        font-weight: 700;
      }

      .floating-filters {
        display: none !important;
      }

      /* On small screens ensure wrapping and near-full width */
      .suggestions {
        max-width: 90vw;
        min-width: 180px;
        left: 0;
        right: auto;
      }

      .search-input {
        width: 180px;
      }

      .nota-tooltip {
        white-space: normal;
        max-width: 90vw;
        overflow-wrap: break-word;
        word-break: break-word;
      }
    }

    /* Mobile Responsiveness */
    @media (max-width:768px) {

      /* Container adjustments */
      .container {
        width: 100% !important;
        max-width: 100% !important;
        margin: 5px auto 20px;
        padding: 15px 20px;
        border-radius: 12px;
      }

      /* Header adjustments */
      .header-inner {
        flex-direction: column;
        padding: 10px;
        gap: 10px;
      }

      .header-inner .left,
      .header-inner .right {
        position: static;
        transform: none;
        margin: 0;
        width: 100%;
        display: flex;
        justify-content: center;
      }

      #siteTitle {
        font-size: 1.1rem;
        margin: 0 auto 4px;
      }

      #siteSubtitle {
        font-size: 0.85rem;
        margin: 0 auto;
      }

      .logo-wrap {
        margin: 0 auto 6px;
      }

      .logo {
        width: 40px;
        height: 40px;
      }

      /* Summary boxes - stack vertically */
      .summary {
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .summary .box {
        min-height: 50px;
        padding: 8px;
        font-size: 12px;
      }

      .summary .box b {
        font-size: 1.2em;
      }

      /* Charts - single column */
      .dashboard-charts-row {
        grid-template-columns: 1fr;
        gap: 12px;
        margin: 8px 0;
      }

      .dashboard-chart-container {
        height: 300px;
        padding: 10px;
      }

      .dashboard-chart-container h3 {
        font-size: 14px;
        margin-bottom: 8px;
      }

      .chart-toggle-btn,
      .fullscreen-btn {
        width: 28px;
        height: 28px;
        min-width: 28px;
        min-height: 28px;
        top: 8px;
        font-size: 0.65rem;
      }

      .fullscreen-btn {
        left: 6px;
      }

      .chart-toggle-btn {
        left: calc(6px + 28px + 3px);
      }

      /* Rankings - single column */
      .dashboard-rankings-row {
        flex-direction: column;
        gap: 12px;
        margin: 8px 0;
      }

      .dashboard-ranking-container {
        height: 280px;
        padding: 12px;
      }

      .dashboard-ranking-container h3 {
        font-size: 14px;
        top: 8px;
      }

      .ranking-order-wrap {
        top: 4px;
        right: 8px;
      }

      .ranking-order-wrap .btn {
        height: 32px;
        font-size: 0.8rem;
        padding: 0 8px;
        min-width: 50px;
      }

      /* Ranking list items */
      .dashboard-ranking-list li {
        padding: 8px 10px;
        height: 44px;
        font-size: 0.9rem;
      }

      .dashboard-ranking-list .rank {
        min-width: 32px;
        padding: 2px 6px;
        font-size: 0.8rem;
      }

      .dashboard-ranking-list .score {
        min-width: 40px;
        font-size: 0.8rem;
        padding: 2px 6px;
      }

      .dashboard-ranking-list .name {
        font-size: 0.9rem;
      }

      .delta-badge {
        font-size: 0.75rem;
        padding: 2px 6px;
        min-width: 32px;
      }

      /* Navigation arrows */
      .nav-arrow-btn {
        width: 24px;
        height: 24px;
        font-size: 12px;
      }

      .ranking-nav-arrows {
        margin-top: 4px;
      }

      /* Filters */
      .filters-bar {
        max-width: 100%;
        margin-bottom: 12px;
        gap: 8px;
      }

      .search-input {
        width: 150px;
        font-size: 0.9rem;
      }

      .mes-select {
        font-size: 0.9rem;
        padding: 6px 10px;
      }

      /* Modals */
      .month-selection-modal .month-selection-box {
        width: 95%;
        max-width: 400px;
        padding: 15px;
      }

      .month-selection-header h3 {
        font-size: 1.1rem;
      }

      .month-selection-select {
        font-size: 0.9rem;
        padding: 8px;
      }

      .month-selection-btn {
        padding: 8px 12px;
        font-size: 0.9rem;
      }

      /* Help modal */
      .help-box {
        width: 95%;
        padding: 12px;
      }

      .help-hero {
        flex-direction: column;
        gap: 12px;
      }

      .help-hero .hero-right {
        width: 100%;
        height: 200px;
      }

      .help-grid {
        grid-template-columns: 1fr;
        gap: 8px;
      }

      /* Floating filters hidden on mobile */
      .floating-filters {
        display: none !important;
      }

      /* Planilha box */
      .planilha-box {
        padding: 1.5rem 1rem;
        margin-bottom: 1rem;
      }

      /* Chart canvas adjustments */
      .chart-wrapper canvas {
        max-height: 260px !important;
      }

      /* Pagination */
      .ranking-pagination .btn {
        height: 28px;
        min-width: 28px;
        font-size: 0.8rem;
        padding: 4px 6px;
      }

      .ranking-pagination #rankingPageInfo {
        font-size: 0.7rem;
      }
    }

    /* Extra small screens */
    @media (max-width:480px) {
      .container {
        padding: 10px 15px;
        margin: 2px auto 15px;
      }

      /* Header */
      #siteTitle {
        font-size: 1rem;
      }

      #siteSubtitle {
        font-size: 0.8rem;
      }

      /* Summary */
      .summary .box {
        min-height: 45px;
        padding: 6px;
        font-size: 11px;
      }

      .summary .box b {
        font-size: 1.1em;
      }

      /* Charts */
      .dashboard-chart-container {
        height: 250px;
        padding: 8px;
      }

      .dashboard-chart-container h3 {
        font-size: 13px;
      }

      .chart-toggle-btn,
      .fullscreen-btn,
      .chart-help-btn {
        width: 28px;
        height: 28px;
        font-size: 0.8rem;
      }

      .chart-toggle-btn {
        left: 38px;
      }

      .chart-help-btn {
        left: 6px;
      }

      .dashboard-chart-container .chart-toggle-btn~.chart-help-btn {
        left: 66px;
      }

      /* Rankings */
      .dashboard-ranking-container {
        height: 240px;
        padding: 10px;
      }

      .dashboard-ranking-container h3 {
        font-size: 13px;
      }

      .ranking-order-wrap .btn {
        height: 28px;
        font-size: 0.75rem;
        padding: 0 6px;
        min-width: 45px;
      }

      /* Ranking items */
      .dashboard-ranking-list li {
        padding: 6px 8px;
        height: 40px;
        font-size: 0.85rem;
      }

      .dashboard-ranking-list .rank {
        min-width: 28px;
        padding: 2px 4px;
        font-size: 0.75rem;
      }

      .dashboard-ranking-list .score {
        min-width: 36px;
        font-size: 0.75rem;
        padding: 2px 4px;
      }

      .dashboard-ranking-list .name {
        font-size: 0.85rem;
      }

      .delta-badge {
        font-size: 0.7rem;
        padding: 1px 4px;
        min-width: 28px;
      }

      /* Navigation */
      .nav-arrow-btn {
        width: 20px;
        height: 20px;
        font-size: 10px;
      }

      /* Filters */
      .search-input {
        width: 120px;
        font-size: 0.85rem;
      }

      .mes-select {
        font-size: 0.85rem;
        padding: 5px 8px;
      }

      /* Modals */
      .month-selection-modal .month-selection-box {
        width: 98%;
        padding: 12px;
      }

      .month-selection-header h3 {
        font-size: 1rem;
      }

      .month-selection-select {
        font-size: 0.85rem;
        padding: 6px;
      }

      /* Chart canvas */
      .chart-wrapper canvas {
        max-height: 220px !important;
      }

      /* Pagination */
      .ranking-pagination .btn {
        height: 24px;
        min-width: 24px;
        font-size: 0.7rem;
        padding: 2px 4px;
      }
    }

    /* Month selection modal mobile adjustments */
    .month-selection-modal {
      padding: 10px;
    }

    .month-selection-modal .month-selection-box {
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .month-selection-header {
      padding: 12px 12px 8px;
    }

    .month-selection-header h3 {
      font-size: 1rem;
      margin: 0;
    }

    .month-selection-content {
      padding: 8px 12px;
    }

    .month-selection-actions {
      padding: 12px;
      gap: 8px;
    }

    .month-selection-btn {
      border-radius: 8px;
      font-weight: 600;
    }

    /* Client modal mobile adjustments */
    .cliente-modal-box {
      border-radius: 12px;
      max-height: 90vh;
      overflow: auto;
    }

    .cliente-modal-header {
      padding: 12px;
    }

    .cliente-modal-header h3 {
      font-size: 1.1rem;
      margin: 0;
    }

    .cliente-modal-body {
      padding: 12px;
      gap: 12px;
    }

    /* Compare modal mobile adjustments */
    .compare-modal-box {
      border-radius: 12px;
      max-height: 90vh;
      overflow: auto;
    }

    .modal-header {
      padding: 12px;
    }

    .modal-header .modal-title {
      font-size: 1.1rem;
      margin: 0;
    }

    .modal-body {
      padding: 12px;
    }

    /* Filters menu mobile adjustments */
    .filters-menu {
      border-radius: 8px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      max-width: 200px;
    }

    .filters-item {
      padding: 10px 12px;
      font-size: 0.9rem;
    }

    /* Help modal mobile adjustments */
    .help-overlay {
      padding: 10px;
    }

    .help-box {
      border-radius: 12px;
      max-height: 90vh;
    }

    .help-close {
      width: 32px;
      height: 32px;
      font-size: 0.9rem;
    }

    /* Plan de action mobile adjustments */
    .plano-acao-overlay {
      padding: 10px;
    }

    .plano-acao-box {
      border-radius: 12px;
      max-height: 90vh;
      overflow: auto;
    }

    .plano-acao-close {
      width: 32px;
      height: 32px;
      font-size: 0.9rem;
    }

    /* Responsive touch targets */
    @media (max-width:768px) {

      .btn,
      .search-input,
      .mes-select {
        min-height: 44px;
        touch-action: manipulation;
      }

      .nav-arrow-btn {
        min-width: 44px;
        min-height: 44px;
        font-size: 14px;
      }

      .chart-toggle-btn,
      .fullscreen-btn,
      .chart-help-btn {
        min-width: 44px;
        min-height: 44px;
        font-size: 14px;
      }
    }

    /* ========== TEMA ESCURO MODERNO E APRIMORADO ========== */
    body.dark-theme {
      /* Cores principais ajustadas para melhor contraste */
      --tryvia-dark: #e8eaed;
      --tryvia-dark2: #bdc1c6;
      --tryvia-white: #1a1d21;
      --tryvia-gray: #202124;
      --tryvia-gray2: #292a2d;
      --tryvia-border: #3c4043;

      /* Cores de destaque mais vibrantes e visÃ­veis */
      --tryvia-cyan: #4fc3f7;
      --tryvia-green: #66bb6a;
      --tryvia-yellow: #ffca28;
      --tryvia-red: #ef5350;
      --tryvia-blue: #42a5f5;

      /* Sombras ajustadas para dark mode */
      --tryvia-shadow: 0 10px 34px rgba(0, 0, 0, 0.8);
      --tryvia-card-shadow: 0 8px 26px rgba(0, 0, 0, 0.6);
      --tryvia-cyan-bg: linear-gradient(135deg, rgba(79, 195, 247, 0.08) 0%, rgba(79, 195, 247, 0.02) 100%);
      --tryvia-gradient: linear-gradient(135deg, #1a1d21 0%, #202124 50%, #1a1d21 100%);

      /* Gradiente de fundo mais suave */
      background: linear-gradient(135deg, #1a1d21 0%, #202124 25%, #1e2125 50%, #202124 75%, #1a1d21 100%);
    }

    /* Header com glassmorphism dark */
    body.dark-theme header {
      background: rgba(26, 29, 33, 0.92);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(79, 195, 247, 0.15);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    /* Container principal */
    body.dark-theme .container {
      background: rgba(32, 33, 36, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(79, 195, 247, 0.12);
      border: 1px solid rgba(79, 195, 247, 0.1);
    }

    body.dark-theme .container:hover {
      box-shadow: 0 24px 70px rgba(0, 0, 0, 0.7), 0 0 0 1px rgba(79, 195, 247, 0.18);
    }

    /* GrÃ¡ficos com bordas gradiente ajustadas para dark */
    body.dark-theme .dashboard-chart-container {
      background: linear-gradient(165deg, rgba(32, 33, 36, 0.98) 0%, rgba(41, 42, 45, 0.95) 50%, rgba(35, 36, 39, 0.92) 100%);
      border: 3px solid transparent;
      background-image:
        linear-gradient(165deg, rgba(32, 33, 36, 0.98) 0%, rgba(41, 42, 45, 0.95) 50%, rgba(35, 36, 39, 0.92) 100%),
        linear-gradient(135deg, #4fc3f7 0%, #42a5f5 25%, #5c6bc0 50%, #42a5f5 75%, #4fc3f7 100%);
      background-origin: border-box;
      background-clip: padding-box, border-box;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    body.dark-theme .dashboard-chart-container:hover {
      box-shadow: 0 12px 48px rgba(79, 195, 247, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    /* Rankings com bordas gradiente ajustadas para dark */
    body.dark-theme .dashboard-ranking-container {
      background: linear-gradient(165deg, rgba(32, 33, 36, 0.98) 0%, rgba(41, 42, 45, 0.95) 50%, rgba(35, 36, 39, 0.92) 100%);
      border: 3px solid transparent;
      background-image:
        linear-gradient(165deg, rgba(32, 33, 36, 0.98) 0%, rgba(41, 42, 45, 0.95) 50%, rgba(35, 36, 39, 0.92) 100%),
        linear-gradient(135deg, #4fc3f7 0%, #42a5f5 25%, #7e57c2 50%, #42a5f5 75%, #4fc3f7 100%);
      background-origin: border-box;
      background-clip: padding-box, border-box;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    body.dark-theme .dashboard-ranking-container:hover {
      box-shadow: 0 12px 48px rgba(79, 195, 247, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    /* Boxes de resumo */
    body.dark-theme .summary .box {
      background: linear-gradient(165deg, rgba(41, 42, 45, 0.95) 0%, rgba(35, 36, 39, 0.9) 100%);
      border: 1px solid rgba(79, 195, 247, 0.2);
      color: var(--tryvia-dark);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    body.dark-theme .summary .box:hover {
      box-shadow: 0 8px 28px rgba(79, 195, 247, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.08);
      border-color: rgba(79, 195, 247, 0.35);
    }

    body.dark-theme .summary .box b {
      background: linear-gradient(135deg, #4fc3f7 0%, #66bb6a 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Boxes de status com cores vibrantes */
    body.dark-theme .box.saude {
      background: linear-gradient(165deg, rgba(102, 187, 106, 0.15) 0%, rgba(102, 187, 106, 0.08) 100%);
      border-color: rgba(102, 187, 106, 0.4);
      color: #81c784;
    }

    body.dark-theme .box.saude::before {
      background: linear-gradient(90deg, #66bb6a 0%, #81c784 100%);
    }

    body.dark-theme .box.atencao {
      background: linear-gradient(165deg, rgba(255, 202, 40, 0.15) 0%, rgba(255, 202, 40, 0.08) 100%);
      border-color: rgba(255, 202, 40, 0.4);
      color: #ffd54f;
    }

    body.dark-theme .box.atencao::before {
      background: linear-gradient(90deg, #ffca28 0%, #ffd54f 100%);
    }

    body.dark-theme .box.critico {
      background: linear-gradient(165deg, rgba(239, 83, 80, 0.15) 0%, rgba(239, 83, 80, 0.08) 100%);
      border-color: rgba(239, 83, 80, 0.4);
      color: #e57373;
    }

    body.dark-theme .box.critico::before {
      background: linear-gradient(90deg, #ef5350 0%, #e57373 100%);
    }

    /* CHS Geral box */
    body.dark-theme .box.geral.saude {
      background: linear-gradient(135deg, rgba(102, 187, 106, 0.18) 0%, rgba(102, 187, 106, 0.1) 100%);
      border-color: #66bb6a;
      color: #81c784;
    }

    body.dark-theme .box.geral.atencao {
      background: linear-gradient(135deg, rgba(255, 202, 40, 0.18) 0%, rgba(255, 202, 40, 0.1) 100%);
      border-color: #ffca28;
      color: #ffd54f;
    }

    body.dark-theme .box.geral.critico {
      background: linear-gradient(135deg, rgba(239, 83, 80, 0.18) 0%, rgba(239, 83, 80, 0.1) 100%);
      border-color: #ef5350;
      color: #e57373;
    }

    /* Logo wrapper */
    body.dark-theme .logo-wrap {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(79, 195, 247, 0.3);
      box-shadow: 0 4px 16px rgba(79, 195, 247, 0.2);
    }

    body.dark-theme .logo {
      filter: none;
    }

    /* Filtros flutuantes */
    body.dark-theme .floating-filters .filters-inner {
      background: rgba(32, 33, 36, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-color: rgba(79, 195, 247, 0.25);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(79, 195, 247, 0.15);
    }

    /* Inputs de busca e selects */
    body.dark-theme .search-input {
      background: rgba(41, 42, 45, 0.95);
      color: var(--tryvia-dark);
      border-color: rgba(79, 195, 247, 0.4);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 2px rgba(255, 255, 255, 0.05);
    }

    body.dark-theme .search-input:focus {
      border-color: var(--tryvia-cyan);
      box-shadow: 0 6px 28px rgba(79, 195, 247, 0.3), 0 0 0 4px rgba(79, 195, 247, 0.15);
    }

    body.dark-theme .search-input::placeholder {
      color: #9aa0a6;
    }

    body.dark-theme .mes-select,
    body.dark-theme .client-modal-mes,
    body.dark-theme .date-select {
      background: rgba(41, 42, 45, 0.95);
      color: var(--tryvia-dark);
      border-color: rgba(79, 195, 247, 0.4);
    }

    /* SugestÃµes de autocomplete */
    body.dark-theme .suggestions {
      background: rgba(32, 33, 36, 0.98);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-color: rgba(79, 195, 247, 0.25);
      box-shadow: 0 12px 34px rgba(0, 0, 0, 0.7);
    }

    body.dark-theme .suggestion-item {
      color: var(--tryvia-dark);
    }

    body.dark-theme .suggestion-item:hover,
    body.dark-theme .suggestion-item.active {
      background: linear-gradient(90deg, rgba(79, 195, 247, 0.18), rgba(79, 195, 247, 0.12));
    }

    body.dark-theme .suggestion-chs {
      background: linear-gradient(90deg, rgba(79, 195, 247, 0.2), rgba(79, 195, 247, 0.15));
      border-color: var(--tryvia-cyan);
      color: #4fc3f7;
    }

    /* Menu de filtros */
    body.dark-theme .filters-menu {
      background: rgba(32, 33, 36, 0.98);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-color: rgba(79, 195, 247, 0.25);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
    }

    body.dark-theme .filters-item {
      color: var(--tryvia-dark);
    }

    body.dark-theme .filters-item:hover {
      background: linear-gradient(90deg, rgba(79, 195, 247, 0.18), rgba(79, 195, 247, 0.12));
    }

    /* Lista de rankings */
    body.dark-theme .dashboard-ranking-list li {
      background: linear-gradient(135deg, rgba(41, 42, 45, 0.95) 0%, rgba(35, 36, 39, 0.9) 100%);
      border-color: rgba(79, 195, 247, 0.2);
      color: var(--tryvia-dark);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.03);
    }

    body.dark-theme .dashboard-ranking-list li:hover {
      background: linear-gradient(135deg, rgba(41, 42, 45, 0.98) 0%, rgba(35, 36, 39, 0.95) 100%);
      border-color: rgba(79, 195, 247, 0.35);
      box-shadow: 0 4px 15px rgba(79, 195, 247, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    body.dark-theme .dashboard-ranking-list .rank {
      background: linear-gradient(145deg, rgba(79, 195, 247, 0.15) 0%, rgba(79, 195, 247, 0.08) 100%);
      color: #4fc3f7;
      border-color: rgba(79, 195, 247, 0.3);
      box-shadow: 0 2px 6px rgba(79, 195, 247, 0.2);
    }

    body.dark-theme .dashboard-ranking-list .client {
      color: var(--tryvia-dark);
    }

    /* BotÃµes */
    body.dark-theme .btn {
      background: linear-gradient(135deg, rgba(41, 42, 45, 0.95) 0%, rgba(35, 36, 39, 0.9) 100%);
      color: var(--tryvia-dark);
      border-color: rgba(79, 195, 247, 0.25);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }

    body.dark-theme .btn:hover {
      background: linear-gradient(135deg, rgba(79, 195, 247, 0.2) 0%, rgba(79, 195, 247, 0.15) 100%);
      border-color: rgba(79, 195, 247, 0.4);
      box-shadow: 0 6px 20px rgba(79, 195, 247, 0.3);
    }

    body.dark-theme .btn-primary {
      background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
      color: #fff;
      border-color: rgba(102, 187, 106, 0.3);
    }

    body.dark-theme .btn-primary:hover {
      background: linear-gradient(135deg, #81c784 0%, #66bb6a 100%);
      box-shadow: 0 6px 20px rgba(102, 187, 106, 0.4);
    }

    /* BotÃµes de controle (fullscreen, toggle, etc) */
    body.dark-theme .fullscreen-btn,
    body.dark-theme .chart-toggle-btn {
      background: linear-gradient(145deg, rgba(41, 42, 45, 0.95) 0%, rgba(35, 36, 39, 0.9) 100%);
      border-color: rgba(79, 195, 247, 0.25);
      color: #4fc3f7;
    }

    body.dark-theme .fullscreen-btn:hover,
    body.dark-theme .chart-toggle-btn:hover {
      background: linear-gradient(145deg, rgba(79, 195, 247, 0.2) 0%, rgba(79, 195, 247, 0.15) 100%);
      border-color: rgba(79, 195, 247, 0.4);
      box-shadow: 0 4px 12px rgba(79, 195, 247, 0.3);
    }

    /* Modais */
    body.dark-theme .help-box,
    body.dark-theme .plano-acao-box,
    body.dark-theme .compare-selector-box,
    body.dark-theme .compare-modal-box,
    body.dark-theme .cliente-modal-box {
      background: linear-gradient(145deg, rgba(32, 33, 36, 0.98) 0%, rgba(41, 42, 45, 0.95) 100%);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-color: rgba(79, 195, 247, 0.3);
      box-shadow: 0 30px 90px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(79, 195, 247, 0.15);
    }

    body.dark-theme .help-hero,
    body.dark-theme .help-section,
    body.dark-theme .help-tile {
      background: rgba(41, 42, 45, 0.6) !important;
      border-color: rgba(79, 195, 247, 0.25) !important;
    }

    body.dark-theme .legend-item {
      background: rgba(41, 42, 45, 0.8);
      border-color: rgba(79, 195, 247, 0.2);
    }

    /* Chart wrapper */
    body.dark-theme .chart-wrapper {
      background: rgba(26, 29, 33, 0.4);
    }

    /* Textos e tÃ­tulos */
    body.dark-theme .modal-title,
    body.dark-theme .help-hero .hero-title,
    body.dark-theme h4 {
      color: #4fc3f7 !important;
    }

    body.dark-theme .chart-title,
    body.dark-theme .cliente-modal-right h4 {
      color: var(--tryvia-dark) !important;
    }

    /* Notas do cliente */
    body.dark-theme .nota-rect {
      background: linear-gradient(145deg, rgba(41, 42, 45, 0.95) 0%, rgba(35, 36, 39, 0.9) 100%) !important;
      border-color: rgba(79, 195, 247, 0.3) !important;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.05) !important;
    }

    body.dark-theme .nota-rect:hover {
      border-color: rgba(79, 195, 247, 0.5) !important;
      box-shadow: 0 8px 28px rgba(79, 195, 247, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.08) !important;
    }

    /* Dados do gestor */
    body.dark-theme .cliente-dados-gestor {
      background: linear-gradient(145deg, rgba(79, 195, 247, 0.1) 0%, rgba(79, 195, 247, 0.05) 100%) !important;
      border-color: rgba(79, 195, 247, 0.25) !important;
      color: var(--tryvia-dark) !important;
    }

    /* Compare selector items */
    body.dark-theme .compare-selector-item {
      background: rgba(41, 42, 45, 0.8);
      border-color: rgba(79, 195, 247, 0.2);
      color: var(--tryvia-dark);
    }

    body.dark-theme .compare-selector-item:hover {
      background: rgba(41, 42, 45, 0.95);
      border-color: rgba(79, 195, 247, 0.35);
      box-shadow: 0 8px 20px rgba(79, 195, 247, 0.2);
    }

    body.dark-theme .chs-badge {
      background: linear-gradient(90deg, rgba(79, 195, 247, 0.2), rgba(79, 195, 247, 0.15));
      border-color: var(--tryvia-cyan);
      color: #4fc3f7;
    }

    /* Planilha box */
    body.dark-theme .planilha-box {
      background: linear-gradient(135deg, rgba(79, 195, 247, 0.1) 0%, rgba(79, 195, 247, 0.05) 100%);
      border-color: var(--tryvia-cyan);
    }

    /* PDCA cards */
    body.dark-theme .pdca-card {
      background: rgba(41, 42, 45, 0.8);
      border-color: rgba(79, 195, 247, 0.3);
    }

    /* Month selection modal */
    body.dark-theme .month-selection-box {
      background: rgba(32, 33, 36, 0.98);
      border-color: rgba(79, 195, 247, 0.3);
    }

    body.dark-theme .month-selection-title {
      color: #4fc3f7;
    }

    body.dark-theme .month-selection-subtitle {
      color: #81c784;
    }

    body.dark-theme .month-selection-select {
      background: rgba(41, 42, 45, 0.95);
      color: var(--tryvia-dark);
      border-color: rgba(79, 195, 247, 0.4);
    }

    /* Month Selection Modal */
    .month-selection-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 20030;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .month-selection-box {
      background: var(--tryvia-white);
      border: 2px solid var(--tryvia-cyan);
      border-radius: 16px;
      width: 96%;
      max-width: 480px;
      max-height: none;
      overflow: visible;
      padding: 24px;
      box-shadow: 0 18px 46px rgba(0, 0, 0, 0.28);
      position: relative;
      text-align: left;
    }

    .month-selection-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .month-selection-title {
      font-size: 1.4rem;
      font-weight: 900;
      color: #000;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .month-selection-subtitle {
      color: #0b63b7;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .month-selection-body {
      margin-bottom: 24px;
    }

    .month-selection-content {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .month-selection-select {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid var(--tryvia-cyan);
      border-radius: 12px;
      background: var(--tryvia-white);
      font-size: 1rem;
      font-weight: 700;
      color: var(--tryvia-dark);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      transition: all 0.2s ease;
    }

    .month-selection-select:focus {
      outline: none;
      border-color: var(--tryvia-cyan);
      box-shadow: 0 6px 20px rgba(0, 207, 255, 0.2);
    }

    .month-selection-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .month-selection-btn {
      padding: 12px 24px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 1rem;
      min-width: 120px;
      transition: all 0.2s ease;
    }

    .month-selection-btn-cancel {
      background: var(--tryvia-gray2);
      color: var(--tryvia-dark);
      border: 1px solid var(--tryvia-border);
    }

    .month-selection-btn-cancel:hover {
      background: #d0d5d9;
      transform: translateY(-1px);
    }

    .month-selection-btn-confirm {
      background: linear-gradient(135deg, var(--tryvia-cyan), #00a8cc);
      color: white;
      border: 1px solid var(--tryvia-cyan);
      box-shadow: 0 4px 12px rgba(0, 207, 255, 0.2);
    }

    .month-selection-btn-confirm:hover {
      background: linear-gradient(135deg, #00a8cc, var(--tryvia-cyan));
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 207, 255, 0.3);
    }
  </style>

</head>

<body>
  <header>
    <div class="header-inner" role="banner">
      <div class="left">
        <!-- external logo provided by user, styled to fit with title -->
        <div class="logo-wrap" aria-hidden="true">
          <img class="logo" src="https://tryvia.github.io/dev/logo1.png" alt="Logo">
        </div>
      </div>

      <div class="title-wrapper" style="text-align:center">
        <div id="siteTitle">Customer Health Score</div>
        <div id="siteSubtitle">DASHBOARD DA SAÃšDE DO CLIENTE</div>
      </div>

      <div class="right">
        <button class="btn" id="themeToggleBtn" type="button" title="Alternar tema"><i class="fas fa-moon"></i></button>
      </div>
    </div>
  </header>
  <script>
    (function () {
      function applyTheme(t) {
        const isDark = (t === 'dark');
        document.body.classList.toggle('dark-theme', isDark);
        const btn = document.getElementById('themeToggleBtn');
        if (btn) { btn.innerHTML = isDark ? '<i class=\"fas fa-sun\"></i>' : '<i class=\"fas fa-moon\"></i>'; btn.title = isDark ? 'Alternar para tema claro' : 'Alternar para tema escuro'; }
      }
      localStorage.removeItem('theme');
      const saved = 'light';
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function () {
          applyTheme(saved);
          const btn = document.getElementById('themeToggleBtn');
          if (btn) { btn.addEventListener('click', function () { const next = document.body.classList.contains('dark-theme') ? 'light' : 'dark'; localStorage.setItem('theme', next); applyTheme(next); }); }
        });
      } else {
        applyTheme(saved);
        const btn = document.getElementById('themeToggleBtn');
        if (btn) { btn.addEventListener('click', function () { const next = document.body.classList.contains('dark-theme') ? 'light' : 'dark'; localStorage.setItem('theme', next); applyTheme(next); }); }
      }
    })();
  </script>

  <div class="container">
    <div class="filters-bar" id="mainFiltersBar" role="region" aria-label="Filtros" style="display:none;">
      <select id="mesSelect" onchange="changeMonth()" style="display:none;"></select>
    </div>

    <div class="summary-wrapper">
      <div class="summary" id="chs-summary">
        <div class="box" id="chsTotal" title="Mostrar todos" onclick="onSummaryClick('all')">Total de Clientes<br><b
            id="chsTotalVal">--</b></div>
        <div class="box saude" id="chsSaudavel" title="Mostrar clientes SaudÃ¡veis" onclick="onSummaryClick('saude')">
          SaudÃ¡veis<br><b id="chsSaudavelVal">--</b></div>
        <div class="box atencao" id="chsAtencao" title="Mostrar clientes em AtenÃ§Ã£o"
          onclick="onSummaryClick('atencao')">AtenÃ§Ã£o<br><b id="chsAtencaoVal">--</b></div>
        <div class="box critico" id="chsCritico" title="Mostrar clientes CrÃ­ticos" onclick="onSummaryClick('critico')">
          CrÃ­ticos<br><b id="chsCriticoVal">--</b></div>
        <div class="box geral" id="chsGeralBox">
          <div style="font-size:0.95rem;">CHS Geral</div>
          <b id="chsGeralValor" style="font-size:1.2rem;">--</b>
        </div>
      </div>
    </div>



    <div id="graficosPrincipais">
      <div class="dashboard-charts-row">
        <div class="dashboard-chart-container">
          <button class="chart-toggle-btn" title="Mudar tipo do grÃ¡fico (apenas este grÃ¡fico)"
            onclick="toggleChartTypeFor('distrib')"><i class="fas fa-sync-alt"></i></button>
          <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)"><i
              class="fas fa-expand"></i></button>
          <h3><i class="fas fa-chart-pie"></i> DistribuiÃ§Ã£o de CHS dos Clientes</h3>
          <div class="chart-wrapper"><canvas id="chartChsDistrib"></canvas></div>
        </div>
        <div class="dashboard-chart-container">
          <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)"><i
              class="fas fa-expand"></i></button>
          <h3><i class="fas fa-chart-line"></i> Clientes em alta, queda e neutros (%)</h3>
          <div class="chart-wrapper"><canvas id="chartTrendUp"></canvas></div>
        </div>
        <div class="dashboard-chart-container">
          <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)"><i
              class="fas fa-expand"></i></button>
          <div class="ranking-card-header">
            <h3 id="indicadorTitle"><i class="fas fa-chart-area"></i> EvoluÃ§Ã£o CHS (por MÃªs)</h3>
            <div class="ranking-order-wrap" id="indicatorFiltersWrap">
              <button class="btn" id="indicatorFiltersBtn" type="button" onclick="toggleIndicatorFiltersMenu()"
                title="Abrir filtros">Filtros</button>
              <div class="filters-menu" id="indicatorFiltersMenu" role="menu" aria-hidden="true">
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('nps')">NPS</button>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('sla')">SLA</button>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('neg')">Av Negativa</button>
                <div class="separator"></div>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('cs')">PercepÃ§Ã£o CS</button>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('chs')">CHS</button>
              </div>
            </div>
          </div>
          <div class="chart-wrapper"><canvas id="chartIndicadores"></canvas></div>
        </div>
      </div>
      <!-- Trend chart moved to 'Ver Mais' section -->
    </div>

    <div class="dashboard-rankings-row">
      <div class="dashboard-ranking-container" id="rankingPiores">
        <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)"><i
            class="fas fa-expand"></i></button>
        <div class="ranking-card-header">
          <h3><i class="fas fa-arrow-down"></i> 5 Menores CHS</h3>
        </div>
        <ul class="dashboard-ranking-list" id="rankingPioresList"></ul>
      </div>
      <div class="dashboard-ranking-container" id="rankingMelhores">
        <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)"><i
            class="fas fa-expand"></i></button>
        <div class="ranking-card-header">
          <h3><i class="fas fa-arrow-up"></i> 5 Maiores CHS</h3>
        </div>
        <ul class="dashboard-ranking-list" id="rankingMelhoresList"></ul>
      </div>
      <div class="dashboard-ranking-container ranking-geral" id="rankingGeral">
        <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)"><i
            class="fas fa-expand"></i></button>
        <div class="ranking-card-header">
          <h3><i class="fas fa-trophy"></i> Ranking Geral de Clientes</h3>
          <div class="ranking-order-wrap" id="rankingFiltersWrap">
            <button class="btn" id="rankingFiltersBtn" type="button" onclick="toggleRankingFiltersMenu()"
              title="Abrir filtros">Filtros</button>
            <div class="filters-menu" id="rankingFiltersMenu" role="menu" aria-hidden="true">
              <button class="filters-item" type="button" onclick="applyRankingFilter('up')">Em Alta</button>
              <button class="filters-item" type="button" onclick="applyRankingFilter('down')">Em Queda</button>
              <div class="separator"></div>
              <button class="filters-item" type="button" onclick="applyRankingFilter('asc')">Crescente</button>
              <button class="filters-item" type="button" onclick="applyRankingFilter('desc')">Decrescente</button>
            </div>
          </div>
        </div>
        <ul class="dashboard-ranking-list" id="rankingGeralList"></ul>
        <div class="ranking-nav-arrows" id="rankingNavArrows">
          <button class="nav-arrow-btn" id="rankingPrevArrow" onclick="rankingPrev()" title="PÃ¡gina anterior"
            disabled><i class="fas fa-chevron-left"></i></button>
          <button class="nav-arrow-btn" id="rankingNextArrow" onclick="rankingNext()" title="PrÃ³xima pÃ¡gina" disabled><i
              class="fas fa-chevron-right"></i></button>
        </div>
      </div>
    </div>

  </div>

  <!-- Floating filters container (will be populated dynamically) -->
  <div id="floatingFilters" class="floating-filters show" aria-hidden="false"></div>

  <!-- Select modal (centered overlay) -->
  <div class="compare-selector-modal" id="selectModal" aria-hidden="true" style="display:none; z-index:12500;">
    <div class="compare-selector-box" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">Selecionar clientes (para anÃ¡lise)</div>
        <div class="modal-controls">
          <button class="btn" onclick="selectAllSelectVisible()">Selecionar todos</button>
          <button class="btn" onclick="clearAllSelectSelection()">Limpar</button>
          <button class="btn" onclick="closeSelectModal()" style="background:#c7c7c7;color:#000;">Fechar</button>
        </div>
      </div>

      <div class="modal-body">
        <div style="flex:1;">
          <input id="selectModalSearch" class="modal-search" placeholder="Buscar nome dentro desta janela..."
            oninput="renderSelectModalList()" />
          <div style="margin-bottom:8px;color:var(--tryvia-dark2);font-weight:600;">Use o campo acima para filtrar a
            lista de clientes nesta janela.</div>
          <div class="list-area">
            <div class="compare-selector-list" id="selectModalList"
              style="display:flex; flex-direction:column; gap:6px; padding:6px;"></div>
          </div>
        </div>

        <div class="info-area" aria-hidden="true">
          <div style="font-weight:800;color:var(--tryvia-cyan);">Resumo</div>
          <div id="selectModalInfo" style="font-size:0.95rem;color:var(--tryvia-dark2);">
            Selecione clientes Ã  esquerda para incluir na anÃ¡lise. Esta Ã¡rea Ã© apenas visual e padronizada com o
            restante do site.
          </div>
          <div style="margin-top:auto;width:100%;display:flex;gap:8px;">
            <button class="btn btn-primary" style="flex:1" onclick="applySelectSelection()">Aplicar seleÃ§Ã£o</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Compare selector modal (centered overlay) -->
  <div class="compare-selector-modal" id="compareSelectorModal" aria-hidden="true" style="display:none;">
    <div class="compare-selector-box" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">Selecionar clientes para comparaÃ§Ã£o</div>
        <div class="modal-controls">
          <input id="compareModalSearch" class="modal-search" placeholder="Buscar nome aqui..."
            oninput="renderCompareSelector()" style="width:220px;" />
          <div class="date-field" style="margin-left:6px;">
            <i class="fas fa-calendar calendar-icon"></i>
            <select id="compareModalMesSelect" class="client-modal-mes" onchange="renderCompareSelector()"
              title="Filtrar por mÃªs ao selecionar clientes para comparar">
            </select>
          </div>
          <button class="btn" onclick="selectAllCompareVisible()">Selecionar todos</button>
          <button class="btn" onclick="clearAllCompareSelection()">Limpar</button>
          <button class="btn" onclick="closeCompareSelector()" style="background:#c7c7c7;color:#000;">Fechar</button>
        </div>
      </div>

      <div class="modal-body">
        <div style="flex:1;">
          <div style="margin-bottom:8px;color:var(--tryvia-dark2);font-weight:600;">Use o campo acima para filtrar a
            lista na janela de comparaÃ§Ã£o e escolha o mÃªs para comparar os dados.</div>
          <div class="list-area">
            <div class="compare-selector-list" id="compareSelectorList"
              style="display:flex; flex-direction:column; gap:6px; padding:6px;"></div>
          </div>
        </div>

        <div class="info-area" aria-hidden="true">
          <div style="font-weight:800;color:var(--tryvia-cyan);">ObservaÃ§Ãµes</div>
          <div style="font-size:0.95rem;color:var(--tryvia-dark2);">
            Escolha pelo menos 2 clientes Ã  esquerda e clique em "Comparar selecionados" para abrir a comparaÃ§Ã£o visual.
          </div>
          <div style="margin-top:auto;width:100%;display:flex;gap:8px;">
            <button class="btn btn-primary" style="flex:1" onclick="applyCompareSelection()">Comparar
              selecionados</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Month selection modal -->
  <div class="month-selection-modal" id="monthSelectionModal" role="dialog" aria-hidden="true" style="display:none;">
    <div class="month-selection-box">
      <div class="month-selection-header">
        <div class="month-selection-title">
          <i class="fas fa-calendar" style="font-size:1.2rem;margin-right:8px;color:var(--tryvia-dark2);"></i>
          Selecione o MÃªs para Visualizar
        </div>
        <div class="month-selection-subtitle">
          Escolha o mÃªs que deseja carregar os dados do dashboard
        </div>
      </div>
      <div class="month-selection-body">
        <div class="month-selection-content">
          <select id="monthSelectionSelect" class="month-selection-select"
            title="Selecione o mÃªs para carregar os dados">
            <option value="">Carregando meses...</option>
          </select>
        </div>
      </div>
      <div class="month-selection-actions">
        <button class="btn month-selection-btn month-selection-btn-cancel" onclick="closeMonthSelectionModal()">
          Cancelar
        </button>
        <button class="btn month-selection-btn month-selection-btn-confirm" onclick="confirmMonthSelection()">
          Carregar Dados
        </button>
      </div>
    </div>
  </div>

  <!-- Compare chart modal -->
  <div class="compare-modal" id="compareModal" role="dialog" aria-hidden="true" style="display:none;">
    <div class="compare-modal-box">
      <div class="modal-header">
        <div class="modal-title" id="compareModalTitle">ComparaÃ§Ã£o de Clientes</div>
        <div class="modal-controls">
          <div class="date-field" style="margin-left:6px;">
            <i class="fas fa-calendar calendar-icon"></i>
            <select id="compareModalMesSelectTop" class="client-modal-mes" onchange="rebuildCompareChartFromModal()"
              title="Filtrar mÃªs da comparaÃ§Ã£o (visualizaÃ§Ã£o)">
            </select>
          </div>
          <button class="btn" onclick="closeCompareModal()"
            style="background:var(--tryvia-red);color:white;">Fechar</button>
        </div>
      </div>

      <div class="modal-body" style="padding-top:6px;">
        <div style="width:100%;height:360px;">
          <canvas id="compareChart" class="compare-modal-canvas"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Cliente modal (dynamic) - will be shown as centered overlay -->
  <div class="cliente-modal" id="clienteModal" aria-hidden="true"></div>

  <script>
    const URL_DA_PLANILHA = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQFJga3Q0ulkeK0xx968BHQHvBnXGA7mg_8lSFa_xc1xBedTI_jU0FVC2yqyEYCG4Pt0J0gP85EMAri/pub?gid=1977027647&single=true&output=csv";
    /* Full JS restored and preserved. All functions included to ensure full functionality:
       - parsing/import (colarPlanilha) now expects 12 columns and includes 'agente'
       - selection modals (openSelectModal, renderSelectModalList, etc.)
       - compare modals (openCompareSelector, renderCompareSelector, etc.)
       - charts creation (Chart.js)
       - rankings, table rendering, filters
       - floating filters observer to show floating bar when main bar scrolls out
       - togglePlanilhaBox and setinha behavior
       - client modal open/update/close (abrirClienteModal, updateClienteModal, fecharClienteModal)
       - autocomplete suggestions for "Buscar cliente..." added without changing existing functions.
       - ranking order button and logic (toggleRankingOrder and rankingOrderDesc)
       - new trend filter button (toggleRankingTrend) cycles: all -> down -> up -> all
       - renderRankingGeral now supports trend filtering (only down/up) and uses same delta logic as before
    */

    /* Globals */
    let clientes = [];
    let clientesFiltrados = [];
    let currentMes = null;
    let currentFilter = null;
    let chartChsDistrib = null, chartChsEvolucao = null, chartCompare = null;
    let chartSlaEvolucao = null, chartCsEvolucao = null, chartNpsEvolucao = null, chartNegEvolucao = null;
    let chartTypeDistrib = 'doughnut', chartTypeEvol = 'line', chartTypeSLA = 'line', chartTypeCS = 'line', chartTypeNPS = 'line', chartTypeNEG = 'line';
    let rankingPage = 1;
    let rankingPageSize = 5;
    let selectedClients = new Set();
    let compareSelectedClients = new Set();
    let statusFilter = null;
    let chartClienteDonut = null;
    let chartClienteComp = null;
    let chartTrendDown = null;
    let chartTrendUp = null;
    let chartIndicadores = null;
    let indicadorAtual = 'chs'; // 'chs' | 'nps' | 'sla' | 'neg' | 'cs'
    let chartChsBreakdown = null;
    let chartTypeBreakdown = 'bar';

    // ConfiguraÃ§Ã£o global de CHS (thresholds e pesos)
    const CHS_CONFIG = {
      thresholds: { saude: 70, atencao: 40 }, // critico < atencao; atencao <= x < saude; saude >=
      weights: { // pesos relativos (serÃ£o normalizados)
        cs: 0.25,
        nps: 0.25,
        sla: 0.30,
        neg: 0.20
      },
      useFormulaOverride: false // quando true, recalcula cli.chs com base nos pesos
    };

    function normalizeWeights(obj) { const t = Object.values(obj || {}).reduce((a, b) => a + (+b || 0), 0) || 1; const out = {}; for (const k in obj) out[k] = (obj[k] || 0) / t; return out; }
    function computeSlaPct(cli) {
      const t1 = Number(cli.sla1ok) || 0, f1 = Number(cli.sla1off) || 0, t2 = Number(cli.sla2ok) || 0, f2 = Number(cli.sla2off) || 0;
      const p1 = (t1 + f1) > 0 ? (t1 / (t1 + f1)) * 100 : null;
      const p2 = (t2 + f2) > 0 ? (t2 / (t2 + f2)) * 100 : null;
      if (p1 != null && p2 != null) return (p1 + p2) / 2; if (p1 != null) return p1; if (p2 != null) return p2; return null;
    }
    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function to0_100(x, min, max) { if (x == null || isNaN(x)) return null; if (min == null || max == null || max === min) return Math.max(0, Math.min(100, Number(x))); const v = (x - min) / (max - min); return Math.round(clamp01(v) * 100); }

    // NormalizaÃ§Ã£o simples: cs (0-10), nps (-100 a 100), neg (0-100 menor Ã© melhor), sla (jÃ¡ %)
    function normalizeMetrics(cli) {
      const cs = to0_100(Number(cli.cs), 0, 10);
      const nps = to0_100(Number(cli.nps), -100, 100);
      const negRaw = Number(cli.neg); // % de avaliaÃ§Ãµes negativas
      const neg = (isNaN(negRaw) ? null : Math.round((1 - clamp01(negRaw / 100)) * 100)); // maior melhor
      const slaPct = computeSlaPct(cli);
      const sla = (slaPct == null ? null : Math.round(slaPct));
      return { cs, nps, neg, sla };
    }

    function calculateChsFromComponents(cli) {
      const w = normalizeWeights(CHS_CONFIG.weights);
      const { cs, nps, neg, sla } = normalizeMetrics(cli);
      const parts = [];
      if (cs != null) parts.push(w.cs * cs); if (nps != null) parts.push(w.nps * nps); if (neg != null) parts.push(w.neg * neg); if (sla != null) parts.push(w.sla * sla);
      if (!parts.length) return cli.chs || 0;
      return Math.round(parts.reduce((a, b) => a + b, 0));
    }

    function recalculateAllChs() {
      if (!CHS_CONFIG.useFormulaOverride) return;
      (clientes || []).forEach(cli => { cli.chs = calculateChsFromComponents(cli); });
    }

    function setChsConfig(cfg) { Object.assign(CHS_CONFIG, cfg || {}); recalculateAllChs(); try { refreshAll(); } catch (e) { } }

    const ValueLabelsAll = {
      id: 'valueLabelsAll',
      afterDatasetsDraw(chart, args, pluginOptions) {
        try {
          if (!chart) return;
          if (pluginOptions === false || (pluginOptions && pluginOptions.enabled === false)) return;
          const ctx = chart.ctx;
          const type = (chart.config && chart.config.type) || '';
          const datasets = (chart.data && chart.data.datasets) || [];
          const offset = (pluginOptions && pluginOptions.offset) || 6;
          const color = (pluginOptions && pluginOptions.color) || '#111';
          const font = (pluginOptions && pluginOptions.font) || 'bold 12px Roboto, Arial, sans-serif';
          ctx.save();
          ctx.fillStyle = color;
          ctx.font = font;

          if (type === 'bar') {
            const isHorizontal = chart.options && chart.options.indexAxis === 'y';
            datasets.forEach((ds, di) => {
              if (ds && ds.hidden) return;
              const meta = chart.getDatasetMeta(di);
              (meta?.data || []).forEach((elem, i) => {
                const v = ds?.data?.[i];
                if (v == null) return;
                const text = (typeof v === 'number') ? (Math.round(v * 10) / 10).toString() : String(v);
                const p = elem.tooltipPosition();
                if (isHorizontal) {
                  ctx.textAlign = 'left';
                  ctx.textBaseline = 'middle';
                  try { ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x + offset, p.y); } catch (e) { }
                  ctx.fillText(text, p.x + offset, p.y);
                } else {
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'bottom';
                  try { ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x, p.y - offset); } catch (e) { }
                  ctx.fillText(text, p.x, p.y - offset);
                }
              });
            });
          } else if (type === 'line') {
            datasets.forEach((ds, di) => {
              if (ds && ds.hidden) return;
              const meta = chart.getDatasetMeta(di);
              (meta?.data || []).forEach((elem, i) => {
                const v = ds?.data?.[i];
                if (v == null) return;
                const text = (typeof v === 'number') ? (Math.round(v * 10) / 10).toString() : String(v);
                const p = elem.tooltipPosition();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                try { ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x, p.y - 6); } catch (e) { }
                ctx.fillText(text, p.x, p.y - 6);
              });
            });
          } else if (type === 'doughnut' || type === 'pie') {
            datasets.forEach((ds, di) => {
              if (ds && ds.hidden) return;
              const meta = chart.getDatasetMeta(di);
              (meta?.data || []).forEach((elem, i) => {
                const v = ds?.data?.[i];
                if (v == null || v === 0) return;
                const text = (typeof v === 'number') ? (Math.round(v * 10) / 10).toString() : String(v);
                const p = elem.tooltipPosition();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                try { ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x, p.y); } catch (e) { }
                ctx.fillText(text, p.x, p.y);
              });
            });
          }

          ctx.restore();
        } catch (e) { }
      }
    };
    try { Chart.register(ValueLabelsAll); } catch (e) { }
    /* Plugin: draw a background grid behind doughnut for DistribuiÃ§Ã£o chart */
    const DoughnutGridBG = {
      id: 'doughnutGridBG',
      beforeDatasetsDraw(chart, args, opts) {
        try {
          if (!chart || chart.config?.type !== 'doughnut') return;
          const id = chart?.canvas?.id || '';
          if (id !== 'chartChsDistrib') return;
          const { ctx, chartArea } = chart; if (!chartArea) return;
          const { left, right, top, bottom, width, height } = chartArea;
          ctx.save();
          ctx.strokeStyle = '#e9eef3';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 4]);
          // vertical lines
          const vLines = 6; for (let i = 1; i < vLines; i++) { const x = left + (width * i / vLines); ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, bottom); ctx.stroke(); }
          // horizontal lines
          const hLines = 4; for (let j = 1; j < hLines; j++) { const y = top + (height * j / hLines); ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke(); }
          ctx.restore();
        } catch (e) { }
      }
    };
    /* Plugin: draw a horizontal target line (e.g., y=70) on charts with a y-scale */
    const TargetLine = {
      id: 'targetLine',
      afterDatasetsDraw(chart, args, opts) {
        try {
          if (!chart || !chart.scales || !chart.scales.y) return;
          // draw ONLY when explicitly configured on the chart options
          if (!(opts && (typeof opts.y === 'number' || opts.enabled === true))) return;
          const yValue = (opts && typeof opts.y === 'number') ? opts.y : 70;
          const color = (opts && opts.color) || '#666';
          const width = (opts && opts.width) || 2;
          const dash = (opts && opts.dash) || [6, 4];
          const y = chart.scales.y.getPixelForValue(yValue);
          const { left, right } = chart.chartArea || {};
          if (!(left >= 0 && right > left && isFinite(y))) return;
          const ctx = chart.ctx; ctx.save();
          ctx.beginPath(); ctx.setLineDash(dash); ctx.lineWidth = width; ctx.strokeStyle = color; ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke(); ctx.restore();
        } catch (e) { }
      }
    };
    /* Plugin: center text inside doughnut (used only on clienteChartDonut) */
    const CenterText = {
      id: 'centerText',
      afterDraw(chart, args, opts) {
        try {
          if (!opts || opts.enabled === false) return;
          if (chart.config?.type !== 'doughnut') return;
          const { ctx, chartArea } = chart; if (!ctx || !chartArea) return;
          const text = (typeof opts.text === 'function') ? opts.text(chart) : (opts.text || '');
          if (!text) return;
          const cx = (chartArea.left + chartArea.right) / 2;
          const cy = (chartArea.top + chartArea.bottom) / 2;
          ctx.save();
          ctx.fillStyle = opts.color || '#000';
          ctx.font = opts.font || '900 28px Roboto, Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          try { ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.strokeText(text, cx, cy); } catch (e) { }
          ctx.fillText(text, cx, cy);
          ctx.restore();
        } catch (e) { }
      }
    };
    try { Chart.register(DoughnutGridBG, TargetLine, CenterText); } catch (e) { }
    try {
      Chart.defaults.animation = Object.assign({}, Chart.defaults.animation, { duration: 500, easing: 'easeOutQuart' });
      if (Chart.defaults.transitions && Chart.defaults.transitions.active && Chart.defaults.transitions.active.animation) {
        Chart.defaults.transitions.active.animation.duration = 400;
      }
    } catch (e) { }

    /* Smoothly reveal a chart canvas by id (fade + slight slide) */
    function animateChartRender(canvasId) {
      try {
        const el = document.getElementById(canvasId);
        if (!el) return;
        const wrap = el.closest('.chart-wrapper') || el;
        wrap.classList.add('chart-anim', 'fade-in', 'slide-up-in');
        setTimeout(function () { wrap.classList.remove('fade-in', 'slide-up-in'); }, 320);
      } catch (e) { }
    }

    /* Body scroll lock helpers to avoid layout shift when overlay opens */
    function lockBodyScroll() {
      try {
        if (document.body.dataset.scrollLocked === '1') return;
        const pr = window.innerWidth - document.documentElement.clientWidth;
        document.body.style.overflow = 'hidden';
        if (pr > 0) { document.body.style.paddingRight = pr + 'px'; }
        document.body.dataset.scrollLocked = '1';
      } catch (e) { }
    }
    function unlockBodyScroll() {
      try {
        document.body.style.overflow = '';
        document.body.style.paddingRight = '';
        delete document.body.dataset.scrollLocked;
      } catch (e) { }
    }

    /* New: ranking order state variable (true = descending, false = ascending) */
    let rankingOrderDesc = true;

    /* New: ranking trend filter state: 'all' | 'down' | 'up' */
    let rankingTrendState = 'all'; // default show all

    /* Component maximum scores for display */
    const MAX_SLA = 20;
    const MAX_NPS = 30;
    const MAX_NEG = 30;
    const MAX_CS = 20;

    /* Calculation helpers */
    function calcSLA(cli) {
      let t1 = Number(cli.sla1ok) || 0, f1 = Number(cli.sla1off) || 0, t2 = Number(cli.sla2ok) || 0, f2 = Number(cli.sla2off) || 0;
      const parts = [];
      if ((t1 + f1) > 0) parts.push(t1 / (t1 + f1));
      if ((t2 + f2) > 0) parts.push(t2 / (t2 + f2));
      if (parts.length === 0) return 0;
      const slaMedia = parts.reduce((a, b) => a + b, 0) / parts.length;
      if (slaMedia >= 1) return 20; if (slaMedia >= 0.9) return 15; if (slaMedia >= 0.8) return 10; if (slaMedia >= 0.7) return 5; return 0;
    }
    function calcNPS(cli, mediaNps = 6) { let nps = cli.nps; if (nps === null || nps === "" || isNaN(Number(nps))) nps = mediaNps; nps = Math.round(Number(nps)); if (nps >= 9) return 30; if (nps === 8) return 22; if (nps === 7) return 14; if (nps === 6) return 7; if (nps === 5) return 2; return 0; }
    function calcNeg(cli) { let neg = Number(cli.neg); if (isNaN(neg)) return 0; neg = Math.round(neg); if (neg === 0) return 30; if (neg === 1) return 15; if (neg === 2) return 5; if (neg >= 3) return 0; return 0; }
    function calcCS(cli, mediaCs = 5) { let cs = cli.cs; if (cs === null || cs === "" || isNaN(Number(cs))) cs = mediaCs; cs = Math.round(Number(cs)); if (cs >= 10) return 20; if (cs === 9) return 16; if (cs === 8) return 12; if (cs === 7) return 8; if (cs === 6) return 4; if (cs <= 5) return 0; return 0; }
    function calcMedia(list, fieldFn) { let vals = list.map(fieldFn).filter(v => v != null && v !== "" && !isNaN(v)); if (!vals.length) return 0; return Math.round(vals.reduce((a, b) => a + Number(b), 0) / vals.length); }
    function calcCHS(cli, clientesList) { let mediaNPS = calcMedia(clientesList, c => c.nps), mediaCS = calcMedia(clientesList, c => c.cs); return Number(calcSLA(cli)) + Number(calcNPS(cli, mediaNPS)) + Number(calcNeg(cli)) + Number(calcCS(cli, mediaCS)); }

    /* UPDATED thresholds and status mapping to match requested ranges:
       SaudÃ¡vel: 100 - 70  (>= 70)
       AtenÃ§Ã£o: 69 - 40    (>= 40 && < 70)
       CrÃ­tico: 39 - 0     (< 40)
    */
    function getStatusCHS(chs) {
      if (isNaN(Number(chs))) return { txt: "Indefinido", cls: "critico", cor: "#e53935" };
      const v = Number(chs);
      if (v >= 70) return { txt: "SaudÃ¡vel", cls: "saude", cor: "#009f42" };
      if (v >= 40) return { txt: "AtenÃ§Ã£o", cls: "atencao", cor: "#ffc900" };
      return { txt: "CrÃ­tico", cls: "critico", cor: "#e53935" };
    }
    function formatMesAno(ym) { if (!ym) return ""; let [y, m] = ym.split('-'); return `${m}/${y}`; }
    function normalizeYYYYMM(s) {
      if (!s) return "";
      const str = String(s).trim();
      // 1) YYYY-MM or YYYY/MM or YYYYMM (optionally with day at the end)
      let m = str.match(/^(\d{4})[-\/]?(\d{1,2})(?:[-\/]\d{1,2})?$/);
      if (m) {
        const y = m[1];
        const mm = m[2].padStart(2, '0');
        return `${y}-${mm}`;
      }
      // 2) DD/MM/YYYY or D/M/YYYY (take middle as month)
      m = str.match(/^(\d{1,2})[-\/]?(\d{1,2})[-\/]?(\d{2,4})$/);
      if (m) {
        const y = m[3].length === 2 ? (m[3] > '50' ? '19' + m[3] : '20' + m[3]) : m[3];
        const mm = m[2].padStart(2, '0');
        return `${y}-${mm}`;
      }
      // 3) MM/YYYY or M/YYYY
      m = str.match(/^(\d{1,2})[-\/]?(\d{4})$/);
      if (m) {
        const y = m[2];
        const mm = m[1].padStart(2, '0');
        return `${y}-${mm}`;
      }
      // Do NOT try to infer from arbitrary digits (prevents phantom months from telefone/IDs)
      return "";
    }
    function preparaClientes(list) { list.forEach(cli => { cli.nome = (cli.nome || '').toString().trim(); cli.chs = calcCHS(cli, list); cli.status = getStatusCHS(cli.chs).txt; cli.dataFmt = normalizeYYYYMM(cli.data); }); }
    function escapeHtml(str) { if (!str && str !== 0) return ""; return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }

    /* Aggregate by name (now includes agente) */
    function aggregateByName(list) {
      const map = {};
      (list || []).forEach(c => {
        const name = c.nome;
        if (!map[name]) map[name] = { count: 0, chsSum: 0, csSum: 0, npsSum: 0, negSum: 0, sla1okSum: 0, sla1offSum: 0, sla2okSum: 0, sla2offSum: 0, gestor: c.gestor || "", celular: c.celular || "", agente: c.agente || "" };
        map[name].count++;
        map[name].chsSum += Number(c.chs) || 0;
        map[name].csSum += isNaN(Number(c.cs)) ? 0 : Number(c.cs);
        map[name].npsSum += isNaN(Number(c.nps)) ? 0 : Number(c.nps);
        map[name].negSum += isNaN(Number(c.neg)) ? 0 : Number(c.neg);
        map[name].sla1okSum += Number(c.sla1ok) || 0;
        map[name].sla1offSum += Number(c.sla1off) || 0;
        map[name].sla2okSum += Number(c.sla2ok) || 0;
        map[name].sla2offSum += Number(c.sla2off) || 0;
      });
      return Object.keys(map).map(name => {
        const m = map[name];
        const cnt = m.count || 1;
        return {
          nome: name,
          chs: Math.round(m.chsSum / cnt),
          cs: Math.round(m.csSum / cnt),
          nps: Math.round(m.npsSum / cnt),
          neg: Math.round(m.negSum / cnt),
          sla1ok: Math.round(m.sla1okSum / cnt),
          sla1off: Math.round(m.sla1offSum / cnt),
          sla2ok: Math.round(m.sla2okSum / cnt),
          sla2off: Math.round(m.sla2offSum / cnt),
          gestor: m.gestor,
          celular: m.celular,
          agente: m.agente
        };
      });
    }

    /* Gradient helpers */
    function redGradientForCHS(chs) {
      const c = Math.max(0, Math.min(100, Number(chs) || 0));
      const intensity = Math.max(0, Math.min(1, (60 - c) / 60));
      const light = Math.round(56 - intensity * 20);
      const dark = Math.max(12, light - 18);
      const color1 = `hsl(0,85%,${light}%)`;
      const color2 = `hsl(0,75%,${dark}%)`;
      return `linear-gradient(180deg, ${color1} 0%, ${color2} 100%)`;
    }
    function greenGradientForCHS(chs) {
      const c = Math.max(0, Math.min(100, Number(chs) || 0));
      const intensity = c / 100;
      const light = Math.round(66 - intensity * 32);
      const dark = Math.max(16, light - 24);
      const color1 = `hsl(140,60%,${light}%)`;
      const color2 = `hsl(140,70%,${dark}%)`;
      return `linear-gradient(180deg, ${color1} 0%, ${color2} 100%)`;
    }
    function yellowGradientForCHS(chs) {
      const c = Math.max(0, Math.min(100, Number(chs) || 0));
      const intensity = c / 100;
      const light = Math.round(70 - intensity * 20);
      const dark = Math.max(20, light - 22);
      const color1 = `hsl(45,95%,${light}%)`;
      const color2 = `hsl(45,90%,${dark}%)`;
      return `linear-gradient(180deg, ${color1} 0%, ${color2} 100%)`;
    }

    /* ---------------- Selection modal (main) ---------------- */

    function openSelectModal() {
      renderSelectModalList();
      const m = document.getElementById('selectModal');
      m.style.display = 'flex';
      m.setAttribute('aria-hidden', 'false');
      lockBodyScroll();
      m.classList.remove('fade-out');
      m.classList.add('fade-in');
      const box = m.querySelector('.compare-selector-box');
      if (box) { box.classList.add('scale-in'); setTimeout(function () { box.classList.remove('scale-in'); }, 280); }
      const onEndOpen = function () { if (m.classList.contains('fade-in')) m.classList.remove('fade-in'); m.removeEventListener('animationend', onEndOpen); };
      m.addEventListener('animationend', onEndOpen);
      setTimeout(function () { const s = document.getElementById('selectModalSearch'); if (s) s.focus(); }, 50);
    }

    function closeSelectModal() {
      const m = document.getElementById('selectModal');
      const box = m.querySelector('.compare-selector-box');
      m.classList.remove('fade-in');
      m.classList.add('fade-out');
      if (box) { box.classList.add('slide-down-out'); }
      const onEnd = function () {
        m.style.display = 'none';
        m.setAttribute('aria-hidden', 'true');
        unlockBodyScroll();
        m.classList.remove('fade-out');
        if (box) { box.classList.remove('slide-down-out'); }
        m.removeEventListener('animationend', onEnd);
      };
      m.addEventListener('animationend', onEnd);
    }

    function renderSelectModalList() {
      const listEl = document.getElementById('selectModalList');
      if (!listEl) return;
      listEl.innerHTML = '';
      const term = (document.getElementById('selectModalSearch')?.value || '').toLowerCase().trim();
      let base = clientes || [];
      if (currentMes && currentMes !== 'all') base = base.filter(c => c.dataFmt === currentMes);
      const names = Array.from(new Set(base.map(c => c.nome))).filter(n => !term || n.toLowerCase().includes(term)).sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));
      if (names.length === 0) {
        const p = document.createElement('div'); p.style.color = 'var(--tryvia-dark2)'; p.style.fontWeight = '700'; p.style.padding = '8px'; p.textContent = 'Nenhum cliente disponÃ­vel.'; listEl.appendChild(p); return;
      }
      names.forEach(name => {
        const id = 'sel_' + Math.random().toString(36).substr(2, 9);
        const checked = selectedClients.has(name) ? 'checked' : '';
        const div = document.createElement('div');
        div.className = 'compare-selector-item';
        div.tabIndex = 0;
        div.innerHTML = `<input type="checkbox" id="${id}" data-name="${escapeHtml(name)}" ${checked} onchange="onSelectModalCheckboxChange(this)" /> <span class="client-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span> <span class="chs-badge">${getAverageCHSForName(name)}</span>`;
        const input = div.querySelector('input');
        div.addEventListener('click', (e) => { if (e.target && e.target.tagName !== 'INPUT') { input.checked = !input.checked; onSelectModalCheckboxChange(input); } });
        div.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); input.checked = !input.checked; onSelectModalCheckboxChange(input); } });
        listEl.appendChild(div);
      });
    }

    function onSelectModalCheckboxChange(el) {
      const name = el.getAttribute('data-name');
      if (!name) return;
      if (el.checked) selectedClients.add(name);
      else selectedClients.delete(name);
    }

    function selectAllSelectVisible() {
      document.querySelectorAll('#selectModalList input[type="checkbox"]').forEach(ch => {
        ch.checked = true;
        const n = ch.getAttribute('data-name');
        if (n) selectedClients.add(n);
      });
    }

    function clearAllSelectSelection() {
      document.querySelectorAll('#selectModalList input[type="checkbox"]').forEach(ch => {
        ch.checked = false;
        const n = ch.getAttribute('data-name');
        if (n) selectedClients.delete(n);
      });
    }

    function applySelectSelection() {
      renderDashboard();
      // Update search inputs to reflect selection count
      try { updateSelectedClientsInputLabel(); } catch (e) { }
      closeSelectModal();
    }

    /* ---------------- Compare selector ---------------- */

    function openCompareSelector() {
      compareSelectedClients = new Set();
      populateCompareMonthSelects();
      renderCompareSelector();
      const m = document.getElementById('compareSelectorModal');
      m.style.display = 'flex';
      m.setAttribute('aria-hidden', 'false');
      lockBodyScroll();

      // Trigger smooth animation
      setTimeout(() => {
        m.classList.add('show');
      }, 10);

      setTimeout(function () { const s = document.getElementById('compareModalSearch'); if (s) s.focus(); }, 50);
    }

    function closeCompareSelector() {
      const m = document.getElementById('compareSelectorModal');
      const box = m.querySelector('.compare-selector-box');
      m.classList.remove('fade-in');
      m.classList.add('fade-out');
      if (box) { box.classList.add('slide-down-out'); }
      const onEnd = function () {
        m.style.display = 'none';
        m.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
        m.classList.remove('fade-out');
        if (box) { box.classList.remove('slide-down-out'); }
        m.removeEventListener('animationend', onEnd);
      };
      m.addEventListener('animationend', onEnd);
    }

    function renderCompareSelector() {
      const listEl = document.getElementById('compareSelectorList');
      if (!listEl) return;
      listEl.innerHTML = '';
      const term = (document.getElementById('compareModalSearch')?.value || '').toLowerCase().trim();
      let base = clientes || [];
      const selMonth = document.getElementById('compareModalMesSelect')?.value || 'all';
      if (selMonth && selMonth !== 'all') base = base.filter(c => c.dataFmt === selMonth);
      const names = Array.from(new Set(base.map(c => c.nome))).filter(n => !term || n.toLowerCase().includes(term)).sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));
      if (names.length === 0) {
        const p = document.createElement('div'); p.style.color = 'var(--tryvia-dark2)'; p.style.fontWeight = '700'; p.style.padding = '8px'; p.textContent = 'Nenhum cliente disponÃ­vel para comparar.'; listEl.appendChild(p); return;
      }
      names.forEach(name => {
        const id = 'cmp_' + Math.random().toString(36).substr(2, 9);
        const div = document.createElement('div');
        div.className = 'compare-selector-item';
        div.tabIndex = 0;
        div.innerHTML = `<input type="checkbox" id="${id}" data-name="${escapeHtml(name)}" onchange="onCompareCheckboxChange(this)" /> <span class="client-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span> <span class="chs-badge">${getAverageCHSForName(name)}</span>`;
        listEl.appendChild(div);
      });
    }

    function onCompareCheckboxChange(el) {
      const name = el.getAttribute('data-name');
      if (!name) return;
      if (el.checked) compareSelectedClients.add(name);
      else compareSelectedClients.delete(name);
    }

    function selectAllCompareVisible() {
      document.querySelectorAll('#compareSelectorList input[type="checkbox"]').forEach(ch => {
        ch.checked = true;
        const n = ch.getAttribute('data-name');
        if (n) compareSelectedClients.add(n);
      });
    }

    function clearAllCompareSelection() {
      document.querySelectorAll('#compareSelectorList input[type="checkbox"]').forEach(ch => {
        ch.checked = false;
        const n = ch.getAttribute('data-name');
        if (n) compareSelectedClients.delete(n);
      });
    }

    function applyCompareSelection() {
      const names = Array.from(compareSelectedClients);
      if (names.length < 2) {
        alert('Selecione pelo menos 2 clientes para comparar.');
        return;
      }
      const selMonth = document.getElementById('compareModalMesSelect')?.value || 'all';
      buildCompareChart(names, selMonth);
      closeCompareSelector();
    }

    /* Build compare chart (now accepts optional month) */
    function buildCompareChart(names, month = 'all') {
      const palette = ['#00cfff', '#009f42', '#ffc900', '#e53935', '#0b63b7', '#b86bff', '#ff8a65'];
      const labels = ['SLA', 'NPS', 'Negativas', 'CS'];
      const datasets = [];
      names.forEach((name, idx) => {
        const clienteAgg = getAggregatedClientDataByNameAndMonth(name, month) || aggregateByName(clientes || []).find(c => c.nome === name) || clientes.find(c => c.nome === name);
        if (!clienteAgg) return;
        const slaScore = calcSLA(clienteAgg);
        const npsScore = calcNPS(clienteAgg, clienteAgg.nps);
        const negScore = calcNeg(clienteAgg);
        const csScore = calcCS(clienteAgg, clienteAgg.cs);
        datasets.push({
          label: name,
          data: [slaScore, npsScore, negScore, csScore],
          backgroundColor: palette[idx % palette.length],
          borderColor: palette[idx % palette.length],
          borderWidth: 1,
          barPercentage: 0.95,
          categoryPercentage: 0.9,
          maxBarThickness: 44,
          borderRadius: 12,
          borderSkipped: 'bottom'
        });
      });

      const modal = document.getElementById('compareModal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      lockBodyScroll();
      window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
      modal.classList.remove('fade-out');
      modal.classList.add('fade-in');
      try { const box = modal.querySelector('.compare-modal-box'); if (box) { box.classList.add('scale-in'); setTimeout(function () { box.classList.remove('scale-in'); }, 280); } } catch (e) { }
      const onEndOpen = function () { if (modal.classList.contains('fade-in')) modal.classList.remove('fade-in'); modal.removeEventListener('animationend', onEndOpen); };
      modal.addEventListener('animationend', onEndOpen);

      const topSelect = document.getElementById('compareModalMesSelectTop');
      if (topSelect) topSelect.value = month || 'all';
      modal._lastCompareNames = names;
      modal._lastCompareMonth = month;

      const ctx = document.getElementById('compareChart').getContext('2d');
      if (chartCompare) chartCompare.destroy();
      chartCompare = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom' } }, scales: { y: { beginAtZero: true, max: 60 } } }
      });
      try { animateChartRender('compareChart'); } catch (e) { }
    }

    function rebuildCompareChartFromModal() {
      const modal = document.getElementById('compareModal');
      if (!modal || !modal._lastCompareNames) return;
      const names = modal._lastCompareNames;
      const month = document.getElementById('compareModalMesSelectTop')?.value || 'all';
      buildCompareChart(names, month);
    }

    function closeCompareModal() {
      const modal = document.getElementById('compareModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
      try { if (chartCompare) chartCompare.destroy(); } catch (e) { }
    }

    /* ---------- existing behaviors (import, charts, rankings, client modal) ---------- */

    function togglePlanilhaBox() {
      const box = document.getElementById('planilhaBox');
      const btn = document.getElementById('planilhaToggleBtn');
      if (!box) return;
      if (box.classList.contains('show')) { box.classList.remove('show'); if (btn) btn.textContent = 'â–¾'; }
      else { box.classList.add('show'); if (btn) btn.textContent = 'â–´'; }
    }

    /* Import function */
    function toNumberSafe(val) {
      if (val === null || val === undefined) return NaN;
      const s = String(val).replace(/%/g, '').replace(/,/g, '.').replace(/[^0-9.\-]/g, '').trim();
      if (!s) return NaN;
      const n = parseFloat(s);
      return isNaN(n) ? NaN : n;
    }
    function parseCsvLine(line) {
      const out = []; let cur = ""; let inQ = false; for (let i = 0; i < line.length; i++) { const ch = line[i]; if (inQ) { if (ch === '"') { if (line[i + 1] === '"') { cur += '"'; i++; } else { inQ = false; } } else { cur += ch; } } else { if (ch === '"') { inQ = true; } else if (ch === ',') { out.push(cur.trim()); cur = ''; } else { cur += ch; } } } out.push(cur.trim()); return out;
    }
    function detectCsvDelim(sample) {
      const lines = Array.isArray(sample) ? sample.slice(0, 20) : [String(sample || '')];
      const cands = [',', ';', '\t'];
      let best = ',', bestScore = -1;
      for (const d of cands) {
        let counts = lines.map(l => parseCsvLineWithDelim(l, d).length);
        const uniq = new Set(counts).size;
        const good = counts.filter(n => n >= 6 && n <= 50).length;
        const mean = counts.reduce((a, b) => a + b, 0) / (counts.length || 1);
        const score = good * 100 - uniq * 10 + mean; // prefer consistent, reasonable column counts
        if (score > bestScore) { bestScore = score; best = d; }
      }
      return best;
    }
    function parseCsvLineWithDelim(line, delim) {
      const out = []; let cur = ""; let inQ = false; const d = delim || ',';
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (inQ) {
          if (ch === '"') {
            if (line[i + 1] === '"') { cur += '"'; i++; }
            else { inQ = false; }
          } else { cur += ch; }
        } else {
          if (ch === '"') { inQ = true; }
          else if (ch === d) { out.push(cur.trim()); cur = ''; }
          else { cur += ch; }
        }
      }
      out.push(cur.trim());
      return out;
    }
    // FunÃ§Ã£o para carregar dados automaticamente
    function carregarDoGoogleSheets() {
      try { console.log("Carregando dados do Google Sheets..."); } catch (e) { }
      fetch(URL_DA_PLANILHA)
        .then(response => response.text())
        .then(textoCSV => processarCSV(textoCSV))
        .catch(erro => {
          try { console.error(erro); } catch (e) { }
          alert("Erro ao carregar os dados. Verifique a conexÃ£o.");
        });
    }

    // FunÃ§Ã£o para ler o CSV do Google
    function processarCSV(texto) {
      try {
        let linhas = (texto || '').split(/\r?\n/).filter(l => l.trim());
        let importados = [];
        if (linhas.length === 0) throw new Error('CSV vazio');
        const delim = detectCsvDelim(linhas.slice(0, Math.min(20, linhas.length)));

        // Helpers
        const toNum = (v) => toNumberSafe(v);
        const byHeader = () => {
          const out = [];
          // Parse header and build index map by names
          const normalizeHeader = (s) => {
            let t = String(s || '');
            try {
              if (/[Ã‚Ãƒ]/.test(t)) {
                // tenta corrigir mojibake ISO-8859-1 -> UTF-8
                t = decodeURIComponent(escape(t));
              }
            } catch (e) { }
            t = t.toLowerCase();
            // normaliza ordinais comuns e sÃ­mbolos esquisitos
            t = t.replace(/[Âª]/g, 'a').replace(/[ÂºÂ°]/g, 'o');
            // remove pontuaÃ§Ã£o comum
            t = t.replace(/[.,;:!?"'`Â´^~@#$%&*()_+=\\\/\[\]|{}<>-]+/g, ' ');
            // remove acentos
            t = t.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            // colapsa espaÃ§os
            t = t.replace(/\s+/g, ' ').trim();
            return t;
          };
          const headerCols = parseCsvLineWithDelim(linhas[0] || '', delim).map(c => c != null ? String(c).trim() : "");
          const hnorm = headerCols.map(normalizeHeader);
          const findIdx = (aliases) => { for (const a of aliases) { const idx = hnorm.indexOf(a); if (idx !== -1) return idx; } return -1; };
          const idxNome = findIdx(['cliente', 'nome', 'cliente empresa', 'empresa']);
          const idxData = findIdx(['data', 'mes', 'm\u00eas', 'mÃªs']);
          const idxCS = findIdx(['percepcao cs', 'percepcao', 'percepcao do cliente', 'percepcao cliente', 'percep\u00e7ao cs', 'percepÃ§Ã£o cs', 'cs']);
          const idxNPS = findIdx(['nps rate', 'nps', 'nps medio', 'nps m\u00e9dio']);
          const idxNEG = findIdx(['av neg fresh', 'av neg', 'negativas', 'avaliacoes negativas', 'avalia\u00e7oes negativas', 'avaliacao negativa', 'avalia\u00e7ao negativa', 'neg']);
          const idxS1ok = findIdx(['1a resposta dentro sla', '1 a resposta dentro sla', '1 resposta dentro sla', 'primeira resposta dentro sla', 'primeira resposta ok']);
          const idxS1off = findIdx(['1a resposta fora sla', '1 a resposta fora sla', '1 resposta fora sla', 'primeira resposta fora sla']);
          const idxS2ok = findIdx(['resolucao sla ok', 'resolucao dentro sla', 'resolucao ok', 'resolu\u00e7ao sla ok', 'resolu\u00e7ao dentro sla', 'resolu\u00e7\u00e3o sla ok', 'resoluÃ§Ã£o sla ok']);
          const idxS2off = findIdx(['resolucao off sla', 'resolucao fora sla', 'resolucao off-sla', 'resolucao offsla', 'resolu\u00e7ao off sla', 'resoluÃ§Ã£o off sla', 'resolucao fora do sla', 'resoluÃ§Ã£o fora do sla', 'resolucao off']);
          const idxGestor = findIdx(['gestor', 'responsavel', 'respons\u00e1vel', 'manager']);
          const idxCel = findIdx(['celular', 'telefone', 'phone', 'whatsapp', 'contato']);
          const idxAgente = findIdx(['agente', 'atendente', 'analista']);

          const hasHeader = (idxNome >= 0 && idxData >= 0);
          const inicio = hasHeader ? 1 : 0;
          for (let i = inicio; i < linhas.length; i++) {
            let colunas = parseCsvLineWithDelim(linhas[i], delim); if (!colunas) continue; colunas = colunas.map(c => c != null ? String(c).trim() : ""); if (colunas.length === 0) continue;
            const nome = (idxNome >= 0 ? colunas[idxNome] : (colunas[0] || ''));
            const data = (idxData >= 0 ? colunas[idxData] : (colunas[1] || ''));
            const csRaw = (idxCS >= 0 ? colunas[idxCS] : (colunas[2] || ''));
            const npsRaw = (idxNPS >= 0 ? colunas[idxNPS] : (colunas[3] || ''));
            const negRaw = (idxNEG >= 0 ? colunas[idxNEG] : (colunas[4] || ''));
            const sla1okR = (idxS1ok >= 0 ? colunas[idxS1ok] : (colunas[5] || ''));
            const sla1offR = (idxS1off >= 0 ? colunas[idxS1off] : (colunas[6] || ''));
            const sla2okR = (idxS2ok >= 0 ? colunas[idxS2ok] : (colunas[7] || ''));
            const sla2offR = (idxS2off >= 0 ? colunas[idxS2off] : (colunas[8] || ''));
            const gestor = (idxGestor >= 0 ? colunas[idxGestor] : (colunas[9] || ''));
            const celular = (idxCel >= 0 ? colunas[idxCel] : (colunas[10] || ''));
            const agente = (idxAgente >= 0 ? colunas[idxAgente] : (colunas[11] || ''));
            if (!nome) continue;
            const dataFmt = normalizeYYYYMM(data); if (!data || !dataFmt) continue;
            const cs = toNum(csRaw), nps = toNum(npsRaw), neg = toNum(negRaw);
            const sla1ok = Number(sla1okR || 0), sla1off = Number(sla1offR || 0), sla2ok = Number(sla2okR || 0), sla2off = Number(sla2offR || 0);
            const hasAny = (!isNaN(cs) || !isNaN(nps) || !isNaN(neg) || (sla1ok + sla1off + sla2ok + sla2off) > 0);
            if (!hasAny) continue;
            out.push({ nome, data, dataFmt, cs, nps, neg, sla1ok, sla1off, sla2ok, sla2off, gestor: gestor || "", celular: celular || "", agente: agente || "" });
          }
          return out;
        };
        const byPosition = () => {
          const out = []; const inicio = (/(cliente|nome)/i.test(linhas[0] || '')) ? 1 : 0;
          for (let i = inicio; i < linhas.length; i++) {
            let colunas = parseCsvLineWithDelim(linhas[i], delim);
            if (!colunas) continue;
            colunas = colunas.map(c => c != null ? String(c).trim() : "");
            if (colunas.length < 2) continue;
            const [nome, data, csRaw, npsRaw, negRaw, sla1okR, sla1offR, sla2okR, sla2offR, gestor, celular, agente] = colunas;
            if (!nome) continue;
            const dataFmt = normalizeYYYYMM(data);
            if (!data || !dataFmt) continue;
            const cs = toNum(csRaw), nps = toNum(npsRaw), neg = toNum(negRaw);
            const sla1ok = Number(sla1okR || 0), sla1off = Number(sla1offR || 0), sla2ok = Number(sla2okR || 0), sla2off = Number(sla2offR || 0);
            const hasAny = (!isNaN(cs) || !isNaN(nps) || !isNaN(neg) || (sla1ok + sla1off + sla2ok + sla2off) > 0);
            if (!hasAny) continue;
            out.push({ nome, data, dataFmt, cs, nps, neg, sla1ok, sla1off, sla2ok, sla2off, gestor: gestor || "", celular: celular || "", agente: agente || "" });
          }
          return out;
        };

        // First attempt: header-based
        importados = byHeader();
        // Heuristics: if data seems suspicious, retry positional
        const validCs = importados.filter(r => !isNaN(Number(r.cs))).length;
        const validNps = importados.filter(r => !isNaN(Number(r.nps))).length;
        const validNeg = importados.filter(r => !isNaN(Number(r.neg))).length;
        const tooFewMetrics = importados.length > 0 && ((validCs / importados.length) < 0.2 || (validNps / importados.length) < 0.2 || (validNeg / importados.length) < 0.2);
        if (importados.length === 0 || tooFewMetrics) {
          importados = byPosition();
        }
        // Additional heuristic: if few rows have SLA totals > 0, mapping likely failed for SLA headers
        const slaRows = importados.filter(r => (((Number(r.sla1ok) || 0) + (Number(r.sla1off) || 0) + (Number(r.sla2ok) || 0) + (Number(r.sla2off) || 0)) > 0)).length;
        const lowSlaCoverage = importados.length > 0 && (slaRows / importados.length) < 0.2;
        // If NEG appears implausibly high across the dataset, mapping may have grabbed SLA columns as NEG
        let negMax = 0; try { negMax = Math.max.apply(null, importados.map(r => { const v = Number(r.neg); return isNaN(v) ? 0 : v; })); } catch (e) { negMax = 0; }
        const negLooksWrong = negMax > 20;
        if (lowSlaCoverage || negLooksWrong) {
          const alt = byPosition();
          if (alt && alt.length) importados = alt;
        }

        // Atualiza as variÃ¡veis globais
        clientes = importados;
        preparaClientes(clientes);
        // Se muitos CHS ficaram idÃªnticos (ex.: tudo 38), tenta fallback posicional
        const uniqueChs = new Set((clientes || []).map(c => c.chs)).size;
        if (clientes.length > 30 && uniqueChs <= 3) {
          const alt = byPosition();
          if (alt && alt.length) { clientes = alt; preparaClientes(clientes); }
        }
        clientesFiltrados = [...clientes];

        // Atualiza os filtros de MÃªs na tela
        const meses = Array.from(new Set(clientes.map(c => c.dataFmt).filter(Boolean))).sort();
        const sel = document.getElementById('mesSelect');
        if (sel) {
          // Preenche o select com opÃ§Ã£o "Todos" mas nÃ£o seleciona nada ainda
          sel.innerHTML = `<option value="all">Todos</option>` + meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
          sel.value = 'all'; // Valor padrÃ£o
          currentMes = 'all';
          statusFilter = 'all';
        }

        // Populate compare selects
        populateCompareMonthSelects();

        // Mostra modal para usuÃ¡rio selecionar o mÃªs
        setTimeout(() => {
          showMonthSelectionModal();
        }, 500);
        try { console.log(`Sucesso: ${clientes.length} clientes carregados.`); } catch (e) { }
      } catch (erro) {
        try { console.error(erro); } catch (e) { }
        alert('Erro ao processar os dados.');
      }
    }

    function populateCompareMonthSelects() {
      const meses = Array.from(new Set(clientes.map(c => c.dataFmt).filter(Boolean))).sort();
      const sel1 = document.getElementById('compareModalMesSelect');
      const sel2 = document.getElementById('compareModalMesSelectTop');
      const sel3 = document.getElementById('clienteModalMesSelect');
      const sel4 = document.getElementById('selectModalMesSelect');
      const sel5 = document.getElementById('rankingFiltersMesSelect');
      const lastMonth = meses.length ? meses[meses.length - 1] : meses[0];
      if (sel1) {
        sel1.innerHTML = meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
        sel1.value = lastMonth;
      }
      if (sel2) {
        sel2.innerHTML = meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
        sel2.value = lastMonth;
      }
      if (sel3) {
        sel3.innerHTML = meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
        sel3.value = lastMonth;
      }
      if (sel4) {
        sel4.innerHTML = meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
        sel4.value = lastMonth;
      }
      if (sel5) {
        sel5.innerHTML = meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
        sel5.value = lastMonth;
      }
    }

    /* FIXED: getViewList now correctly applies the status filter to aggregated data when currentMes === 'all'
       so when "Todos" is selected, filtering by Saude/AtenÃ§Ã£o/CrÃ­tico uses the per-client average CHS across months.
    */
    function getViewList() {
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];

      // respect explicit selectedClients (if user picked a subset)
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));

      if (currentMes && currentMes !== 'all') {
        // month-specific view: aggregate per client for that month to keep consistency across rankings
        const rows = base.filter(c => c.dataFmt === currentMes);
        let aggregatedMonth = aggregateByName(rows);
        if (statusFilter && statusFilter !== 'all') {
          aggregatedMonth = aggregatedMonth.filter(c => {
            const st = getStatusCHS(c.chs).cls;
            return st === statusFilter;
          });
        }
        return aggregatedMonth;
      } else {
        // "Todos" -> usar a mesma agregaÃ§Ã£o da pÃ¡gina/modal: mÃ©dia do CHS por cliente (across months)
        let aggregated = aggregateByName(base);
        if (statusFilter && statusFilter !== 'all') {
          aggregated = aggregated.filter(a => getStatusCHS(a.chs).cls === statusFilter);
        }
        return aggregated;
      }
    }

    /* New helper: count visible unique client names considering current search/filter/selection/month */
    function getVisibleUniqueClientCount() {
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];

      // apply selectedClients filter if user has explicitly selected a subset
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));

      // when filtering by month, work on records; otherwise aggregation per client
      if (currentMes && currentMes !== 'all') {
        base = base.filter(c => c.dataFmt === currentMes);
        if (statusFilter && statusFilter !== 'all') {
          base = base.filter(c => getStatusCHS(c.chs).cls === statusFilter);
        }
        const names = new Set((base || []).map(r => r.nome));
        return names.size;
      } else {
        // aggregate per name for "Todos"
        let aggregated = aggregateByName(base);
        if (statusFilter && statusFilter !== 'all') {
          aggregated = aggregated.filter(a => getStatusCHS(a.chs).cls === statusFilter);
        }
        return aggregated.length;
      }
    }

    function onMesChange(val) {
      currentMes = val || 'all';
      // sync float select if present
      const floatMes = document.getElementById('floatMesSelect');
      const mainMes = document.getElementById('mesSelect');
      if (floatMes && mainMes && floatMes.value !== mainMes.value) floatMes.value = mainMes.value;
      rankingPage = 1;
      renderDashboard();
      renderSelectModalList();
      renderCompareSelector();
    }

    function filtrarClientes() {
      const mainEl = document.getElementById('searchInput');
      const floatEl = document.getElementById('floatSearchInput');
      const val = (mainEl && typeof mainEl.value === 'string') ? mainEl.value : (floatEl && typeof floatEl.value === 'string' ? floatEl.value : '');
      const searchTerm = (val || '').toLowerCase();
      if (!searchTerm) clientesFiltrados = [...(clientes || [])];
      else clientesFiltrados = (clientes || []).filter(cliente => ((cliente.nome || '').toLowerCase().includes(searchTerm)));
      rankingPage = 1;
      renderDashboard();
      // Keep suggestions updated as user types
      try { renderSuggestions(); } catch (e) { }
    }

    /* per-chart type toggling */
    function toggleChartTypeFor(which) {
      const types = ['bar', 'line'];
      const typesDistrib = ['bar', 'doughnut'];
      if (which === 'distrib') {
        const idx = typesDistrib.indexOf(chartTypeDistrib);
        chartTypeDistrib = typesDistrib[(idx + 1) % typesDistrib.length];
        createChartDistribuicao();
      } else if (which === 'evol') {
        const idx = types.indexOf(chartTypeEvol);
        chartTypeEvol = types[(idx + 1) % types.length];
        createChartEvolucao();
      } else if (which === 'sla') {
        const idx = types.indexOf(chartTypeSLA);
        chartTypeSLA = types[(idx + 1) % types.length];
        createChartSLA();
      } else if (which === 'cs') {
        const idx = types.indexOf(chartTypeCS);
        chartTypeCS = types[(idx + 1) % types.length];
        createChartCS();
      } else if (which === 'nps') {
        const idx = types.indexOf(chartTypeNPS);
        chartTypeNPS = types[(idx + 1) % types.length];
        createChartNPS();
      } else if (which === 'neg') {
        const idx = types.indexOf(chartTypeNEG);
        chartTypeNEG = types[(idx + 1) % types.length];
        createChartNEG();
      }
    }

    /* handle clicks on summary boxes to filter by status or show all */
    function onSummaryClick(key) {
      statusFilter = key === 'all' ? 'all' : key;
      rankingPage = 1;
      renderDashboard();
    }


    /* Rendering dashboard and parts */
    function renderDashboard() {
      renderSummary();
      renderTable();
      createCharts();
      renderRankings();
      renderSelectModalList();
      renderCompareSelector();
    }

    /* Utility: get list of all months present (sorted ascending) */
    function getAllMonthsSorted() {
      const meses = Array.from(new Set((clientes || []).map(c => c.dataFmt).filter(Boolean))).sort();
      return meses;
    }

    /* Utility: returns previous month in 'YYYY-MM' format or null */
    function previousMonthString(ym) {
      if (!ym) return null;
      const parts = ym.split('-');
      if (parts.length < 2) return null;
      let y = parseInt(parts[0], 10), m = parseInt(parts[1], 10);
      if (isNaN(y) || isNaN(m)) return null;
      m = m - 1;
      if (m < 1) { y = y - 1; m = 12; }
      if (y < 0) return null;
      const mm = m < 10 ? '0' + m : '' + m;
      return `${y}-${mm}`;
    }

    /* Utility: get CHS for a client in a given month WITHOUT fallback.
       If there are no records for that client in that month, return null.
       This avoids inferring tendÃªncia (alta/queda) quando nÃ£o hÃ¡ mÃªs anterior vÃ¡lido. */
    function getCHSForClientInMonth(name, month) {
      if (!month) return null;
      const target = normalizeYYYYMM(month);
      if (!target) return null;
      const rows = (clientes || []).filter(c => c.nome === name && normalizeYYYYMM(c.dataFmt) === target);
      if (rows.length === 0) return null;
      const avg = Math.round(rows.reduce((s, r) => s + (Number(r.chs) || 0), 0) / rows.length);
      return Math.max(0, Math.min(100, avg));
    }

    /* Rendering functions for rankings, charts, table, client modal etc. */
    function renderRankings() {
      // Determine how many unique clients are visible under current filters/search/month
      const visibleUniqueCount = getVisibleUniqueClientCount();

      const pioresContainer = document.getElementById('rankingPiores');
      const melhoresContainer = document.getElementById('rankingMelhores');

      // When fewer than 6 unique clients are visible, hide the side rankings (same logic as 'Selecionar clientes' behavior),
      // and only show the geral ranking. This also applies when searching a single client.
      if (visibleUniqueCount >= 6) {
        if (pioresContainer) pioresContainer.style.display = '';
        if (melhoresContainer) melhoresContainer.style.display = '';
        renderRankingPiores();
        renderRankingMelhores();
        try { const row = document.querySelector('.dashboard-rankings-row'); if (row) row.classList.remove('one-only'); } catch (e) { }
      } else {
        if (pioresContainer) pioresContainer.style.display = 'none';
        if (melhoresContainer) melhoresContainer.style.display = 'none';
        const pList = document.getElementById('rankingPioresList');
        const mList = document.getElementById('rankingMelhoresList');
        if (pList) pList.innerHTML = '';
        if (mList) mList.innerHTML = '';
        try { const row = document.querySelector('.dashboard-rankings-row'); if (row) row.classList.add('one-only'); } catch (e) { }
      }

      renderRankingGeral();
    }

    function renderSummary() {
      const view = getViewList();
      const total = view.length || 0;
      // thresholds updated per your request:
      // SaudÃ¡vel: >=70, AtenÃ§Ã£o: >=40 && <70, CrÃ­tico: <40
      const saudavel = view.filter(c => c.chs >= 70).length;
      const atencao = view.filter(c => c.chs >= 40 && c.chs < 70).length;
      const critico = view.filter(c => c.chs < 40).length;
      const chsGeral = total ? Math.round(view.reduce((sum, c) => sum + c.chs, 0) / total) : '--';
      document.getElementById('chsTotalVal').textContent = total;
      document.getElementById('chsSaudavelVal').textContent = saudavel;
      document.getElementById('chsAtencaoVal').textContent = atencao;
      document.getElementById('chsCriticoVal').textContent = critico;
      document.getElementById('chsGeralValor').textContent = chsGeral;

      ['chsTotal', 'chsSaudavel', 'chsAtencao', 'chsCritico'].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.style.boxShadow = '';
        el.style.transform = '';
      });
      if (statusFilter === 'all' || statusFilter === null) {
        const el = document.getElementById('chsTotal'); if (el) { el.style.boxShadow = '0 6px 20px rgba(0,0,0,0.08)'; el.style.transform = 'translateY(-4px)'; }
      } else if (statusFilter === 'saude') {
        const el = document.getElementById('chsSaudavel'); if (el) { el.style.boxShadow = '0 6px 20px rgba(0,0,0,0.08)'; el.style.transform = 'translateY(-4px)'; }
      } else if (statusFilter === 'atencao') {
        const el = document.getElementById('chsAtencao'); if (el) { el.style.boxShadow = '0 6px 20px rgba(0,0,0,0.08)'; el.style.transform = 'translateY(-4px)'; }
      } else if (statusFilter === 'critico') {
        const el = document.getElementById('chsCritico'); if (el) { el.style.boxShadow = '0 6px 20px rgba(0,0,0,0.08)'; el.style.transform = 'translateY(-4px)'; }
      }

      // Update CHS Geral box to reflect the cognitive state and heart/icon color
      try {
        const geralEl = document.getElementById('chsGeralBox');
        const heartEl = document.getElementById('chsHeart');
        if (geralEl) {
          // remove previous status classes
          geralEl.classList.remove('saude', 'atencao', 'critico');
          if (chsGeral !== '--' && !isNaN(Number(chsGeral))) {
            const statusObj = getStatusCHS(Number(chsGeral));
            // Add status class so CSS rules color the heart and background appropriately
            geralEl.classList.add(statusObj.cls);
            if (heartEl) {
              // Change the displayed icon according to status:
              if (statusObj.cls === 'saude') {
                heartEl.textContent = 'ðŸ’š';
              } else if (statusObj.cls === 'atencao') {
                // attention icon (will be colored by CSS via parent .atencao)
                heartEl.textContent = 'âš ï¸';
              } else {
                // critical -> red X icon
                heartEl.textContent = 'âŒ';
              }
            }
          } else {
            if (heartEl) heartEl.textContent = 'ðŸ’š';
          }
        }
      } catch (e) { }
    }

    function renderTable() {
      let tbody = document.querySelector('#chs-table tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      const base = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let rows = (currentMes && currentMes !== 'all') ? base.filter(c => c.dataFmt === currentMes) : base;
      if (selectedClients && selectedClients.size > 0) rows = rows.filter(r => selectedClients.has(r.nome));
      if (statusFilter && statusFilter !== 'all') rows = rows.filter(r => getStatusCHS(r.chs).cls === statusFilter);
      (rows || []).forEach(cli => {
        let status = getStatusCHS(cli.chs);
        let row = document.createElement('tr');
        row.innerHTML = `
      <td><span class="client-card" title="${escapeHtml(cli.nome)}" onclick="abrirClienteModal('${escapeHtml(cli.nome)}')">${escapeHtml(cli.nome)}</span></td>
      <td>${escapeHtml(cli.data)}</td>
      <td><b>${cli.chs}</b></td>
      <td><span class="status ${status.cls}">${status.txt}</span></td>
      <td>${cli.cs || '-'}</td>
      <td>${cli.nps || '-'}</td>
      <td>${cli.neg || '-'}</td>
      <td>${cli.sla1ok || '-'}</td>
      <td>${cli.sla1off || '-'}</td>
      <td>${cli.sla2ok || '-'}</td>
      <td>${cli.sla2off || '-'}</td>
      <td>
        <button class="btn" onclick="verDetalhes('${escapeHtml(cli.nome)}')">Ver</button>
        <button class="btn" onclick="editarCliente('${escapeHtml(cli.nome)}')">Editar</button>
        <button class="btn" onclick="ligarCliente('${escapeHtml(cli.nome)}')">Ligar</button>
      </td>
    `;
        tbody.appendChild(row);
      });
    }

    function createCharts() {
      try { recalculateAllChs(); } catch (e) { }
      createChartDistribuicao();
      // Ensure TrendUp chart is created initially as it is visible by default
      try { createChartTrendUp(); } catch (e) { }
      createChartIndicadores();
    }

    /* Charts months menu removed */

    function createChartDistribuicao() {
      const canvas = document.getElementById('chartChsDistrib');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartChsDistrib) chartChsDistrib.destroy();
      const view = getViewList();
      // thresholds parametrizados
      const thSaude = (CHS_CONFIG && CHS_CONFIG.thresholds && CHS_CONFIG.thresholds.saude) || 70;
      const thAtencao = (CHS_CONFIG && CHS_CONFIG.thresholds && CHS_CONFIG.thresholds.atencao) || 40;
      const saudavel = view.filter(c => c.chs >= thSaude).length;
      const atencao = view.filter(c => c.chs >= thAtencao && c.chs < thSaude).length;
      const critico = view.filter(c => c.chs < thAtencao).length;
      const typeRaw = chartTypeDistrib || 'bar';
      const type = (typeRaw === 'bar' || typeRaw === 'doughnut') ? typeRaw : 'doughnut';
      const labels = ['SaudÃ¡vel', 'AtenÃ§Ã£o', 'CrÃ­tico'];
      const dataArr = [saudavel, atencao, critico];
      const colors = ['#009f42', '#ffc900', '#e53935'];

      const barDataset = { data: dataArr, backgroundColor: colors, borderColor: ['#007a33', '#e6b400', '#c62828'], borderWidth: 2, barPercentage: 0.95, categoryPercentage: 0.9, maxBarThickness: 44, borderRadius: 12, borderSkipped: 'bottom' };
      const donutDataset = { data: dataArr, backgroundColor: colors, borderColor: '#ffffff', borderWidth: 2 };
      const lineDataset = { label: 'DistribuiÃ§Ã£o CHS', data: dataArr, fill: true, backgroundColor: 'rgba(0,207,255,0.18)', borderColor: '#0b63b7', pointBackgroundColor: '#0b63b7', pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 4, pointHoverRadius: 6, borderWidth: 3 };
      const dataset = (type === 'bar') ? barDataset : (type === 'doughnut' ? donutDataset : lineDataset);

      let options = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: type === 'pie' || type === 'doughnut', labels: { boxWidth: 12 } } } };
      if (type === 'bar') {
        options.scales = { y: { beginAtZero: true } };
        options.animation = false;
      } else if (type === 'doughnut') {
        options.cutout = '65%';
        options.plugins.legend = { position: 'bottom', labels: { boxWidth: 12, padding: 10, font: { size: 11 } } };
        options.plugins.tooltip = { callbacks: { label: (ctx) => `${ctx.label}: ${ctx.parsed}` } };
        options.layout = { padding: { top: 5, bottom: 5, left: 5, right: 5 } };
        // grid background handled by DoughnutGridBG plugin
      }

      chartChsDistrib = new Chart(ctx, { type, data: { labels, datasets: [dataset] }, options });
      try { animateChartRender('chartChsDistrib'); } catch (e) { }
    }

    function createChartEvolucao() {
      let ctx = document.getElementById('chartChsEvolucao').getContext('2d');
      if (chartChsEvolucao) chartChsEvolucao.destroy();
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
      let mesesMap = {};
      (base || []).forEach(cli => { if (cli.dataFmt) { if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = []; mesesMap[cli.dataFmt].push(cli.chs); } });
      let meses = Object.keys(mesesMap).sort();
      let medias = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
      let chartType = chartTypeEvol || 'bar';
      let effectiveType = (chartType === 'pie' || chartType === 'doughnut') ? 'line' : chartType;

      // Compute diffs between consecutive months to style up/down trends
      const diffs = medias.map((v, i) => i === 0 ? 0 : v - medias[i - 1]);
      const upColor = '#009f42';     // tryvia green
      const downColor = '#e53935';   // tryvia red
      const neutralColor = '#0b63b7';// tryvia blue
      const cyanFill = 'rgba(0,207,255,0.18)';

      // Per-point background color (based on delta vs mÃªs anterior)
      const pointBg = diffs.map(d => d > 0 ? upColor : (d < 0 ? downColor : neutralColor));
      const barBg = pointBg; // same logic for bars

      const labelsFmt = meses.map(formatMesAno);
      const datasetCommon = {
        label: 'CHS MÃ©dio',
        data: medias,
        borderWidth: 2
      };

      let dataset;
      let options;
      if (effectiveType === 'line') {
        dataset = Object.assign({}, datasetCommon, {
          fill: true,
          backgroundColor: cyanFill,
          borderColor: neutralColor, // default, segments will override
          pointBackgroundColor: pointBg,
          pointBorderColor: '#ffffff',
          pointBorderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          segment: {
            borderColor: ctx => {
              const dy = ctx.p1.parsed.y - ctx.p0.parsed.y;
              return dy > 0 ? upColor : (dy < 0 ? downColor : neutralColor);
            },
            borderWidth: 3
          }
        });
        options = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const i = context.dataIndex;
                  const val = context.parsed.y;
                  if (i === 0) return `CHS: ${val}`;
                  const prevCal = previousMonthString(meses[i]);
                  if (meses[i - 1] !== prevCal) return `CHS: ${val}`;
                  const d = val - medias[i - 1];
                  const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”');
                  const signVal = d > 0 ? `+${d}` : `${d}`;
                  return `CHS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`;
                }
              }
            },
            targetLine: { y: 70, color: '#666', width: 2, dash: [6, 4] }
          },
          scales: { y: { beginAtZero: true, max: 100 } }
        };
      } else {
        // Bar style per month colored by movement vs mÃªs anterior
        dataset = Object.assign({}, datasetCommon, {
          backgroundColor: barBg,
          borderColor: barBg,
          borderWidth: 2,
          barPercentage: 0.95,
          categoryPercentage: 0.9,
          maxBarThickness: 44,
          borderRadius: 12,
          borderSkipped: 'bottom',
          animations: { y: { from: 0 } }
        });
        options = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const i = context.dataIndex;
                  const val = context.parsed.y;
                  if (i === 0) return `CHS: ${val}`;
                  const prevCal = previousMonthString(meses[i]);
                  if (meses[i - 1] !== prevCal) return `CHS: ${val}`;
                  const d = val - medias[i - 1];
                  const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”');
                  const signVal = d > 0 ? `+${d}` : `${d}`;
                  return `CHS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`;
                }
              }
            },
            targetLine: { y: 70, color: '#666', width: 2, dash: [6, 4] }
          },
          scales: { y: { beginAtZero: true, max: 100 } }
        };
        options.animation = false;
      }

      chartChsEvolucao = new Chart(ctx, {
        type: effectiveType,
        data: { labels: labelsFmt, datasets: [dataset] },
        options
      });
      try { animateChartRender('chartChsEvolucao'); } catch (e) { }
    }

    function createChartChsBreakdown() {
      const canvas = document.getElementById('chartChsBreakdown'); if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartChsBreakdown) chartChsBreakdown.destroy();
      const view = (typeof getViewList === 'function') ? getViewList() : (clientesFiltrados && clientesFiltrados.length ? clientesFiltrados : clientes);
      const w = normalizeWeights(CHS_CONFIG.weights);
      // mÃ©dia das mÃ©tricas normalizadas para a visÃ£o atual
      const acc = { cs: 0, nps: 0, neg: 0, sla: 0, n: 0, has: { cs: 0, nps: 0, neg: 0, sla: 0 } };
      (view || []).forEach(cli => {
        const m = normalizeMetrics(cli);
        if (m.cs != null) { acc.cs += m.cs; acc.has.cs++; }
        if (m.nps != null) { acc.nps += m.nps; acc.has.nps++; }
        if (m.neg != null) { acc.neg += m.neg; acc.has.neg++; }
        if (m.sla != null) { acc.sla += m.sla; acc.has.sla++; }
        acc.n++;
      });
      const avg = {
        cs: acc.has.cs ? Math.round(acc.cs / acc.has.cs) : 0,
        nps: acc.has.nps ? Math.round(acc.nps / acc.has.nps) : 0,
        neg: acc.has.neg ? Math.round(acc.neg / acc.has.neg) : 0,
        sla: acc.has.sla ? Math.round(acc.sla / acc.has.sla) : 0
      };
      const labels = ['CS', 'NPS', 'SLA', 'Negativas(â—€ melhor)'];
      const values = [avg.cs * w.cs, avg.nps * w.nps, avg.sla * w.sla, avg.neg * w.neg].map(v => Math.round(v));
      const colors = ['#6b43b8', '#0b63b7', '#009f42', '#e53935'];
      const type = chartTypeBreakdown === 'doughnut' ? 'doughnut' : 'bar';
      const datasetBar = { data: values, backgroundColor: colors, borderColor: colors, borderWidth: 2, barPercentage: 0.9, categoryPercentage: 0.9, maxBarThickness: 44, borderRadius: 12, borderSkipped: 'bottom' };
      const datasetDonut = { data: values, backgroundColor: colors, borderColor: '#fff', borderWidth: 2 };
      const dataset = (type === 'bar') ? datasetBar : datasetDonut;
      let options = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => `${labels[ctx.dataIndex]}: ${ctx.parsed}` } } } };
      if (type === 'bar') options.scales = { y: { beginAtZero: true, max: 100 } };
      chartChsBreakdown = new Chart(ctx, { type, data: { labels, datasets: [dataset] }, options });
      try { animateChartRender('chartChsBreakdown'); } catch (e) { }
    }

    /* Trend charts on main dashboard */
    function createChartTrendDown() {
      const canvas = document.getElementById('chartTrendDown'); if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartTrendDown) chartTrendDown.destroy();
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
      const months = Array.from(new Set((base || []).map(c => c.dataFmt).filter(Boolean))).sort();
      const names = Array.from(new Set((base || []).map(c => (c.nome || '').toString().trim()).filter(Boolean)));
      const labelsFmt = months.map(formatMesAno);
      const dataSeries = months.map(m => {
        const curr = normalizeYYYYMM(m); const prev = previousMonthString(curr);
        if (!prev) return 0;
        let down = 0, total = 0;
        for (const n of names) {
          const pv = getCHSForClientInMonth(n, prev); const cv = getCHSForClientInMonth(n, curr);
          if (pv == null || cv == null) continue; total++; if (cv < pv) down++;
        }
        return total ? Math.round((down / total) * 1000) / 10 : 0;
      });
      chartTrendDown = new Chart(ctx, {
        type: 'line',
        data: { labels: labelsFmt, datasets: [{ label: '% em queda', data: dataSeries, fill: true, backgroundColor: 'rgba(229,57,53,0.12)', borderColor: '#e53935', borderWidth: 3, pointRadius: 4, pointHoverRadius: 6, tension: 0.25 }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (ctx) => (ctx.parsed.y ?? 0) + '%' } } }, scales: { y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, callback: v => v + '%' } } } }
      });
      try { animateChartRender('chartTrendDown'); } catch (e) { }
    }
    function createChartTrendUp() {
      const canvas = document.getElementById('chartTrendUp'); if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartTrendUp) chartTrendUp.destroy();
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
      const months = Array.from(new Set((base || []).map(c => c.dataFmt).filter(Boolean))).sort();
      const names = Array.from(new Set((base || []).map(c => (c.nome || '').toString().trim()).filter(Boolean)));
      const labelsFmt = months.map(formatMesAno);
      const upPercs = [], downPercs = [], neutralPercs = [];
      months.forEach(m => {
        const curr = normalizeYYYYMM(m); const prev = previousMonthString(curr);
        if (!prev) { upPercs.push(0); downPercs.push(0); neutralPercs.push(0); return; }
        let up = 0, down = 0, neutral = 0, total = 0;
        for (const n of names) {
          const pv = getCHSForClientInMonth(n, prev); const cv = getCHSForClientInMonth(n, curr);
          if (pv == null || cv == null) continue; total++;
          if (cv > pv) up++; else if (cv < pv) down++; else neutral++;
        }
        const denom = total || 1;
        upPercs.push(Math.round((up / denom) * 1000) / 10);
        downPercs.push(Math.round((down / denom) * 1000) / 10);
        neutralPercs.push(Math.round((neutral / denom) * 1000) / 10);
      });
      chartTrendUp = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labelsFmt, datasets: [
            { label: '% em alta', data: upPercs, fill: false, borderColor: '#009f42', backgroundColor: 'rgba(0,159,66,0.12)', borderWidth: 3, pointRadius: 4, pointHoverRadius: 6, tension: 0.25 },
            { label: '% em queda', data: downPercs, fill: false, borderColor: '#e53935', backgroundColor: 'rgba(229,57,53,0.12)', borderWidth: 3, pointRadius: 4, pointHoverRadius: 6, tension: 0.25 },
            { label: '% neutros', data: neutralPercs, fill: false, borderColor: '#0b63b7', backgroundColor: 'rgba(11,99,183,0.12)', borderWidth: 3, pointRadius: 4, pointHoverRadius: 6, tension: 0.25 }
          ]
        },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${(ctx.parsed.y ?? 0)}%` } } }, scales: { y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, callback: v => v + '%' } } } }
      });
      try { animateChartRender('chartTrendUp'); } catch (e) { }
    }

    /* ========= New indicator charts ========= */
    function createChartSLA() {
      const canvas = document.getElementById('chartSlaEvolucao'); if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartSlaEvolucao) chartSlaEvolucao.destroy();
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
      const mesesMap = {};
      (base || []).forEach(cli => {
        if (!cli.dataFmt) return;
        // compute SLA% per row
        const t1 = Number(cli.sla1ok) || 0, f1 = Number(cli.sla1off) || 0, t2 = Number(cli.sla2ok) || 0, f2 = Number(cli.sla2off) || 0;
        const p1 = (t1 + f1) > 0 ? (t1 / (t1 + f1)) : null;
        const p2 = (t2 + f2) > 0 ? (t2 / (t2 + f2)) : null;
        const pct = (p1 != null && p2 != null) ? Math.round(((p1 + p2) / 2) * 100) : (p1 != null ? Math.round(p1 * 100) : (p2 != null ? Math.round(p2 * 100) : null));
        if (pct == null) return;
        if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
        mesesMap[cli.dataFmt].push(pct);
      });
      let meses = Object.keys(mesesMap).sort();
      // SLA must be shown in %: average of row percentages per month
      let series = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
      const diffs = series.map((v, i) => i === 0 ? 0 : v - series[i - 1]);
      const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
      const pointBg = diffs.map(d => d > 0 ? upColor : (d < 0 ? downColor : neutralColor));
      const labelsFmt = meses.map(formatMesAno);
      const effectiveType = chartTypeSLA || 'line';
      let dataset, options;
      if (effectiveType === 'line') {
        dataset = { label: 'SLA (%)', data: series, fill: true, backgroundColor: cyanFill, borderColor: neutralColor, pointBackgroundColor: pointBg, pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 4, pointHoverRadius: 6, borderWidth: 3, segment: { borderColor: ctx => { const dy = ctx.p1.parsed.y - ctx.p0.parsed.y; return dy > 0 ? upColor : (dy < 0 ? downColor : neutralColor); } } };
        options = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `SLA: ${val}%`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `SLA: ${val}%`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `SLA: ${val}%  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales: { y: { beginAtZero: true, max: 100 } } };
      } else {
        dataset = { label: 'SLA (%)', data: series, backgroundColor: pointBg, borderColor: pointBg, borderWidth: 2, barPercentage: 0.95, categoryPercentage: 0.9, maxBarThickness: 44, borderRadius: 12, borderSkipped: 'bottom' };
        options = { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `SLA: ${val}%`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `SLA: ${val}%`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `SLA: ${val}%  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales: { y: { beginAtZero: true, max: 100 } } };
      }
      chartSlaEvolucao = new Chart(ctx, { type: effectiveType, data: { labels: labelsFmt, datasets: [dataset] }, options });
      try { animateChartRender('chartSlaEvolucao'); } catch (e) { }
    }

    function createChartCS() {
      const canvas = document.getElementById('chartCsEvolucao'); if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartCsEvolucao) chartCsEvolucao.destroy();
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
      const mesesMap = {};
      (base || []).forEach(cli => { if (cli.dataFmt && !isNaN(Number(cli.cs))) { if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = []; mesesMap[cli.dataFmt].push(Number(cli.cs)); } });
      let meses = Object.keys(mesesMap).sort();
      let series = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
      const diffs = series.map((v, i) => i === 0 ? 0 : v - series[i - 1]);
      const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
      const pointBg = diffs.map(d => d > 0 ? upColor : (d < 0 ? downColor : neutralColor));
      const labelsFmt = meses.map(formatMesAno);
      const effectiveType = chartTypeCS || 'line';
      let dataset, options;
      if (effectiveType === 'line') {
        dataset = { label: 'CS MÃ©dio', data: series, fill: true, backgroundColor: cyanFill, borderColor: neutralColor, pointBackgroundColor: pointBg, pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 4, pointHoverRadius: 6, borderWidth: 3, segment: { borderColor: ctx => { const dy = ctx.p1.parsed.y - ctx.p0.parsed.y; return dy > 0 ? upColor : (dy < 0 ? downColor : neutralColor); } } };
        options = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true },
            tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `CS: ${val}`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `CS: ${val}`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `CS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } }
          },
          scales: { y: { beginAtZero: true, max: 10 } }
        };
      } else {
        dataset = { label: 'CS MÃ©dio', data: series, backgroundColor: pointBg, borderColor: pointBg, borderWidth: 2, barPercentage: 0.95, categoryPercentage: 0.9, maxBarThickness: 44, borderRadius: 12, borderSkipped: 'bottom' };
        options = { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `CS: ${val}`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `CS: ${val}`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `CS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales: { y: { beginAtZero: true, max: 10 } } };
      }
      chartCsEvolucao = new Chart(ctx, { type: effectiveType, data: { labels: labelsFmt, datasets: [dataset] }, options });
      try { animateChartRender('chartCsEvolucao'); } catch (e) { }
    }

    function createChartNPS() {
      const canvas = document.getElementById('chartNpsEvolucao'); if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartNpsEvolucao) chartNpsEvolucao.destroy();
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
      const mesesMap = {};
      (base || []).forEach(cli => { if (cli.dataFmt && !isNaN(Number(cli.nps))) { if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = []; mesesMap[cli.dataFmt].push(Number(cli.nps)); } });
      let meses = Object.keys(mesesMap).sort();
      let series = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
      const diffs = series.map((v, i) => i === 0 ? 0 : v - series[i - 1]);
      const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
      const pointBg = diffs.map(d => d > 0 ? upColor : (d < 0 ? downColor : neutralColor));
      const labelsFmt = meses.map(formatMesAno);
      const effectiveType = chartTypeNPS || 'line';
      let dataset, options;
      if (effectiveType === 'line') {
        dataset = { label: 'NPS MÃ©dio', data: series, fill: true, backgroundColor: cyanFill, borderColor: neutralColor, pointBackgroundColor: pointBg, pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 4, pointHoverRadius: 6, borderWidth: 3, segment: { borderColor: ctx => { const dy = ctx.p1.parsed.y - ctx.p0.parsed.y; return dy > 0 ? upColor : (dy < 0 ? downColor : neutralColor); } } };
        options = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `NPS: ${val}`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `NPS: ${val}`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `NPS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales: { y: { beginAtZero: true, max: 10 } } };
      } else {
        dataset = { label: 'NPS MÃ©dio', data: series, backgroundColor: pointBg, borderColor: pointBg, borderWidth: 2, barPercentage: 0.95, categoryPercentage: 0.9, maxBarThickness: 44, borderRadius: 12, borderSkipped: 'bottom' };
        options = { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `NPS: ${val}`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `NPS: ${val}`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `NPS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales: { y: { beginAtZero: true, max: 10 } } };
      }
      chartNpsEvolucao = new Chart(ctx, { type: effectiveType, data: { labels: labelsFmt, datasets: [dataset] }, options });
      try { animateChartRender('chartNpsEvolucao'); } catch (e) { }
    }

    function createChartNEG() {
      const canvas = document.getElementById('chartNegEvolucao'); if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartNegEvolucao) chartNegEvolucao.destroy();
      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
      const mesesMap = {};
      (base || []).forEach(cli => {
        if (!cli.dataFmt) return;
        let raw = (cli.neg !== undefined ? cli.neg : null);
        if (raw === null || raw === '' || isNaN(Number(raw))) {
          raw = (cli.negativas !== undefined ? cli.negativas : raw);
        }
        if (raw === null || raw === '' || isNaN(Number(raw))) {
          raw = (cli.avNeg !== undefined ? cli.avNeg : raw);
        }
        if (raw === null || raw === '' || isNaN(Number(raw))) {
          raw = (cli.av_neg !== undefined ? cli.av_neg : raw);
        }
        if (raw === null || raw === '' || isNaN(Number(raw))) {
          raw = (cli.avNegFresh !== undefined ? cli.avNegFresh : raw);
        }
        let val = null;
        if (raw !== null && raw !== undefined) {
          const s = String(raw).replace(',', '.').replace(/[^0-9.\-]/g, '');
          const n = parseFloat(s);
          if (!isNaN(n)) val = n;
        }
        if (val === null) return;
        if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
        mesesMap[cli.dataFmt].push(val);
      });
      const meses = Object.keys(mesesMap).sort();
      const series = meses.map(m => mesesMap[m].reduce((a, b) => a + b, 0));
      const diffs = series.map((v, i) => i === 0 ? 0 : v - series[i - 1]);
      const upColor = '#e53935', downColor = '#009f42', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
      // For negatives, up is worse, so invert colors: increase -> red, decrease -> green
      const pointBg = diffs.map(d => d > 0 ? upColor : (d < 0 ? downColor : neutralColor));
      const labelsFmt = meses.map(formatMesAno);
      const effectiveType = chartTypeNEG || 'line';
      const maxVal = series.reduce((m, v) => Math.max(m, v || 0), 0);
      const yMax = Math.max(5, Math.ceil(maxVal * 1.4));
      let dataset, options;
      if (effectiveType === 'line') {
        dataset = { label: 'AvaliaÃ§Ãµes Negativas (Qtd)', data: series, fill: true, backgroundColor: cyanFill, borderColor: neutralColor, pointBackgroundColor: pointBg, pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 4, pointHoverRadius: 6, borderWidth: 3, segment: { borderColor: ctx => { const dy = ctx.p1.parsed.y - ctx.p0.parsed.y; return dy > 0 ? '#e53935' : (dy < 0 ? '#009f42' : neutralColor); } } };
        options = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `Negativas: ${val}`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `Negativas: ${val}`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `Negativas: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales: { y: { beginAtZero: true, max: yMax } } };
      } else {
        dataset = { label: 'AvaliaÃ§Ãµes Negativas (Qtd)', data: series, backgroundColor: pointBg, borderColor: pointBg, borderWidth: 2, barPercentage: 0.95, categoryPercentage: 0.9, maxBarThickness: 44, borderRadius: 12, borderSkipped: 'bottom' };
        options = { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (context) => { const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `Negativas: ${val}`; const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `Negativas: ${val}`; const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `Negativas: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales: { y: { beginAtZero: true, max: yMax } } };
      }
      chartNegEvolucao = new Chart(ctx, { type: effectiveType, data: { labels: labelsFmt, datasets: [dataset] }, options });
      try { animateChartRender('chartNegEvolucao'); } catch (e) { }
    }

    /* Unified indicators chart (NPS, SLA, Av Negativa, PercepÃ§Ã£o CS) */
    function createChartIndicadores() {
      const canvas = document.getElementById('chartIndicadores');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (chartIndicadores) chartIndicadores.destroy();

      const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
      let base = baseAll || [];
      if (selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));

      const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
      const isTv = document.body && document.body.classList && document.body.classList.contains('tv-mode');
      const titleEl = document.getElementById('indicadorTitle');
      if (isTv && titleEl) titleEl.textContent = 'SLA / CS / NPS';

      let meses = [];
      let series = [];
      let labelsFmt = [];
      let labelText = '';
      let yMax = null;
      let yScaleMax = null;
      let tooltipPrefix = '';
      let tooltipSuffix = '';
      let invertColors = false; // for negatives

      if (isTv) {
        // TV mode: overlay SLA, CS, NPS together on 0-100 scale
        const months = Array.from(new Set((base || []).map(c => c.dataFmt).filter(Boolean))).sort();
        const labels = months.map(formatMesAno);
        // Build maps for averages
        const mapNps = {}, mapCs = {}, mapSla = {};
        (base || []).forEach(cli => {
          if (!cli.dataFmt) return;
          // NPS
          if (!isNaN(Number(cli.nps))) { if (!mapNps[cli.dataFmt]) mapNps[cli.dataFmt] = []; mapNps[cli.dataFmt].push(Number(cli.nps)); }
          // CS
          if (!isNaN(Number(cli.cs))) { if (!mapCs[cli.dataFmt]) mapCs[cli.dataFmt] = []; mapCs[cli.dataFmt].push(Number(cli.cs)); }
          // SLA
          const t1 = Number(cli.sla1ok) || 0, f1 = Number(cli.sla1off) || 0, t2 = Number(cli.sla2ok) || 0, f2 = Number(cli.sla2off) || 0;
          const p1 = (t1 + f1) > 0 ? (t1 / (t1 + f1)) : null;
          const p2 = (t2 + f2) > 0 ? (t2 / (t2 + f2)) : null;
          const pct = (p1 != null && p2 != null) ? Math.round(((p1 + p2) / 2) * 100) : (p1 != null ? Math.round(p1 * 100) : (p2 != null ? Math.round(p2 * 100) : null));
          if (pct != null) { if (!mapSla[cli.dataFmt]) mapSla[cli.dataFmt] = []; mapSla[cli.dataFmt].push(pct); }
        });
        const seriesNps = months.map(m => {
          const arr = mapNps[m] || []; const avg10 = arr.length ? Math.round(arr.reduce((a, b) => a + b, 0) / arr.length) : 0; return avg10 * 10; // scale to 0-100
        });
        const seriesCs = months.map(m => {
          const arr = mapCs[m] || []; const avg10 = arr.length ? Math.round(arr.reduce((a, b) => a + b, 0) / arr.length) : 0; return avg10 * 10; // scale to 0-100
        });
        const seriesSla = months.map(m => {
          const arr = mapSla[m] || []; return arr.length ? Math.round(arr.reduce((a, b) => a + b, 0) / arr.length) : 0;
        });
        const datasets = [
          { label: 'SLA', data: seriesSla, fill: false, borderColor: upColor, backgroundColor: 'rgba(0,159,66,0.12)', borderWidth: 3, pointRadius: 3, pointHoverRadius: 5, tension: 0.25 },
          { label: 'CS', data: seriesCs, fill: false, borderColor: '#ffc900', backgroundColor: 'rgba(255,201,0,0.12)', borderWidth: 3, pointRadius: 3, pointHoverRadius: 5, tension: 0.25 },
          { label: 'NPS', data: seriesNps, fill: false, borderColor: neutralColor, backgroundColor: 'rgba(11,99,183,0.12)', borderWidth: 3, pointRadius: 3, pointHoverRadius: 5, tension: 0.25 }
        ];
        const options = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: true }, tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y ?? 0}%` } } }, scales: { y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, callback: v => v + '%' } } } };
        chartIndicadores = new Chart(ctx, { type: 'line', data: { labels, datasets }, options });
        try { animateChartRender('chartIndicadores'); } catch (e) { }
        return;
      }

      if (indicadorAtual === 'nps') {
        const mesesMap = {};
        (base || []).forEach(cli => { if (cli.dataFmt && !isNaN(Number(cli.nps))) { if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = []; mesesMap[cli.dataFmt].push(Number(cli.nps)); } });
        meses = Object.keys(mesesMap).sort();
        series = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
        labelsFmt = meses.map(formatMesAno);
        labelText = 'NPS MÃ©dio';
        yScaleMax = 10;
        tooltipPrefix = 'NPS: ';
      } else if (indicadorAtual === 'cs') {
        const mesesMap = {};
        (base || []).forEach(cli => { if (cli.dataFmt && !isNaN(Number(cli.cs))) { if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = []; mesesMap[cli.dataFmt].push(Number(cli.cs)); } });
        meses = Object.keys(mesesMap).sort();
        series = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
        labelsFmt = meses.map(formatMesAno);
        labelText = 'CS MÃ©dio';
        yScaleMax = 10;
        tooltipPrefix = 'CS: ';
      } else if (indicadorAtual === 'sla') {
        const mesesMap = {};
        (base || []).forEach(cli => {
          if (!cli.dataFmt) return;
          const t1 = Number(cli.sla1ok) || 0, f1 = Number(cli.sla1off) || 0, t2 = Number(cli.sla2ok) || 0, f2 = Number(cli.sla2off) || 0;
          const p1 = (t1 + f1) > 0 ? (t1 / (t1 + f1)) : null;
          const p2 = (t2 + f2) > 0 ? (t2 / (t2 + f2)) : null;
          const pct = (p1 != null && p2 != null) ? Math.round(((p1 + p2) / 2) * 100) : (p1 != null ? Math.round(p1 * 100) : (p2 != null ? Math.round(p2 * 100) : null));
          if (pct == null) return;
          if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
          mesesMap[cli.dataFmt].push(pct);
        });
        meses = Object.keys(mesesMap).sort();
        series = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
        labelsFmt = meses.map(formatMesAno);
        labelText = 'SLA (%)';
        yScaleMax = 100;
        tooltipPrefix = 'SLA: ';
        tooltipSuffix = '%';
      } else if (indicadorAtual === 'chs') {
        const mesesMap = {};
        (base || []).forEach(cli => { if (cli.dataFmt && !isNaN(Number(cli.chs))) { if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = []; mesesMap[cli.dataFmt].push(Number(cli.chs)); } });
        meses = Object.keys(mesesMap).sort();
        series = meses.map(m => Math.round(mesesMap[m].reduce((a, b) => a + b, 0) / mesesMap[m].length));
        labelsFmt = meses.map(formatMesAno);
        labelText = 'CHS MÃ©dio';
        yScaleMax = 100;
        tooltipPrefix = 'CHS: ';
      } else { // 'neg' (Av Negativa)
        const mesesMap = {};
        (base || []).forEach(cli => {
          if (!cli.dataFmt) return;
          let raw = (cli.neg !== undefined ? cli.neg : null);
          if (raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.negativas !== undefined ? cli.negativas : raw);
          if (raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.avNeg !== undefined ? cli.avNeg : raw);
          if (raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.av_neg !== undefined ? cli.av_neg : raw);
          if (raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.avNegFresh !== undefined ? cli.avNegFresh : raw);
          let val = null;
          if (raw !== null && raw !== undefined) {
            const s = String(raw).replace(',', '.').replace(/[^0-9.\-]/g, '');
            const n = parseFloat(s);
            if (!isNaN(n)) val = n;
          }
          if (val === null) return;
          if (!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
          mesesMap[cli.dataFmt].push(val);
        });
        meses = Object.keys(mesesMap).sort();
        series = meses.map(m => mesesMap[m].reduce((a, b) => a + b, 0));
        labelsFmt = meses.map(formatMesAno);
        labelText = 'AvaliaÃ§Ãµes Negativas (Qtd)';
        const maxVal = series.reduce((m, v) => Math.max(m, v || 0), 0);
        yScaleMax = Math.max(5, Math.ceil(maxVal * 1.4));
        tooltipPrefix = 'Negativas: ';
        invertColors = true;
      }

      const diffs = series.map((v, i) => i === 0 ? 0 : v - series[i - 1]);
      const pointBg = diffs.map(d => invertColors ? (d > 0 ? downColor : (d < 0 ? upColor : neutralColor)) : (d > 0 ? upColor : (d < 0 ? downColor : neutralColor)));

      const dataset = {
        label: labelText,
        data: series,
        fill: true,
        backgroundColor: cyanFill,
        borderColor: neutralColor,
        pointBackgroundColor: pointBg,
        pointBorderColor: '#fff',
        pointBorderWidth: 2,
        pointRadius: 4,
        pointHoverRadius: 6,
        borderWidth: 3,
        segment: { borderColor: ctx => { const dy = ctx.p1.parsed.y - ctx.p0.parsed.y; const up = invertColors ? downColor : upColor; const down = invertColors ? upColor : downColor; return dy > 0 ? up : (dy < 0 ? down : neutralColor); } }
      };

      const tooltipLabel = (context) => {
        const i = context.dataIndex; const val = context.parsed.y; if (i === 0) return `${tooltipPrefix}${val}${tooltipSuffix}`;
        const prevCal = previousMonthString(meses[i]); if (meses[i - 1] !== prevCal) return `${tooltipPrefix}${val}${tooltipSuffix}`;
        const d = val - series[i - 1]; const arrow = d > 0 ? 'â–²' : (d < 0 ? 'â–¼' : 'â€”'); const signVal = d > 0 ? `+${d}` : `${d}`; return `${tooltipPrefix}${val}${tooltipSuffix}  (${arrow} ${signVal} vs mÃªs anterior)`;
      };

      const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: true }, tooltip: { callbacks: { label: tooltipLabel } } },
        scales: { y: { beginAtZero: true, max: yScaleMax } }
      };

      chartIndicadores = new Chart(ctx, { type: 'line', data: { labels: labelsFmt, datasets: [dataset] }, options });
      try { animateChartRender('chartIndicadores'); } catch (e) { }
    }

    function toggleIndicatorFiltersMenu() {
      const menu = document.getElementById('indicatorFiltersMenu');
      if (!menu) return;
      const isOpen = menu.style.display === 'block';
      menu.style.display = isOpen ? 'none' : 'block';
      menu.setAttribute('aria-hidden', isOpen ? 'true' : 'false');
    }
    function closeIndicatorFiltersMenu() {
      const menu = document.getElementById('indicatorFiltersMenu');
      if (menu) { menu.style.display = 'none'; menu.setAttribute('aria-hidden', 'true'); }
    }
    function applyIndicatorFilter(kind) {
      indicadorAtual = kind;
      const title = document.getElementById('indicadorTitle');
      if (title) {
        if (kind === 'nps') title.textContent = 'EvoluÃ§Ã£o NPS (por MÃªs)';
        else if (kind === 'sla') title.textContent = 'EvoluÃ§Ã£o SLA (%) por MÃªs';
        else if (kind === 'neg') title.textContent = 'EvoluÃ§Ã£o AvaliaÃ§Ã£o Negativa (por MÃªs)';
        else if (kind === 'cs') title.textContent = 'EvoluÃ§Ã£o PercepÃ§Ã£o CS (por MÃªs)';
        else if (kind === 'chs') title.textContent = 'EvoluÃ§Ã£o CHS (por MÃªs)';
      }
      createChartIndicadores();
      closeIndicatorFiltersMenu();
    }

    /* Rankings helper functions */
    function renderRankingPiores() {
      const view = getViewList();
      let piores = [...view].sort((a, b) => a.chs - b.chs).slice(0, 5);
      let list = document.getElementById('rankingPioresList'); if (list) list.innerHTML = '';
      piores.forEach((cli, i) => {
        let li = document.createElement('li');
        li.onclick = () => abrirClienteModal(cli.nome);
        const statusObj = getStatusCHS(cli.chs);
        // Adicionar classe de status para degradÃª colorido na barra
        li.classList.add('status-' + statusObj.cls);
        let grad;
        if (statusObj.cls === 'saude') grad = greenGradientForCHS(cli.chs);
        else if (statusObj.cls === 'atencao') grad = yellowGradientForCHS(cli.chs);
        else grad = redGradientForCHS(cli.chs);
        const rankColor = statusObj.cor || '#e53935';
        const medal = (i === 0 ? ' gold' : (i === 1 ? ' silver' : (i === 2 ? ' bronze' : '')));
        const meterW = Math.max(0, Math.min(Number(cli.chs) || 0, 100));
        li.innerHTML = `<div class="perf-meter" style="width:${meterW}%;"></div><span class="rank${medal}" style="color:${rankColor};border-color:${rankColor};background:var(--tryvia-white);">${i + 1}</span><span class="client" title="${escapeHtml(cli.nome)}">${escapeHtml(cli.nome)}</span><span class="score" style="background:${grad};color:#fff;">${cli.chs}</span>`;
        if (list) list.appendChild(li);
      });
    }
    function renderRankingMelhores() {
      const view = getViewList();
      let melhores = [...view].sort((a, b) => b.chs - a.chs).slice(0, 5);
      let list = document.getElementById('rankingMelhoresList'); if (list) list.innerHTML = '';
      melhores.forEach((cli, i) => {
        let li = document.createElement('li');
        li.onclick = () => abrirClienteModal(cli.nome);
        const statusObj = getStatusCHS(cli.chs);
        // Adicionar classe de status para degradÃª colorido na barra
        li.classList.add('status-' + statusObj.cls);
        let grad;
        if (statusObj.cls === 'saude') grad = greenGradientForCHS(cli.chs);
        else if (statusObj.cls === 'atencao') grad = yellowGradientForCHS(cli.chs);
        else grad = redGradientForCHS(cli.chs);
        const rankColor = statusObj.cor || '#009f42';
        const medal = (i === 0 ? ' gold' : (i === 1 ? ' silver' : (i === 2 ? ' bronze' : '')));
        const meterW = Math.max(0, Math.min(Number(cli.chs) || 0, 100));
        li.innerHTML = `<div class="perf-meter" style="width:${meterW}%;"></div><span class="rank${medal}" style="color:${rankColor};border-color:${rankColor};background:var(--tryvia-white);">${i + 1}</span><span class="client" title="${escapeHtml(cli.nome)}">${escapeHtml(cli.nome)}</span><span class="score" style="background:${grad};color:#fff;">${cli.chs}</span>`;
        if (list) list.appendChild(li);
      });
    }
    function renderRankingGeral() {
      const list = document.getElementById('rankingGeralList'); if (list) list.innerHTML = '';
      const view = getViewList();

      // Enrich view items with trend diff (per cliente):
      // - Se currentMes !== 'all': usa exatamente currentMes e previousMonthString(currentMes).
      // - Se currentMes === 'all': para cada cliente, usa o Ãºltimo mÃªs disponÃ­vel desse cliente e o mÃªs anterior dele.
      const enriched = (view || []).map(item => {
        let targetMonth = null;
        let prevMonth = null;
        if (currentMes && currentMes !== 'all') {
          targetMonth = normalizeYYYYMM(currentMes);
          prevMonth = previousMonthString(targetMonth);
        } else {
          // pegar Ãºltimo mÃªs disponÃ­vel para este cliente
          const monthsForClient = Array.from(new Set((clientes || [])
            .filter(r => r.nome === item.nome && r.dataFmt)
            .map(r => normalizeYYYYMM(r.dataFmt))))
            .sort();
          const len = monthsForClient.length;
          targetMonth = len ? monthsForClient[len - 1] : null;
          // para "Todos": usar mÃªs anterior disponÃ­vel do prÃ³prio cliente, nÃ£o o anterior de calendÃ¡rio
          prevMonth = len >= 2 ? monthsForClient[len - 2] : null;
        }
        // Use the same CHS shown in the list for the target month to keep delta consistent
        const chsTarget = (currentMes && currentMes !== 'all') ? (typeof item.chs === 'number' ? item.chs : null)
          : (targetMonth ? getCHSForClientInMonth(item.nome, targetMonth) : null);
        const chsPrev = prevMonth ? getCHSForClientInMonth(item.nome, prevMonth) : null;
        let diff = null;
        if (typeof chsTarget === 'number' && typeof chsPrev === 'number') diff = Math.round(chsTarget - chsPrev);
        return Object.assign({}, item, { _trendDiff: diff, _chsTarget: chsTarget, _chsPrev: chsPrev, _targetMonth: targetMonth, _prevMonth: prevMonth });
      });

      // Apply trend filter if set
      let filtered = enriched;
      if (rankingTrendState === 'down') {
        // keep only those with diff < 0
        filtered = enriched.filter(it => typeof it._trendDiff === 'number' && it._trendDiff < 0);
      } else if (rankingTrendState === 'up') {
        filtered = enriched.filter(it => typeof it._trendDiff === 'number' && it._trendDiff > 0);
      } else {
        filtered = enriched;
      }

      // Use rankingOrderDesc to decide sort order
      // When filtering by trend, sort by trend diff instead of CHS score
      let sorted;
      if (rankingTrendState === 'down') {
        // Em Queda: ordenar pela maior queda (diff mais negativo)
        sorted = filtered.sort((a, b) => {
          const diffA = a._trendDiff || 0;
          const diffB = b._trendDiff || 0;
          return diffA - diffB; // mais negativo primeiro
        });
      } else if (rankingTrendState === 'up') {
        // Em Alta: ordenar pela maior alta (diff mais positivo)
        sorted = filtered.sort((a, b) => {
          const diffA = a._trendDiff || 0;
          const diffB = b._trendDiff || 0;
          return diffB - diffA; // mais positivo primeiro
        });
      } else {
        // Normal: ordenar por CHS
        sorted = filtered.sort((a, b) => rankingOrderDesc ? (b.chs - a.chs) : (a.chs - b.chs));
      }
      const totalItems = sorted.length;
      // If Ranking Geral is fullscreen, enforce at least 10 items per page locally
      const rgElFS = (function () { try { return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null; } catch (e) { return null; } })();
      const rgEl = (function () { try { return document.getElementById('rankingGeral'); } catch (e) { return null; } })();
      const effectivePageSize = (rgElFS && rgEl && rgElFS === rgEl) ? Math.max(10, rankingPageSize) : rankingPageSize;
      const totalPages = Math.max(1, Math.ceil(totalItems / effectivePageSize));
      if (rankingPage > totalPages) rankingPage = totalPages;
      if (rankingPage < 1) rankingPage = 1;
      const startIdx = (rankingPage - 1) * effectivePageSize;
      const pageItems = sorted.slice(startIdx, startIdx + effectivePageSize);

      pageItems.forEach((cli, idx) => {
        const globalIndex = startIdx + idx + 1;
        const li = document.createElement('li');
        li.setAttribute('data-name', cli.nome);

        const statusObj = getStatusCHS(cli.chs);
        // Adicionar classe de status para degradÃª colorido na barra
        li.classList.add('status-' + statusObj.cls);

        let grad;
        if (statusObj.cls === 'saude') grad = greenGradientForCHS(cli.chs);
        else if (statusObj.cls === 'atencao') grad = yellowGradientForCHS(cli.chs);
        else grad = redGradientForCHS(cli.chs);

        // Determine CHS delta vs previous month (suppress when filtering by "Todos")
        let deltaHtml = '';
        try {
          if (currentMes === 'all') {
            deltaHtml = '';
          } else if (typeof cli._trendDiff === 'number') {
            const diff = cli._trendDiff;
            if (diff > 0) {
              // Up: green arrow and value
              deltaHtml = `<span class=\"delta-badge delta-up\" title=\"Subiu ${diff} pontos vs ${formatMesAno(cli._prevMonth)}\">â–² ${diff}</span>`;
            } else if (diff < 0) {
              deltaHtml = `<span class=\"delta-badge delta-down\" title=\"Desceu ${Math.abs(diff)} pontos vs ${formatMesAno(cli._prevMonth)}\">â–¼ ${Math.abs(diff)}</span>`;
            } else {
              deltaHtml = `<span class=\"delta-badge delta-neutral\" title=\"Sem variaÃ§Ã£o vs ${formatMesAno(cli._prevMonth)}\">â€” 0</span>`;
            }
          } else {
            deltaHtml = '';
          }
        } catch (e) { deltaHtml = ''; }

        const rankStyle = `background:var(--tryvia-white);color:${statusObj.cor};border-color:${statusObj.cor};`;
        const scoreStyle = `background: ${grad}; color:#fff;`;
        const medal = (globalIndex === 1 ? ' gold' : (globalIndex === 2 ? ' silver' : (globalIndex === 3 ? ' bronze' : '')));
        const meterW = Math.max(0, Math.min(Number(cli.chs) || 0, 100));
        li.innerHTML = `<div class="perf-meter" style="width:${meterW}%;"></div><span class="rank${medal}" style="${rankStyle}">${globalIndex}</span><span class="client" title="${escapeHtml(cli.nome)}">${escapeHtml(cli.nome)}${deltaHtml}</span><span class="score score-gold" style="${scoreStyle}">${cli.chs}</span>`;
        li.addEventListener('click', function (ev) { abrirClienteModal(cli.nome); ev.stopPropagation(); });
        const clientSpan = li.querySelector('.client');
        if (clientSpan) clientSpan.addEventListener('click', function (ev) { ev.stopPropagation(); abrirClienteModal(cli.nome); });
        if (list) list.appendChild(li);
      });
      const prevArrow = document.getElementById('rankingPrevArrow');
      const nextArrow = document.getElementById('rankingNextArrow');
      if (prevArrow) prevArrow.disabled = (rankingPage <= 1);
      if (nextArrow) nextArrow.disabled = (rankingPage >= totalPages);
      if (totalItems === 0) {
        if (list) list.innerHTML = '<li style="justify-content:center;background:transparent;border:none;color:var(--tryvia-dark2);font-weight:600;">Nenhum cliente importado.</li>';
        if (prevArrow) prevArrow.disabled = true;
        if (nextArrow) nextArrow.disabled = true;
      }
    }

    /* New: toggleRankingOrder flips rankingOrderDesc and updates button text/icon and re-renders */
    function toggleRankingOrder() {
      rankingOrderDesc = !rankingOrderDesc;
      const btn = document.getElementById('rankingOrderBtn');
      if (btn) {
        btn.textContent = rankingOrderDesc ? 'â¬‡ï¸' : 'â¬†ï¸';
        btn.title = rankingOrderDesc ? 'OrdenaÃ§Ã£o: maiores primeiro (clique para inverter)' : 'OrdenaÃ§Ã£o: menores primeiro (clique para inverter)';
      }
      rankingPage = 1;
      renderRankingGeral();
    }

    /* New: toggleRankingTrend cycles through 'all' -> 'down' -> 'up' -> 'all' and updates button symbol/title */
    function toggleRankingTrend() {
      const btn = document.getElementById('rankingTrendBtn');
      if (!btn) return;
      if (rankingTrendState === 'all') {
        rankingTrendState = 'down';
        btn.textContent = 'â†“';
        btn.title = 'Mostrar apenas Em Queda (descendo vs mÃªs anterior)';
      } else if (rankingTrendState === 'down') {
        rankingTrendState = 'up';
        btn.textContent = 'â†‘';
        btn.title = 'Mostrar apenas Em Alta (subindo vs mÃªs anterior)';
      } else {
        rankingTrendState = 'all';
        btn.textContent = 'â†•';
        btn.title = 'Filtro tendÃªncia: Todos (reset)';
      }
      rankingPage = 1;
      renderRankingGeral();
    }

    /* New: unified filters menu for Ranking Geral */
    function toggleRankingFiltersMenu() {
      const menu = document.getElementById('rankingFiltersMenu');
      if (!menu) return;
      const isOpen = menu.style.display === 'block';
      menu.style.display = isOpen ? 'none' : 'block';
      menu.setAttribute('aria-hidden', isOpen ? 'true' : 'false');
    }
    function closeRankingFiltersMenu() {
      const menu = document.getElementById('rankingFiltersMenu');
      if (menu) { menu.style.display = 'none'; menu.setAttribute('aria-hidden', 'true'); }
    }
    function applyRankingFilter(type) {
      if (type === 'up') {
        rankingTrendState = 'up';
      } else if (type === 'down') {
        rankingTrendState = 'down';
      } else if (type === 'asc') {
        rankingOrderDesc = false; // crescente
        rankingTrendState = 'all'; // mostrar todos os clientes
      } else if (type === 'desc') {
        rankingOrderDesc = true; // decrescente
        rankingTrendState = 'all'; // mostrar todos os clientes
      }
      rankingPage = 1;
      renderRankingGeral();
      closeRankingFiltersMenu();
    }

    /* Client modal and other helpers */
    /* IMPORTANT: ensure modal aggregation for mes === 'all' uses the SAME aggregation method as the main view.
       Main view (when mes === 'all') uses aggregateByName(...) which computes chs as the mean of per-record chs.
       The modal will now return the same aggregated values when mes === 'all', so both show the same number.
       Additionally: when gestor/celular/agente missing, we try to reuse values from previous month, then next, then any.
    */
    function parseYYYYMM(ym) {
      if (!ym) return null;
      const parts = ym.split('-');
      if (parts.length < 2) return null;
      const y = parseInt(parts[0], 10);
      const m = parseInt(parts[1], 10);
      if (isNaN(y) || isNaN(m)) return null;
      return { y, m, num: y * 12 + m };
    }

    function findNearestRowWithGestor(rowsAll, targetMes) {
      if (!rowsAll || !rowsAll.length) return null;
      // prefer previous month rows with any of gestor/celular/agente; then next month; then any with any
      const withAny = rowsAll.filter(r => (r.gestor && r.gestor.toString().trim()) || (r.celular && r.celular.toString().trim()) || (r.agente && r.agente.toString().trim()));
      if (!withAny.length) return null;

      if (!targetMes) {
        // no specific month target -> prefer latest row with any
        const sorted = withAny.slice().filter(r => r.dataFmt).sort((a, b) => {
          const pa = parseYYYYMM(a.dataFmt), pb = parseYYYYMM(b.dataFmt);
          return (pb && pb.num || 0) - (pa && pa.num || 0);
        });
        return sorted.length ? sorted[0] : withAny[0];
      }
      const target = parseYYYYMM(targetMes);
      if (!target) {
        const any = withAny.slice().reverse().find(r => (r.gestor && r.gestor.toString().trim()) || (r.celular && r.celular.toString().trim()) || (r.agente && r.agente.toString().trim()));
        return any || null;
      }
      const candidates = withAny.map(r => {
        const parsed = parseYYYYMM(r.dataFmt || '');
        return { row: r, num: parsed ? parsed.num : null };
      });

      // previous: those with num < target.num, pick max num
      const prev = candidates.filter(c => c.num !== null && c.num < target.num).sort((a, b) => b.num - a.num);
      if (prev.length) return prev[0].row;
      // next: those with num > target.num, pick min num
      const next = candidates.filter(c => c.num !== null && c.num > target.num).sort((a, b) => a.num - b.num);
      if (next.length) return next[0].row;
      // fallback: any with data
      return candidates.length ? candidates[0].row : null;
    }

    function getAggregatedClientDataByNameAndMonth(name, mes) {
      const rowsAll = (clientes || []).filter(c => c.nome === name);
      if (!rowsAll.length) return null;
      // If asking for a specific month, aggregate only those rows (and if none for that month, fallback to all)
      if (mes && mes !== 'all') {
        let rows = rowsAll.filter(r => r.dataFmt === mes);
        if (rows.length === 0) rows = rowsAll;
        const cnt = rows.length;
        const agg = {
          nome: name,
          cs: Math.round(rows.reduce((s, r) => s + (isNaN(Number(r.cs)) ? 0 : Number(r.cs)), 0) / cnt),
          nps: Math.round(rows.reduce((s, r) => s + (isNaN(Number(r.nps)) ? 0 : Number(r.nps)), 0) / cnt),
          neg: Math.round(rows.reduce((s, r) => s + (isNaN(Number(r.neg)) ? 0 : Number(r.neg)), 0) / cnt),
          sla1ok: Math.round(rows.reduce((s, r) => s + (isNaN(Number(r.sla1ok)) ? 0 : Number(r.sla1ok)), 0) / cnt),
          sla1off: Math.round(rows.reduce((s, r) => s + (isNaN(Number(r.sla1off)) ? 0 : Number(r.sla1off)), 0) / cnt),
          sla2ok: Math.round(rows.reduce((s, r) => s + (isNaN(Number(r.sla2ok)) ? 0 : Number(r.sla2ok)), 0) / cnt),
          sla2off: Math.round(rows.reduce((s, r) => s + (isNaN(Number(r.sla2off)) ? 0 : Number(r.sla2off)), 0) / cnt),
          gestor: rows[0].gestor || '',
          celular: rows[0].celular || '',
          agente: rows[0].agente || ''
        };
        // If gestor/celular/agente missing, try to find nearest month with any of those fields and reuse
        if ((!agg.gestor || !agg.gestor.toString().trim()) || (!agg.celular || !agg.celular.toString().trim()) || (!agg.agente || !agg.agente.toString().trim())) {
          const nearest = findNearestRowWithGestor(rowsAll, mes);
          if (nearest) {
            agg.gestor = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : (nearest.gestor || agg.gestor);
            agg.celular = agg.celular && agg.celular.toString().trim() ? agg.celular : (nearest.celular || agg.celular);
            agg.agente = agg.agente && agg.agente.toString().trim() ? agg.agente : (nearest.agente || agg.agente);
          }
        }
        // For modal consistency with rankings in month view, use mean of per-record CHS for the selected month
        const chsMean = Math.round(rows.reduce((s, r) => s + (Number(r.chs) || 0), 0) / cnt);
        agg.chs = Math.max(0, Math.min(100, chsMean));
        return agg;
      } else {
        // mes === 'all' -> use same aggregation as main page (mean of per-record chs)
        const aggList = aggregateByName(rowsAll || []);
        const found = aggList.find(a => a.nome === name);
        if (found) {
          // If gestor/celular/agente missing in aggregated found, try to pick latest available from rowsAll
          if ((!found.gestor || !found.gestor.toString().trim()) || (!found.celular || !found.celular.toString().trim()) || (!found.agente || !found.agente.toString().trim())) {
            const nearest = findNearestRowWithGestor(rowsAll, null);
            if (nearest) {
              found.gestor = found.gestor && found.gestor.toString().trim() ? found.gestor : (nearest.gestor || found.gestor);
              found.celular = found.celular && found.celular.toString().trim() ? found.celular : (nearest.celular || found.celular);
              found.agente = found.agente && found.agente.toString().trim() ? found.agente : (nearest.agente || found.agente);
            }
          }
          return found;
        }
        // fallback: compute averages similarly
        const cnt = rowsAll.length;
        const agg = {
          nome: name,
          cs: Math.round(rowsAll.reduce((s, r) => s + (isNaN(Number(r.cs)) ? 0 : Number(r.cs)), 0) / cnt),
          nps: Math.round(rowsAll.reduce((s, r) => s + (isNaN(Number(r.nps)) ? 0 : Number(r.nps)), 0) / cnt),
          neg: Math.round(rowsAll.reduce((s, r) => s + (isNaN(Number(r.neg)) ? 0 : Number(r.neg)), 0) / cnt),
          sla1ok: Math.round(rowsAll.reduce((s, r) => s + (isNaN(Number(r.sla1ok)) ? 0 : Number(r.sla1ok)), 0) / cnt),
          sla1off: Math.round(rowsAll.reduce((s, r) => s + (isNaN(Number(r.sla1off)) ? 0 : Number(r.sla1off)), 0) / cnt),
          sla2ok: Math.round(rowsAll.reduce((s, r) => s + (isNaN(Number(r.sla2ok)) ? 0 : Number(r.sla2ok)), 0) / cnt),
          sla2off: Math.round(rowsAll.reduce((s, r) => s + (isNaN(Number(r.sla2off)) ? 0 : Number(r.sla2off)), 0) / cnt),
          gestor: rowsAll[0].gestor || '',
          celular: rowsAll[0].celular || '',
          agente: rowsAll[0].agente || ''
        };
        // Try fallback nearest if fields missing
        if ((!agg.gestor || !agg.gestor.toString().trim()) || (!agg.celular || !agg.celular.toString().trim()) || (!agg.agente || !agg.agente.toString().trim())) {
          const nearest = findNearestRowWithGestor(rowsAll, null);
          if (nearest) {
            agg.gestor = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : (nearest.gestor || agg.gestor);
            agg.celular = agg.celular && agg.celular.toString().trim() ? agg.celular : (nearest.celular || agg.celular);
            agg.agente = agg.agente && agg.agente.toString().trim() ? agg.agente : (nearest.agente || agg.agente);
          }
        }
        // To make it consistent with main dashboard aggregated chs, compute chs as mean of per-record chs
        agg.chs = Math.round(rowsAll.reduce((s, r) => s + (Number(r.chs) || 0), 0) / cnt);
        return agg;
      }
    }

    function abrirClienteModal(nomeCliente) {
      const modal = document.getElementById('clienteModal');
      const rows = (clientes || []).filter(c => c.nome === nomeCliente);
      const meses = Array.from(new Set(rows.map(r => r.dataFmt).filter(Boolean))).sort();
      let mesOptions = `<option value="all">Todos</option>`;
      meses.forEach(m => mesOptions += `<option value="${m}">${formatMesAno(m)}</option>`);

      modal.innerHTML = `
    <div class="cliente-modal-box" role="dialog" aria-modal="true">
      <button class="close-modal" onclick="fecharClienteModal()">Ã—</button>
      <div class="cliente-modal-header">
        <div style="display:flex;align-items:center;gap:10px;">
          <h2 style="color:var(--tryvia-cyan);margin:0;">${escapeHtml(nomeCliente)}</h2>
          <div class="date-field" style="margin-left:6px;">
            <i class="fas fa-calendar calendar-icon"></i>
            <select id="clientModalMesSelect" class="client-modal-mes" onchange="updateClienteModal('${escapeHtml(nomeCliente)}', this.value)">${mesOptions}</select>
          </div>
        </div>
        
      </div>

      <div class="cliente-modal-body" style="display:flex;gap:12px;align-items:flex-start;">
        <div class="cliente-modal-left" style="flex:1;min-width:220px;">
          <div id="clienteStatusLargeContainer" style="margin:0 0 8px 0;"></div>
          <div class="cliente-notas" id="clienteNotasArea" style="display:flex;gap:.6rem;justify-content:space-between;margin:.8rem 0 .8rem 0;flex-wrap:wrap;">
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">SLA</div>
              <div id="notaSLA" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipSLA">--</div>
            </div>
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">NPS</div>
              <div id="notaNPS" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipNPS">--</div>
            </div>
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">NEG</div>
              <div id="notaNEG" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipNEG">--</div>
            </div>
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">CS</div>
              <div id="notaCS" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipCS">--</div>
            </div>
          </div>

          <div class="cliente-dados-gestor" id="clienteDadosGestor" style="margin-top:0.8rem;padding:.8rem;border-radius:10px;font-size:0.95rem;background:var(--tryvia-cyan-bg);border:2px solid var(--tryvia-cyan);"></div>
          <div id="planoAcaoBtnWrap" class="plano-acao-trigger"></div>

        </div>

        <div class="cliente-modal-right" style="flex:1;min-width:220px;display:flex;flex-direction:column;gap:8px;">
          <h4 style="color:var(--tryvia-cyan);margin:0 0 6px 0;">GrÃ¡ficos</h4>
          <div style="background:var(--tryvia-white);border-radius:8px;padding:6px;border:1px solid var(--tryvia-border);box-shadow:var(--tryvia-card-shadow);">
            <div class="chart-title"><span class="dot"></span> CHS do Cliente</div>
            <canvas id="clienteChartDonut" style="width:100%;height:160px;"></canvas>
          </div>
          <div style="margin-top:6px;background:var(--tryvia-white);border-radius:8px;padding:6px;border:1px solid var(--tryvia-border);box-shadow:var(--tryvia-card-shadow);">
            <div class="chart-title"><span class="dot"></span> PontuaÃ§Ãµes por critÃ©rio</div>
            <canvas id="clienteChartComp" style="width:100%;height:160px;"></canvas>
          </div>
        </div>
      </div>
    </div>
  `;
      // Use class-based transitions for smooth open without flicker
      modal.setAttribute('aria-hidden', 'false');
      lockBodyScroll();
      modal.classList.remove('modal-closing');

      // Force reflow before adding modal-open class for smooth animation
      void modal.offsetWidth;
      modal.classList.add('modal-open');

      const select = document.getElementById('clientModalMesSelect');
      const availableMeses = meses || [];
      const defaultMonth = (currentMes && currentMes !== 'all' && availableMeses.includes(currentMes)) ? currentMes : 'all';
      if (select) { select.value = defaultMonth; }

      // Wait for transition to complete before rendering charts
      setTimeout(function () {
        try {
          updateClienteModal(nomeCliente, (select && select.value) ? select.value : defaultMonth);
          const top = modal.querySelector('.cliente-modal-box'); if (top) top.scrollTop = 0;
        } catch (e) { updateClienteModal(nomeCliente, 'all'); }
      }, 380);
    }

    function updateClienteModal(nomeCliente, mes) {
      const agg = getAggregatedClientDataByNameAndMonth(nomeCliente, mes);
      if (!agg) return;

      // compute component scores
      const slaScore = calcSLA(agg);
      const npsScore = calcNPS(agg, agg.nps);
      const negScore = calcNeg(agg);
      const csScore = calcCS(agg, agg.cs);

      // Display "score / max" beside each indicator as requested
      const notaSLAEl = document.getElementById('notaSLA');
      const notaNPSEl = document.getElementById('notaNPS');
      const notaNEGEl = document.getElementById('notaNEG');
      const notaCSEl = document.getElementById('notaCS');

      if (notaSLAEl) notaSLAEl.textContent = `${slaScore}/${MAX_SLA}`;
      if (notaNPSEl) notaNPSEl.textContent = `${npsScore}/${MAX_NPS}`;
      if (notaNEGEl) notaNEGEl.textContent = `${negScore}/${MAX_NEG}`;
      if (notaCSEl) notaCSEl.textContent = `${csScore}/${MAX_CS}`;

      // Build tooltip texts showing raw/unweighted values and description, expanded and more descriptive for clarity.
      try {
        // SLA raw percent calculation (more detailed info)
        let slaTooltipText = 'SLA: sem registros suficientes';
        try {
          const s1ok = Number(agg.sla1ok), s1off = Number(agg.sla1off), s2ok = Number(agg.sla2ok), s2off = Number(agg.sla2off);
          let pct1 = (s1ok + s1off) > 0 ? (s1ok / (s1ok + s1off)) : null;
          let pct2 = (s2ok + s2off) > 0 ? (s2ok / (s2ok + s2off)) : null;
          let avgPct = null;
          if (pct1 === null && pct2 === null) avgPct = null;
          else if (pct1 === null) avgPct = pct2;
          else if (pct2 === null) avgPct = pct1;
          else avgPct = (pct1 + pct2) / 2;
          if (avgPct === null) slaTooltipText = 'SLA: sem registros suficientes para calcular percentual.';
          else {
            const pct1txt = pct1 === null ? 'â€”' : ((pct1 * 100).toFixed(1) + '%');
            const pct2txt = pct2 === null ? 'â€”' : ((pct2 * 100).toFixed(1) + '%');
            slaTooltipText = `SLA: ${(avgPct * 100).toFixed(1)}% (mÃ©dia entre 1Âª resposta e resoluÃ§Ã£o) â€” Detalhes: 1Âª resposta ${pct1txt}, resoluÃ§Ã£o ${pct2txt} â€” Nota Final: ${slaScore}/${MAX_SLA} (apos penalizaÃ§Ãµes)`;
            // Note: we build a single line description separated by " â€” " to favor horizontal layout.
          }
        } catch (e) { slaTooltipText = 'SLA: erro ao calcular detalhes.'; }

        const npsTooltip = (agg.nps === null || agg.nps === undefined || isNaN(Number(agg.nps))) ? `NPS: sem registros â€” PontuaÃ§Ã£o: ${npsScore}/${MAX_NPS}` : `NPS: ${Number(agg.nps).toFixed(1)}  â€” Nota Final: ${npsScore}/${MAX_NPS} (Ã¡pos penalizaÃ§Ãµes)`;
        const negTooltip = (agg.neg === null || agg.neg === undefined || isNaN(Number(agg.neg))) ? `Negativas: sem registros â€” PontuaÃ§Ã£o: ${negScore}/${MAX_NEG}` : `AvaliaÃ§Ãµes Negativas Detectadas: ${Number(agg.neg).toFixed(1)} â€” Nota Final: ${negScore}/${MAX_NEG} (apÃ³s penalizaÃ§Ãµes)`;
        const csTooltip = (agg.cs === null || agg.cs === undefined || isNaN(Number(agg.cs))) ? `CS: sem registros â€” PontuaÃ§Ã£o: ${csScore}/${MAX_CS}` : `PercepÃ§Ã£o CS: ${Number(agg.cs).toFixed(1)} â€” Nota Final: ${csScore}/${MAX_CS} (apÃ³s penalizaÃ§Ãµes)`;

        const tSLA = document.getElementById('tooltipSLA');
        const tNPS = document.getElementById('tooltipNPS');
        const tNEG = document.getElementById('tooltipNEG');
        const tCS = document.getElementById('tooltipCS');
        if (tSLA) tSLA.textContent = slaTooltipText;
        if (tNPS) tNPS.textContent = npsTooltip;
        if (tNEG) tNEG.textContent = negTooltip;
        if (tCS) tCS.textContent = csTooltip;
      } catch (e) { }

      // Instead of showing "Registros", now show "Agente" value (from column Agente) in the client modal
      // Use fallback logic: agg.agente should already have been filled by nearest-month logic if missing
      const agenteText = agg.agente && agg.agente.toString().trim() ? agg.agente : 'NÃ£o informado';
      const gestorText = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : 'NÃ£o informado';
      const celularText = agg.celular && agg.celular.toString().trim() ? agg.celular : 'NÃ£o informado';

      document.getElementById('clienteDadosGestor').innerHTML = `<strong>Agente:</strong> ${escapeHtml(agenteText)}<br><strong>Gestor:</strong> ${escapeHtml(gestorText)}<br><strong>Celular:</strong> ${escapeHtml(celularText)}`;

      const statusObj = getStatusCHS(agg.chs);
      const statusHtml = `<div class="status-large ${statusObj.cls}" style="display:flex;align-items:center;gap:10px;padding:10px;border-radius:12px;font-weight:800;font-size:1rem;background:${statusObj.cls === 'saude' ? 'linear-gradient(90deg,#e7faee,#d4f4dd)' : (statusObj.cls === 'atencao' ? 'linear-gradient(90deg,#fffbe7,#fff3c6)' : 'linear-gradient(90deg,#ffeaea,#ffd1d1)')};color:${statusObj.cor};border:2px solid ${statusObj.cor};"><div class="status-icon" style="font-size:1.4rem;">${statusObj.cls === 'saude' ? 'ðŸ’š' : (statusObj.cls === 'atencao' ? 'âš ï¸' : 'âŒ')}</div><div><div class="status-text">${statusObj.txt}</div><div class="status-chs">${agg.chs} pts</div></div></div>`;
      const statusContainer = document.getElementById('clienteStatusLargeContainer');
      if (statusContainer) statusContainer.innerHTML = statusHtml;

      // Show/Hide Plano de AÃ§Ã£o button: show if CHS < 70 OR cliente estÃ¡ em queda vs mÃªs anterior
      let isDownTrend = false;
      try {
        let targetMonth = null, prevMonth = null;
        if (mes && mes !== 'all') {
          targetMonth = normalizeYYYYMM(mes);
          prevMonth = previousMonthString(targetMonth);
        } else {
          const monthsForClient = Array.from(new Set((clientes || [])
            .filter(r => r.nome === nomeCliente && r.dataFmt)
            .map(r => normalizeYYYYMM(r.dataFmt)))).sort();
          const len = monthsForClient.length;
          targetMonth = len ? monthsForClient[len - 1] : null;
          prevMonth = len >= 2 ? monthsForClient[len - 2] : null;
        }
        const currVal = targetMonth ? getCHSForClientInMonth(nomeCliente, targetMonth) : null;
        const prevVal = prevMonth ? getCHSForClientInMonth(nomeCliente, prevMonth) : null;
        isDownTrend = (typeof currVal === 'number' && typeof prevVal === 'number' && currVal < prevVal);
      } catch (e) { isDownTrend = false; }

      try {
        const btnWrap = document.getElementById('planoAcaoBtnWrap');
        if (btnWrap) {
          if (isDownTrend || Number(agg.chs) < 70) {
            btnWrap.innerHTML = `<button class="btn btn-primary" id="planoAcaoBtn">Plano de AÃ§Ã£o</button>`;
            setTimeout(function () { var b = document.getElementById('planoAcaoBtn'); if (b) { b.onclick = function () { abrirPlanoAcao(nomeCliente); }; } }, 0);
          } else {
            btnWrap.innerHTML = '';
          }
        }
      } catch (e) { }

      try { if (chartClienteDonut) chartClienteDonut.destroy(); } catch (e) { }
      const donutCanvas = document.getElementById('clienteChartDonut');
      if (donutCanvas) { try { donutCanvas.width = donutCanvas.clientWidth || 320; donutCanvas.height = 180; } catch (e) { } }
      const donutCtx = donutCanvas.getContext('2d');
      const statusColor = statusObj.cor || '#00cfff';

      // Create gradient for the main segment
      const donutGradient = donutCtx.createLinearGradient(0, 0, 200, 200);
      if (statusObj.cls === 'saude') {
        donutGradient.addColorStop(0, '#00d084');
        donutGradient.addColorStop(1, '#00a86b');
      } else if (statusObj.cls === 'atencao') {
        donutGradient.addColorStop(0, '#ffc107');
        donutGradient.addColorStop(1, '#ff9800');
      } else {
        donutGradient.addColorStop(0, '#ff6b6b');
        donutGradient.addColorStop(1, '#e53935');
      }

      const donutData = {
        labels: ['CHS', 'Restante'],
        datasets: [{
          data: [Math.max(0, Math.round(agg.chs)), Math.max(0, 100 - Math.round(agg.chs))],
          backgroundColor: [donutGradient, 'rgba(0,0,0,0.04)'],
          borderColor: ['rgba(255,255,255,0.8)', 'rgba(0,0,0,0.02)'],
          borderWidth: 3,
          borderRadius: 6,
          spacing: 2
        }]
      };
      chartClienteDonut = new Chart(donutCtx, {
        type: 'doughnut',
        data: donutData,
        options: {
          devicePixelRatio: (window.devicePixelRatio || 1) * 1.5,
          responsive: false,
          maintainAspectRatio: false,
          animation: { animateRotate: true, animateScale: true, duration: 600, easing: 'easeOutQuart' },
          cutout: '72%',
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleFont: { size: 13, weight: '600' },
              bodyFont: { size: 12 },
              padding: 12,
              cornerRadius: 10,
              displayColors: false,
              callbacks: { label: function (context) { return context.label + ': ' + context.parsed + (context.label === 'CHS' ? ' pts' : ''); } }
            },
            valueLabelsAll: false,
            centerText: { enabled: true, text: String(Math.max(0, Math.round(agg.chs) || 0)), font: '800 36px Poppins, Roboto, sans-serif', color: statusColor }
          }
        }
      });

      try { if (chartClienteComp) chartClienteComp.destroy(); } catch (e) { }
      const compCanvas = document.getElementById('clienteChartComp');
      if (compCanvas) { try { compCanvas.width = compCanvas.clientWidth || 320; compCanvas.height = 180; } catch (e) { } }
      const compCtx = compCanvas.getContext('2d');

      // Create gradients for each bar
      const slaGrad = compCtx.createLinearGradient(0, 0, 200, 0);
      slaGrad.addColorStop(0, '#00d4ff'); slaGrad.addColorStop(1, '#0099cc');
      const npsGrad = compCtx.createLinearGradient(0, 0, 200, 0);
      npsGrad.addColorStop(0, '#667eea'); npsGrad.addColorStop(1, '#764ba2');
      const negGrad = compCtx.createLinearGradient(0, 0, 200, 0);
      negGrad.addColorStop(0, '#ff6b6b'); negGrad.addColorStop(1, '#ee5a5a');
      const csGrad = compCtx.createLinearGradient(0, 0, 200, 0);
      csGrad.addColorStop(0, '#00d084'); csGrad.addColorStop(1, '#00a86b');

      const compData = {
        labels: ['SLA', 'NPS', 'Negativas', 'CS'],
        datasets: [{
          label: 'PontuaÃ§Ã£o',
          data: [calcSLA(agg), calcNPS(agg, agg.nps), calcNeg(agg), calcCS(agg, agg.cs)],
          backgroundColor: [slaGrad, npsGrad, negGrad, csGrad],
          borderColor: ['rgba(0,212,255,0.3)', 'rgba(102,126,234,0.3)', 'rgba(255,107,107,0.3)', 'rgba(0,208,132,0.3)'],
          borderWidth: 0,
          barPercentage: 0.7,
          categoryPercentage: 0.85,
          maxBarThickness: 28,
          borderRadius: 8,
          borderSkipped: false
        }]
      };
      chartClienteComp = new Chart(compCtx, {
        type: 'bar',
        data: compData,
        options: {
          devicePixelRatio: (window.devicePixelRatio || 1) * 1.5,
          indexAxis: 'y',
          responsive: false,
          maintainAspectRatio: false,
          animation: { duration: 500, easing: 'easeOutQuart' },
          layout: { padding: { left: 5, right: 15 } },
          scales: {
            x: {
              beginAtZero: true,
              max: 35,
              grid: { color: 'rgba(0,0,0,0.04)', drawBorder: false },
              ticks: { stepSize: 10, font: { size: 10, weight: '500' }, color: '#888' }
            },
            y: {
              grid: { display: false, drawBorder: false },
              ticks: { font: { size: 11, weight: '600' }, color: '#555', padding: 8 }
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleFont: { size: 13, weight: '600' },
              bodyFont: { size: 12 },
              padding: 12,
              cornerRadius: 10,
              displayColors: true,
              boxPadding: 6
            }
          }
        }
      });

      try { document.getElementById('clienteChartDonut')._chart = chartClienteDonut; document.getElementById('clienteChartComp')._chart = chartClienteComp; } catch (e) { }

      // New: trend charts (% de clientes em queda / em alta)
      try { if (chartClienteTrendDown) chartClienteTrendDown.destroy(); } catch (e) { }
      try { if (chartClienteTrendUp) chartClienteTrendUp.destroy(); } catch (e) { }
      const trendDownCanvas = document.getElementById('clienteTrendDown');
      const trendUpCanvas = document.getElementById('clienteTrendUp');
      if (trendDownCanvas && trendUpCanvas) {
        try { trendDownCanvas.width = trendDownCanvas.clientWidth || 320; trendDownCanvas.height = 160; } catch (e) { }
        try { trendUpCanvas.width = trendUpCanvas.clientWidth || 320; trendUpCanvas.height = 160; } catch (e) { }
        const trendDownCtx = trendDownCanvas.getContext('2d');
        const trendUpCtx = trendUpCanvas.getContext('2d');

        const allMonths = Array.from(new Set((clientes || []).map(c => c.dataFmt).filter(Boolean))).sort();
        const allNames = Array.from(new Set((clientes || []).map(c => (c.nome || '').toString().trim()).filter(Boolean)));
        const labelsFmt = [];
        const downPercs = [];
        const upPercs = [];
        for (let i = 0; i < allMonths.length; i++) {
          const m = normalizeYYYYMM(allMonths[i]);
          labelsFmt.push(formatMesAno(m));
          const prev = previousMonthString(m);
          if (!prev) { downPercs.push(0); upPercs.push(0); continue; }
          let down = 0, up = 0;
          for (const name of allNames) {
            const prevVal = getCHSForClientInMonth(name, prev);
            const currVal = getCHSForClientInMonth(name, m);
            if (prevVal == null || currVal == null) continue;
            if (currVal < prevVal) down++; else if (currVal > prevVal) up++;
          }
          const total = allNames.length || 1;
          downPercs.push(Math.round((down / total) * 1000) / 10);
          upPercs.push(Math.round((up / total) * 1000) / 10);
        }

        chartClienteTrendDown = new Chart(trendDownCtx, {
          type: 'line',
          data: { labels: labelsFmt, datasets: [{ label: '% em queda', data: downPercs, fill: true, backgroundColor: 'rgba(229,57,53,0.12)', borderColor: '#e53935', borderWidth: 2.5, pointRadius: 3, pointHoverRadius: 5, tension: 0.25 }] },
          options: { devicePixelRatio: (window.devicePixelRatio || 1), responsive: false, maintainAspectRatio: false, animation: false, scales: { y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, callback: (v) => v + '%' } }, x: { grid: { display: false } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => (ctx.parsed.y ?? 0) + '%' } } } }
        });

        chartClienteTrendUp = new Chart(trendUpCtx, {
          type: 'line',
          data: { labels: labelsFmt, datasets: [{ label: '% em alta', data: upPercs, fill: true, backgroundColor: 'rgba(0,159,66,0.12)', borderColor: '#009f42', borderWidth: 2.5, pointRadius: 3, pointHoverRadius: 5, tension: 0.25 }] },
          options: { devicePixelRatio: (window.devicePixelRatio || 1), responsive: false, maintainAspectRatio: false, animation: false, scales: { y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, callback: (v) => v + '%' } }, x: { grid: { display: false } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => (ctx.parsed.y ?? 0) + '%' } } } }
        });
      }
    }

    function fecharClienteModal() {
      const modal = document.getElementById('clienteModal');

      // Add closing class for exit animation
      modal.classList.add('modal-closing');
      modal.classList.remove('modal-open');

      // Wait for transition to complete before hiding
      setTimeout(function () {
        modal.setAttribute('aria-hidden', 'true');
        unlockBodyScroll();
        modal.classList.remove('modal-closing');
      }, 300);

      // Destroy charts
      try { if (chartClienteDonut) chartClienteDonut.destroy(); } catch (e) { }
      try { if (chartClienteComp) chartClienteComp.destroy(); } catch (e) { }
      try { if (chartClienteTrendDown) { chartClienteTrendDown.destroy(); chartClienteTrendDown = null; } } catch (e) { }
      try { if (chartClienteTrendUp) { chartClienteTrendUp.destroy(); chartClienteTrendUp = null; } } catch (e) { }
    }

    /* Plano de AÃ§Ã£o: open/close and content builder */
    function abrirPlanoAcao(nomeCliente) {
      try {
        const sel = document.getElementById('clientModalMesSelect');
        const mes = sel ? sel.value : 'all';
        const agg = getAggregatedClientDataByNameAndMonth(nomeCliente, mes);
        if (!agg) { alert('Dados indisponÃ­veis para este cliente.'); return; }
        const gestorText = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : 'NÃ£o informado';
        const agenteText = agg.agente && agg.agente.toString().trim() ? agg.agente : 'NÃ£o informado';
        const notaGeral = Math.round(Number(agg.chs) || 0);

        // Sinalizadores simples por mÃ©trica
        const s1ok = Number(agg.sla1ok) || 0, s1off = Number(agg.sla1off) || 0, s2ok = Number(agg.sla2ok) || 0, s2off = Number(agg.sla2off) || 0;
        const s1tot = s1ok + s1off, s2tot = s2ok + s2off;
        const primeiraRespostaOK = s1tot > 0 ? (s1ok / s1tot) : null; // proporÃ§Ã£o atendida
        const resolucaoOK = s2tot > 0 ? (s2ok / s2tot) : null;        // proporÃ§Ã£o atendida
        const satisfacao = (agg.nps != null && !isNaN(Number(agg.nps))) ? Number(agg.nps) : null; // 0-10
        const avalNegativas = (agg.neg != null && !isNaN(Number(agg.neg))) ? Number(agg.neg) : null; // contagem
        const qualidade = (agg.cs != null && !isNaN(Number(agg.cs))) ? Number(agg.cs) : null; // 0-10

        // CritÃ©rios (simples e claros)
        const bomPrimeiraResp = primeiraRespostaOK !== null && primeiraRespostaOK >= 0.90;
        const bomResolucao = resolucaoOK !== null && resolucaoOK >= 0.85;
        const bomSatisfacao = satisfacao !== null && satisfacao >= 8;
        const semNegativas = avalNegativas !== null && avalNegativas === 0;
        const bomQualidade = qualidade !== null && qualidade >= 8;

        const precisaPrimeiraResp = primeiraRespostaOK !== null && primeiraRespostaOK < 0.90;
        const precisaResolucao = resolucaoOK !== null && resolucaoOK < 0.85;
        const precisaSatisfacao = satisfacao !== null && satisfacao < 8;
        const precisaNegativas = avalNegativas !== null && avalNegativas >= 1;
        const precisaQualidade = qualidade !== null && qualidade < 8;

        // Destaques positivos e pontos a melhorar
        const bons = [];
        if (bomPrimeiraResp) bons.push('Primeira resposta rÃ¡pida na maior parte dos atendimentos');
        if (bomResolucao) bons.push('ResoluÃ§Ã£o dentro do prazo na maioria dos casos');
        if (semNegativas) bons.push('Sem avaliaÃ§Ãµes negativas recentes');
        if (bomSatisfacao) bons.push('Boa satisfaÃ§Ã£o nas pesquisas (mÃ©dia 8 ou mais)');
        if (bomQualidade) bons.push('Boa qualidade do atendimento');

        const melhorar = [];
        if (precisaPrimeiraResp) melhorar.push('Tempo para dar a primeira resposta');
        if (precisaResolucao) melhorar.push('Tempo para resolver os pedidos');
        if (precisaNegativas) melhorar.push('AvaliaÃ§Ãµes negativas recentes');
        if (precisaSatisfacao) melhorar.push('SatisfaÃ§Ã£o do cliente nas pesquisas');
        if (precisaQualidade) melhorar.push('Qualidade do atendimento');

        // SeÃ§Ãµes de aÃ§Ãµes especÃ­ficas (somente para o que precisa melhorar)
        const secoes = [];
        if (precisaPrimeiraResp) {
          secoes.push({
            titulo: 'Tempo para responder a primeira mensagem',
            bullets: [
              'Definir meta clara para a primeira resposta (ex.: atÃ© 10 minutos em horÃ¡rio comercial).',
              'Usar mensagens salvas para agilizar a primeira resposta.',
              'Acompanhar diariamente os casos que ainda nÃ£o tiveram resposta inicial e agir de imediato.'
            ]
          });
        }
        if (precisaResolucao) {
          secoes.push({
            titulo: 'Tempo para resolver o pedido',
            bullets: [
              'Criar um passo a passo simples para os problemas mais comuns (com soluÃ§Ã£o e responsÃ¡vel).',
              'Remover bloqueios rapidamente: se um caso estÃ¡ parado, envolver quem pode destravar na hora.',
              'Revisar diariamente os pedidos perto do prazo e priorizar a conclusÃ£o.'
            ]
          });
        }
        if (precisaNegativas) {
          secoes.push({
            titulo: 'AvaliaÃ§Ãµes negativas',
            bullets: [
              'Entrar em contato com quem avaliou negativamente em atÃ© 2 dias para entender o motivo e combinar a soluÃ§Ã£o.',
              'Quando for pÃºblico, responder com pedido de desculpas, explicaÃ§Ã£o simples e o que serÃ¡ feito para corrigir.',
              'Toda semana, revisar com a equipe os atendimentos mal avaliados e combinar melhorias.'
            ]
          });
        }
        if (precisaSatisfacao) {
          secoes.push({
            titulo: 'SatisfaÃ§Ã£o do cliente (pesquisa)',
            bullets: [
              'Ao finalizar um atendimento, confirmar se a pessoa ficou satisfeita e qual Ã© o prÃ³ximo passo.',
              'Mapear os 3 motivos mais comuns de insatisfaÃ§Ã£o e corrigi-los com prioridade.',
              'Ajustar a linguagem: mensagens curtas, claras e com prazos objetivos.'
            ]
          });
        }
        if (precisaQualidade) {
          secoes.push({
            titulo: 'Qualidade do atendimento',
            bullets: [
              'Treinar a equipe nos cenÃ¡rios de uso mais comuns do cliente, com exemplos prÃ¡ticos.',
              'Criar um plano simples de acompanhamento com marcos e responsÃ¡veis.',
              'Fazer uma reuniÃ£o mensal de resultados com o cliente: o que melhorou e o que faremos no prÃ³ximo mÃªs.'
            ]
          });
        }

        const bonsHtml = bons.length ? `<ul>${bons.map(b => `<li>${escapeHtml(b)}</li>`).join('')}</ul>` : '<ul><li>Ainda nÃ£o temos destaques positivos claros â€” vamos construir com as aÃ§Ãµes abaixo.</li></ul>';
        const melhorarHtml = melhorar.length ? `<ul>${melhorar.map(b => `<li>${escapeHtml(b)}</li>`).join('')}</ul>` : '<ul><li>Nenhum ponto crÃ­tico detectado neste perÃ­odo â€” mantenha as boas prÃ¡ticas.</li></ul>';
        const secoesHtml = secoes.map(sec => `<h4>${escapeHtml(sec.titulo)}</h4><ul>${sec.bullets.map(b => `<li>${escapeHtml(b)}</li>`).join('')}</ul>`).join('');

        const alvos = [];
        if (precisaPrimeiraResp) alvos.push('tempo de resposta');
        if (precisaResolucao) alvos.push('tempo de resoluÃ§Ã£o');
        if (precisaSatisfacao) alvos.push('satisfaÃ§Ã£o do cliente');
        if (precisaNegativas) alvos.push('reduÃ§Ã£o de avaliaÃ§Ãµes negativas');
        if (precisaQualidade) alvos.push('qualidade do atendimento');
        const objetivoLinha = alvos.length ? `Em 30 dias, melhorar ${escapeHtml(alvos.join(', '))} e aumentar a nota geral.` : 'Em 30 dias, manter os bons resultados e a satisfaÃ§Ã£o do cliente.';

        // Motivos (somente pontos ruins, com metas claras)
        const motivos = [];
        if (precisaPrimeiraResp && primeiraRespostaOK !== null) motivos.push(`Primeira resposta no prazo ficou em ${Math.round(primeiraRespostaOK * 100)}% (meta: 90%).`);
        if (precisaResolucao && resolucaoOK !== null) motivos.push(`ResoluÃ§Ã£o no prazo ficou em ${Math.round(resolucaoOK * 100)}% (meta: 85%).`);
        if (precisaSatisfacao && satisfacao !== null) motivos.push(`SatisfaÃ§Ã£o mÃ©dia ficou em ${satisfacao.toFixed(1)} (meta: 8).`);
        if (precisaNegativas && avalNegativas !== null) motivos.push(`Foram registradas ${avalNegativas} avaliaÃ§Ãµes negativas (meta: 0).`);
        if (precisaQualidade && qualidade !== null) motivos.push(`Qualidade do atendimento ficou em ${qualidade.toFixed(1)} (meta: 8).`);

        // PDCA â€“ montar bullets conforme pontos fracos
        const pdcaPlan = [];
        if (precisaPrimeiraResp) pdcaPlan.push('Definir meta de primeira resposta (ex.: atÃ© 10 minutos em horÃ¡rio comercial).');
        if (precisaResolucao) pdcaPlan.push('Definir metas simples de prazos por tipo de pedido (fÃ¡cil, mÃ©dio, complexo).');
        if (precisaSatisfacao) pdcaPlan.push('Estabelecer padrÃ£o de encerramento: confirmar soluÃ§Ã£o e prÃ³ximo passo.');
        if (precisaNegativas) pdcaPlan.push('Criar regra de contato com avaliaÃ§Ãµes negativas em atÃ© 2 dias.');
        if (precisaQualidade) pdcaPlan.push('Planejar treinamento rÃ¡pido com exemplos prÃ¡ticos do cliente.');

        const pdcaDo = [];
        if (precisaPrimeiraResp) pdcaDo.push('Usar mensagens salvas para agilizar a primeira resposta.');
        if (precisaResolucao) pdcaDo.push('Criar passo a passo dos problemas mais comuns e definir responsÃ¡veis.');
        if (precisaSatisfacao) pdcaDo.push('Ajustar a linguagem: mensagens curtas, claras e com prazos.');
        if (precisaNegativas) pdcaDo.push('Responder avaliaÃ§Ãµes negativas com pedido de desculpas e plano de soluÃ§Ã£o.');
        if (precisaQualidade) pdcaDo.push('Realizar sessÃ£o de treinamento de 1 hora com a equipe.');

        const pdcaCheck = [
          'Acompanhar diariamente: casos sem primeira resposta e casos perto do prazo.',
          'Revisar semanalmente as avaliaÃ§Ãµes e pesquisas recebidas.',
          'Registrar o que foi feito e o resultado (planilha simples ou sistema).'
        ];

        const pdcaAct = [
          'A cada semana: manter o que funcionou e ajustar o que nÃ£o funcionou.',
          'Em 30 dias: revisar as metas e atualizar o plano para o prÃ³ximo mÃªs.'
        ];

        const pdcaHtml = `
      <div class="pdca-grid">
        <div class="pdca-card pdca-plan"><div class="pdca-head"><span class="pdca-icon">ðŸ“</span> PLAN</div><ul>${pdcaPlan.map(b => `<li>${escapeHtml(b)}</li>`).join('') || '<li>Manter boas prÃ¡ticas atuais.</li>'}</ul></div>
        <div class="pdca-card pdca-do"><div class="pdca-head"><span class="pdca-icon">â–¶ï¸</span> DO</div><ul>${pdcaDo.map(b => `<li>${escapeHtml(b)}</li>`).join('') || '<li>Executar as aÃ§Ãµes definidas no plano.</li>'}</ul></div>
        <div class="pdca-card pdca-check"><div class="pdca-head"><span class="pdca-icon">âœ…</span> CHECK</div><ul>${pdcaCheck.map(b => `<li>${escapeHtml(b)}</li>`).join('')}</ul></div>
        <div class="pdca-card pdca-act"><div class="pdca-head"><span class="pdca-icon">ðŸ”</span> ACT</div><ul>${pdcaAct.map(b => `<li>${escapeHtml(b)}</li>`).join('')}</ul></div>
      </div>`;

        const html = `
      <div class="plano-acao-box">
        <button class="plano-acao-close" onclick="fecharPlanoAcao()">Ã—</button>
        <h3>Plano de AÃ§Ã£o (PDCA) â€” ${escapeHtml(nomeCliente)} (nota geral: ${notaGeral})</h3>
        <div><strong>Gestor:</strong> ${escapeHtml(gestorText)} &nbsp; | &nbsp; <strong>Agente:</strong> ${escapeHtml(agenteText)}</div>
        <h4>Por que a nota ficou assim?</h4>
        <ul>${motivos.map(m => `<li>${escapeHtml(m)}</li>`).join('')}</ul>
        <h4>O que jÃ¡ estÃ¡ bom</h4>
        ${bonsHtml}
        <h4>Objetivo (30 dias)</h4>
        <ul><li>${objetivoLinha}</li></ul>
        ${pdcaHtml}
      </div>`;
        const overlay = document.createElement('div');
        overlay.className = 'plano-acao-overlay';
        overlay.innerHTML = html;
        document.body.appendChild(overlay);

        // Trigger animation
        setTimeout(() => {
          overlay.classList.add('show');
        }, 10);
      } catch (e) { alert('NÃ£o foi possÃ­vel abrir o plano de aÃ§Ã£o.'); }
    }

    function fecharPlanoAcao() {
      const ov = document.querySelector('.plano-acao-overlay');
      if (!ov) return;
      try {
        ov.classList.remove('show');
        setTimeout(() => {
          ov.remove();
        }, 300);
      } catch (e) { ov.remove(); }
    }
    /* Help CHS modal */
    function openHelpCHS() {
      try {
        const overlay = document.createElement('div');
        overlay.className = 'help-overlay';
        overlay.innerHTML = `
  <div class="help-box">
    <button class="help-close" onclick="closeHelpCHS()">Ã—</button>
    <div class="help-hero">
          <div class="hero-left">
            <div class="hero-title">ðŸ’¡ Entenda o CHS <span class="hero-sub">(Customer Health Score)</span></div>
            <div>O CHS Ã© uma nota de <strong>0 a 100</strong> que resume a saÃºde do relacionamento com o cliente. Ã‰ composto por 4 partes, com pesos diferentes.</div>
            <div class="pill-group">
              <span class="pill saude"><span class="dot"></span> SaudÃ¡vel â‰¥ 70</span>
              <span class="pill atencao"><span class="dot"></span> AtenÃ§Ã£o 40â€“69</span>
              <span class="pill critico"><span class="dot"></span> CrÃ­tico &lt; 40</span>
            </div>
          </div>
          <div class="hero-right">
            <canvas id="helpChsDonut" style="width:200px;height:200px;" width="200" height="200"></canvas>
            <div class="legend">
              <span class="legend-item legend-sla"><span class="dot"></span> SLA 20</span>
              <span class="legend-item legend-nps"><span class="dot"></span> NPS 30</span>
              <span class="legend-item legend-neg"><span class="dot"></span> Negativas 30</span>
              <span class="legend-item legend-cs"><span class="dot"></span> CS 20</span>
            </div>
          </div>
        </div>

        <div class="help-grid">
          <div class="help-tile">
            <div class="tile-icon">â±ï¸</div>
            <div>
              <h4>SLA (20 pts)</h4>
              <p>MÃ©dia entre <strong>1Âª resposta</strong> no prazo e <strong>resoluÃ§Ã£o</strong> no prazo. Quanto maior a % de atendimentos no prazo, maior a pontuaÃ§Ã£o.</p>
            </div>
          </div>
          <div class="help-tile">
            <div class="tile-icon">ðŸ˜Š</div>
            <div>
              <h4>NPS (30 pts)</h4>
              <p>MÃ©dia de satisfaÃ§Ã£o de <strong>0 a 10</strong>. Notas altas elevam o CHS, notas baixas reduzem.</p>
            </div>
          </div>
          <div class="help-tile">
            <div class="tile-icon">âŒ</div>
            <div>
              <h4>Negativas (30 pts)</h4>
              <p>Quantidade recente de avaliaÃ§Ãµes negativas. <strong>0 Ã© a meta</strong>. Quanto menos negativas, maior a pontuaÃ§Ã£o.</p>
            </div>
          </div>
          <div class="help-tile">
            <div class="tile-icon">â­</div>
            <div>
              <h4>CS (20 pts)</h4>
              <p><strong>PercepÃ§Ã£o de qualidade</strong> de 0 a 10. Reflete a experiÃªncia do cliente com o atendimento.</p>
            </div>
          </div>
        </div>

        <div class="help-section">
          <h4>Como lemos o resultado</h4>
          <ul>
            <li>Use o <strong>filtro de mÃªs</strong> para comparar perÃ­odos.</li>
            <li>Observe <strong>tendÃªncias</strong> (alta/queda) nos grÃ¡ficos.</li>
            <li>Monitore <strong>negativas</strong> â€” trabalhar para manter <strong>0</strong>.</li>
            <li>Se a nota cair, abra o <strong>Plano de AÃ§Ã£o (PDCA)</strong>.</li>
          </ul>
        </div>

        <div class="help-section">
          <h4>Exemplo rÃ¡pido</h4>
          <div>Se um cliente tem: SLA 16/20, NPS 22/30, Negativas 15/30, CS 12/20 â†’ <strong>CHS 65</strong> (AtenÃ§Ã£o). Foco em reduzir negativas e melhorar SLA.</div>
        </div>
      </div>`;
        document.body.appendChild(overlay);
        lockBodyScroll();

        // Trigger animation
        setTimeout(() => {
          overlay.classList.add('show');
        }, 10);

        // Render chart  // Build the donut chart for CHS composition
        try {
          const el = document.getElementById('helpChsDonut');
          if (el) {
            const ctx = el.getContext('2d');
            new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: ['SLA 20', 'NPS 30', 'Negativas 30', 'CS 20'],
                datasets: [{ data: [20, 30, 30, 20], backgroundColor: ['#0b63b7', '#6b43b8', '#e53935', '#009f42'], borderColor: '#ffffff', borderWidth: 2 }]
              },
              options: { devicePixelRatio: (window.devicePixelRatio || 1), responsive: false, maintainAspectRatio: false, cutout: '62%', plugins: { legend: { display: false } } }
            });
          }
        } catch (e) { }
      } catch (e) { alert('NÃ£o foi possÃ­vel abrir a ajuda.'); }
    }

    function closeHelpCHS() {
      try {
        const ov = document.querySelector('.help-overlay');
        if (!ov) return;
        ov.classList.remove('show');
        setTimeout(() => {
          ov.remove();
          unlockBodyScroll();
        }, 300);
      } catch (e) { }
    }
    /* Helper */
    function getAverageCHSForName(name) {
      if (!clientes || !clientes.length) return '--';
      const rows = clientes.filter(c => c.nome === name);
      if (!rows.length) return '--';
      const avg = Math.round(rows.reduce((s, r) => s + (Number(r.chs) || 0), 0) / rows.length);
      return avg;
    }

    /* ========== Floating filters logic and synchronization ========== */

    function createFloatingFiltersIfNeeded() {
      const floatingContainer = document.getElementById('floatingFilters');
      if (!floatingContainer) return;
      if (floatingContainer.dataset.inited === '1') return;

      floatingContainer.innerHTML = `
    <div class="filters-inner" id="floatingFiltersInner">
      <div class="header-search" style="margin-left:0;">
        <i class="fas fa-search search-icon"></i>
        <input type="text" id="floatSearchInput" class="search-input" placeholder="Buscar clientes..." />
        <div id="floatSearchSuggestions" class="suggestions" role="listbox" aria-hidden="true"></div>
      </div>
      <div class="date-field" style="margin-left:6px;">
        <i class="fas fa-calendar calendar-icon"></i>
        <select id="floatMesSelect" class="mes-select">
          <option value="all">Todos</option>
        </select>
      </div>
      <div style="display:flex;gap:8px;margin-left:6px;align-items:center;">
        <button class="btn" id="floatSelectBtn">Selecionar clientes</button>
        <button class="btn btn-primary" id="floatCompareBtn">Comparar</button>
        <button class="help-btn" id="floatHelpBtn" title="Entenda o CHS"><i class="fas fa-question"></i></button>
      </div>
    </div>
  `;
      floatingContainer.dataset.inited = '1';
      // Default collapsed state on creation (persisted preference honored; default collapsed if none)
      try {
        let saved = null; try { saved = localStorage.getItem('floatingFiltersCollapsed'); } catch (e) { }
        const wantCollapsed = (saved === '1' || saved === null || typeof saved === 'undefined');
        const inner = document.getElementById('floatingFiltersInner');
        if (wantCollapsed) { floatingContainer.classList.add('collapsed'); if (inner) inner.classList.add('collapsed'); }
      } catch (e) { }
      try { var fh = document.getElementById('floatHelpBtn'); if (fh) fh.onclick = function () { openHelpCHS(); }; } catch (e) { }

      function syncMonthOptions() {
        try {
          const src = document.getElementById('mesSelect');
          const dst = document.getElementById('floatMesSelect');
          if (!dst) return;
          if (src) {
            dst.innerHTML = src.innerHTML;
            dst.value = src.value;
          } else {
            const meses = (typeof getAllMonthsSorted === 'function') ? getAllMonthsSorted() : Array.from(new Set((clientes || []).map(c => c.dataFmt).filter(Boolean))).sort();
            const options = `<option value="all">Todos</option>` + meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
            dst.innerHTML = options;
            dst.value = (typeof currentMes !== 'undefined' && currentMes && currentMes !== 'all') ? currentMes : meses[meses.length - 1] || 'all';
          }
        } catch (e) { }
      }
      syncMonthOptions();

      const floatSearch = document.getElementById('floatSearchInput');
      const mainSearch = document.getElementById('searchInput');
      if (floatSearch) {
        floatSearch.addEventListener('input', (e) => {
          try { if (mainSearch && mainSearch.value !== e.target.value) mainSearch.value = e.target.value; } catch (ex) { }
          filtrarClientes();
          renderCompareSelector();
          renderSelectModalList();
        });
      }
      if (mainSearch && floatSearch) {
        mainSearch.addEventListener('input', (e) => {
          try { if (floatSearch.value !== e.target.value) floatSearch.value = e.target.value; } catch (ex) { }
        });
      }

      const floatMes = document.getElementById('floatMesSelect');
      const mainMes = document.getElementById('mesSelect');
      if (floatMes) {
        floatMes.addEventListener('change', (e) => {
          if (mainMes && mainMes.value !== e.target.value) mainMes.value = e.target.value;
          onMesChange(e.target.value);
        });
      }
      if (mainMes && floatMes) {
        mainMes.addEventListener('change', (e) => {
          if (floatMes.value !== e.target.value) floatMes.value = mainMes.value;
        });
      }

      const floatSelectBtn = document.getElementById('floatSelectBtn');
      const floatCompareBtn = document.getElementById('floatCompareBtn');
      if (floatSelectBtn) floatSelectBtn.addEventListener('click', () => { openSelectModal(); });
      if (floatCompareBtn) floatCompareBtn.addEventListener('click', () => { openCompareSelector(); });

      const originalPopulate = populateCompareMonthSelects;
      populateCompareMonthSelects = function () {
        originalPopulate();
        syncMonthOptions();
      };

      setTimeout(() => { try { if (mainSearch && floatSearch) floatSearch.value = mainSearch.value; if (mainMes && floatMes) floatMes.value = mainMes.value; } catch (e) { } }, 50);
    }

    /* Init observer to show floating filters when main filters scroll out */
    function initFiltersObserver() {
      const mainBar = document.getElementById('mainFiltersBar');
      const floating = document.getElementById('floatingFilters');
      if (!mainBar || !floating) return;

      createFloatingFiltersIfNeeded();

      let observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            try {
              floating.style.display = 'none';
              floating.setAttribute('aria-hidden', 'true');
              floating.classList.remove('show');
              floating.classList.add('hide');
            } catch (e) { }
          } else {
            try {
              createFloatingFiltersIfNeeded();
              floating.style.display = 'flex';
              floating.setAttribute('aria-hidden', 'false');
              floating.classList.remove('hide');
              floating.classList.add('show');

              // Set initial collapsed/expanded based on saved preference (default: collapsed)
              try {
                const inner = document.getElementById('floatingFiltersInner');
                let saved = null; try { saved = localStorage.getItem('floatingFiltersCollapsed'); } catch (e) { }
                const wantCollapsed = (saved === '1' || saved === null || typeof saved === 'undefined');
                if (wantCollapsed) {
                  floating.classList.add('collapsed');
                  if (inner) inner.classList.add('collapsed');
                  const btn = inner ? inner.querySelector('.collapse-btn') : null;
                  if (btn) { btn.innerText = 'â—€'; btn.setAttribute('aria-expanded', 'false'); }
                } else {
                  floating.classList.remove('collapsed');
                  if (inner) inner.classList.remove('collapsed');
                  const btn = inner ? inner.querySelector('.collapse-btn') : null;
                  if (btn) { btn.innerText = 'â–¶'; btn.setAttribute('aria-expanded', 'true'); }
                }
                // sync input values
                const mainSearch = document.getElementById('searchInput'), floatSearch = document.getElementById('floatSearchInput');
                if (mainSearch && floatSearch) floatSearch.value = mainSearch.value;
                const mainMes = document.getElementById('mesSelect'), floatMes = document.getElementById('floatMesSelect');
                if (mainMes && floatMes) floatMes.value = mainMes.value;
              } catch (e) { }

            } catch (e) { }
          }
        });
      }, { root: null, threshold: 0, rootMargin: '0px' });

      observer.observe(mainBar);

      // After floating is created we add the subtle collapse/expand button and behavior.
      // We do this here to ensure elements exist and to keep functions unchanged.
      waitForFloatingAndInjectToggle();
    }

    /* Inject collapse/expand button and logic into floating filters */
    function ensureFloatingToggle() {
      const floating = document.getElementById('floatingFilters');
      if (!floating) return;
      const inner = document.getElementById('floatingFiltersInner');
      if (!inner) return;

      // Avoid duplicate injection
      if (inner.querySelector('.collapse-btn')) return;

      // Create collapse/expand button
      const btn = document.createElement('button');
      btn.className = 'collapse-btn';
      btn.type = 'button';
      btn.setAttribute('aria-expanded', 'true');
      btn.title = 'Recolher / Expandir filtros';
      btn.innerText = 'â–¶'; // collapse indicator (collapses to the right)
      btn.style.marginLeft = '6px';
      btn.style.fontSize = '14px';
      btn.style.lineHeight = '1';
      btn.style.background = 'var(--tryvia-white)';
      btn.style.color = 'var(--tryvia-cyan)';

      inner.appendChild(btn);
      // Ensure button reflects current collapsed state on creation
      try {
        const floatingCollapsed = floating.classList.contains('collapsed') || inner.classList.contains('collapsed');
        if (floatingCollapsed) {
          btn.innerText = 'â—€';
          btn.setAttribute('aria-expanded', 'false');
        }
      } catch (e) { }

      function setCollapsedState(collapsed, save) {
        if (collapsed) {
          floating.classList.add('collapsed');
          inner.classList.add('collapsed');
          btn.innerText = 'â—€'; // show expand arrow (expand to the left)
          btn.setAttribute('aria-expanded', 'false');
        } else {
          floating.classList.remove('collapsed');
          inner.classList.remove('collapsed');
          btn.innerText = 'â–¶'; // show collapse arrow (collapse to the right)
          btn.setAttribute('aria-expanded', 'true');
        }
        if (save) {
          try { localStorage.setItem('floatingFiltersCollapsed', '' + (collapsed ? 1 : 0)); } catch (e) { }
        }
      }

      // Load saved preference but do not force collapsed on show â€” allow toggle but default is expanded when shown.
      let saved = null;
      try { saved = localStorage.getItem('floatingFiltersCollapsed'); } catch (e) { }
      // If user had previously collapsed and wants persistence, we still respect it only when they toggle.
      // But we avoid forcing collapsed state immediately; initial show will be expanded (handled in observer).

      btn.addEventListener('click', function (e) {
        const isCollapsed = floating.classList.contains('collapsed');
        setCollapsedState(!isCollapsed, true);
        btn.focus();
        e.stopPropagation();
      });

      // Allow clicking search icon to expand and focus search
      const searchIcon = inner.querySelector('.search-icon');
      if (searchIcon) {
        searchIcon.style.cursor = 'pointer';
        searchIcon.setAttribute('title', 'Buscar cliente');
        searchIcon.addEventListener('click', () => {
          if (floating.classList.contains('collapsed')) {
            // expand
            floating.classList.remove('collapsed');
            inner.classList.remove('collapsed');
            const btnLocal = inner.querySelector('.collapse-btn');
            if (btnLocal) { btnLocal.innerText = 'â–¶'; btnLocal.setAttribute('aria-expanded', 'true'); try { localStorage.setItem('floatingFiltersCollapsed', '0'); } catch (e) { } }
            setTimeout(() => {
              const floatInput = document.getElementById('floatSearchInput');
              if (floatInput) floatInput.focus();
            }, 220);
          } else {
            const floatInput = document.getElementById('floatSearchInput');
            if (floatInput) floatInput.focus();
          }
        });
      }

      // Keep in sync values between float and main search
      const floatInput = document.getElementById('floatSearchInput');
      const mainInput = document.getElementById('searchInput');
      if (floatInput && mainInput) {
        const sync = () => { try { if (mainInput.value !== floatInput.value) mainInput.value = floatInput.value; if (floatInput.value !== mainInput.value) floatInput.value = mainInput.value; } catch (e) { } };
        floatInput.addEventListener('input', sync);
        mainInput.addEventListener('input', sync);
      }
    }

    function waitForFloatingAndInjectToggle(retries) {
      retries = typeof retries === 'number' ? retries : 30;
      const inner = document.getElementById('floatingFiltersInner');
      if (inner) {
        ensureFloatingToggle();
        return;
      }
      if (retries <= 0) return;
      setTimeout(() => waitForFloatingAndInjectToggle(retries - 1), 160);
    }

    /* AUTOCOMPLETE SUGGESTIONS (new, added without modifying existing functions) */
    /* Renders suggestions based on current registered clientes and the typed term.
       Keeps the UI responsive and integrates with existing filtering behavior.
    */
    function renderSuggestions() {
      const mainInput = document.getElementById('searchInput');
      const mainBox = document.getElementById('searchSuggestions');
      const floatInput = document.getElementById('floatSearchInput');
      const floatBox = document.getElementById('floatSearchSuggestions');
      if (!mainInput && !floatInput) return;

      const activeIsFloat = (document.activeElement && document.activeElement.id === 'floatSearchInput');
      const input = activeIsFloat && floatInput ? floatInput : (mainInput || floatInput);
      const suggestionsBox = activeIsFloat && floatBox ? floatBox : (mainBox || floatBox);
      if (!suggestionsBox) return;

      // Close the other dropdown
      try {
        const other = suggestionsBox === mainBox ? floatBox : mainBox;
        if (other) { other.classList.remove('show'); other.setAttribute('aria-hidden', 'true'); other.innerHTML = ''; }
      } catch (e) { }

      const term = (input.value || '').toLowerCase().trim();
      // Build unique client list
      const names = Array.from(new Set((clientes || []).map(c => (c.nome || '').toString().trim()).filter(Boolean)))
        .filter(n => !term || n.toLowerCase().includes(term))
        .sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));

      // Build header with actions and results list
      const listId = suggestionsBox === mainBox ? 'suggestListMain' : 'suggestListFloat';
      suggestionsBox.innerHTML = `
    <div style="display:flex;gap:6px;margin-bottom:6px;">
      <button class="btn" type="button" onclick="suggestSelectAll('${listId}')">Selecionar todos</button>
      <button class="btn" type="button" onclick="suggestClearAll('${listId}')">Limpar</button>
    </div>
    <div id="${listId}" style="display:flex;flex-direction:column;gap:6px;"></div>
  `;
      const listEl = document.getElementById(listId);
      if (names.length === 0) {
        const p = document.createElement('div');
        p.className = 'suggestion-item';
        p.textContent = 'Nenhum cliente encontrado';
        listEl.appendChild(p);
      } else {
        names.forEach(name => {
          const id = 'sg_' + Math.random().toString(36).slice(2, 9);
          const checked = selectedClients && selectedClients.has(name);
          const avg = getAverageCHSForName(name);
          const statusObj = getStatusCHS(Number(avg));
          const badgeColor = (statusObj && statusObj.cor) ? statusObj.cor : '#006f5a';
          const row = document.createElement('div');
          row.className = 'compare-selector-item';
          row.tabIndex = 0;
          row.innerHTML = `<input type=\"checkbox\" id=\"${id}\" data-name=\"${escapeHtml(name)}\" ${checked ? 'checked' : ''}/> <span class=\"client-name\" title=\"${escapeHtml(name)}\">${escapeHtml(name)}</span> <span class=\"chs-badge\" style=\"border-color:${badgeColor}; color:${badgeColor};\">${avg}</span>`;
          const input = row.querySelector('input');
          const toggle = () => { input.checked = !input.checked; const n = input.getAttribute('data-name'); if (input.checked) selectedClients.add(n); else selectedClients.delete(n); updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard(); };
          input.addEventListener('change', () => toggle());
          row.addEventListener('click', (ev) => { if (ev.target && ev.target.tagName !== 'INPUT') { toggle(); } });
          row.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); toggle(); } });
          listEl.appendChild(row);
        });
      }

      // match width with the input
      try {
        const w = Math.max(260, input.offsetWidth);
        suggestionsBox.style.minWidth = w + 'px';
        suggestionsBox.style.width = w + 'px';
        // align left edge with the input (account for search icon area)
        const left = input.offsetLeft || 0;
        suggestionsBox.style.left = left + 'px';
      } catch (e) { }

      suggestionsBox.classList.add('show');
      suggestionsBox.setAttribute('aria-hidden', 'false');
    }

    function suggestSelectAll(listId) {
      document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => { ch.checked = true; const n = ch.getAttribute('data-name'); if (n) selectedClients.add(n); });
      rankingPage = 1; renderDashboard();
    }
    function suggestClearAll(listId) {
      document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => { ch.checked = false; const n = ch.getAttribute('data-name'); if (n) selectedClients.delete(n); });
      rankingPage = 1; renderDashboard();
    }

    /* When user selects a suggestion: populate search, trigger existing filtering and related UI updates */
    function selectSuggestion(name) {
      const mainInput = document.getElementById('searchInput');
      const floatInput = document.getElementById('floatSearchInput');
      const activeIsFloat = (document.activeElement && document.activeElement.id === 'floatSearchInput');
      const target = activeIsFloat && floatInput ? floatInput : mainInput;
      if (!target) return;
      target.value = name;
      // Sync the other input too
      try {
        if (target === mainInput && floatInput) floatInput.value = name;
        if (target === floatInput && mainInput) mainInput.value = name;
      } catch (e) { }
      // Hide both suggestion boxes
      ['searchSuggestions', 'floatSearchSuggestions'].forEach(id => {
        const box = document.getElementById(id);
        if (box) { box.classList.remove('show'); box.setAttribute('aria-hidden', 'true'); box.innerHTML = ''; }
      });
      // Trigger existing filters and selectors to update
      filtrarClientes();
      renderCompareSelector();
      renderSelectModalList();
    }

    /* Keyboard navigation for suggestion list */
    function handleSearchKeyDown(e) {
      const mainBox = document.getElementById('searchSuggestions');
      const floatBox = document.getElementById('floatSearchSuggestions');
      const suggestionsBox = (floatBox && floatBox.classList.contains('show')) ? floatBox : mainBox;
      if (!suggestionsBox || !suggestionsBox.classList.contains('show')) return;
      const items = Array.from(suggestionsBox.querySelectorAll('.suggestion-item'));
      if (!items.length) return;
      let activeIndex = items.findIndex(it => it.classList.contains('active'));
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (activeIndex >= 0) items[activeIndex].classList.remove('active');
        const next = (activeIndex + 1) % items.length;
        items[next].classList.add('active');
        items[next].scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (activeIndex >= 0) items[activeIndex].classList.remove('active');
        const prev = (activeIndex - 1 + items.length) % items.length;
        items[prev].classList.add('active');
        items[prev].scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'Enter') {
        if (activeIndex >= 0) {
          e.preventDefault();
          const name = items[activeIndex].getAttribute('data-name');
          if (name) selectSuggestion(name);
        }
      } else if (e.key === 'Escape') {
        suggestionsBox.classList.remove('show');
        suggestionsBox.setAttribute('aria-hidden', 'true');
        suggestionsBox.innerHTML = '';
      }
    }

    /* Hide suggestions on blur, but allow click handlers (use timeout) */
    function attachSearchHandlers() {
      const input = document.getElementById('searchInput');
      const suggestionsBox = document.getElementById('searchSuggestions');
      if (input) {
        input.addEventListener('input', function () {
          renderSuggestions();
        });
        input.addEventListener('focus', function () { renderSuggestions(); });
        input.addEventListener('keydown', function (e) { handleSearchKeyDown(e); });
        input.addEventListener('blur', function () {
          setTimeout(() => {
            const sb = document.getElementById('searchSuggestions');
            const headerSearchMain = document.querySelector('.filters-left .header-search');
            const active = document.activeElement;
            if (headerSearchMain && (headerSearchMain.contains(active))) {
              return;
            }
            if (sb) { sb.classList.remove('show'); sb.setAttribute('aria-hidden', 'true'); sb.innerHTML = ''; }
          }, 60);
        });
      }
      if (suggestionsBox) {
        suggestionsBox.addEventListener('blur', function () {
          setTimeout(() => {
            const sb = document.getElementById('searchSuggestions');
            if (sb) { sb.classList.remove('show'); sb.setAttribute('aria-hidden', 'true'); sb.innerHTML = ''; }
          }, 120);
        });
      }

      // If clicking outside, hide suggestions
      document.addEventListener('click', function (e) {
        const target = e.target;
        const headerSearchMain = document.querySelector('.filters-left .header-search');
        const headerSearchFloat = document.querySelector('#floatingFiltersInner .header-search');
        const boxes = ['searchSuggestions', 'floatSearchSuggestions'];
        if ((!headerSearchMain || !headerSearchMain.contains(target)) && (!headerSearchFloat || !headerSearchFloat.contains(target))) {
          boxes.forEach(id => { const sb = document.getElementById(id); if (sb) { sb.classList.remove('show'); sb.setAttribute('aria-hidden', 'true'); sb.innerHTML = ''; } });
        }
      });

      // Wire floating input as well (if exists)
      const floatInput = document.getElementById('floatSearchInput');
      const floatBox = document.getElementById('floatSearchSuggestions');
      if (floatInput) {
        floatInput.addEventListener('input', function () { renderSuggestions(); });
        floatInput.addEventListener('focus', function () { renderSuggestions(); });
        floatInput.addEventListener('keydown', function (e) { handleSearchKeyDown(e); });
        floatInput.addEventListener('blur', function () {
          setTimeout(() => {
            const headerSearchFloat = document.querySelector('#floatingFiltersInner .header-search');
            const active = document.activeElement;
            if (headerSearchFloat && headerSearchFloat.contains(active)) {
              return;
            }
            if (floatBox) { floatBox.classList.remove('show'); floatBox.setAttribute('aria-hidden', 'true'); floatBox.innerHTML = ''; }
          }, 60);
        });
      }
    }

    /* ========== End autocomplete helpers ========== */
    /* Helper: show number of selected clients in the search inputs */
    function updateSelectedClientsInputLabel() {
      // no-op: do not write into search inputs so it won't interfere with typing
    }

    /* ========== Inline multi-select below search inputs ========== */
    function openInlineSelect(which) {
      const isFloat = which === 'float';
      const boxId = isFloat ? 'floatSearchSuggestions' : 'searchSuggestions';
      const box = document.getElementById(boxId);
      if (!box) return;
      // Close other box first to avoid conflicts
      try { const otherId = isFloat ? 'searchSuggestions' : 'floatSearchSuggestions'; const other = document.getElementById(otherId); if (other) { other.classList.remove('show'); other.setAttribute('aria-hidden', 'true'); other.innerHTML = ''; } } catch (e) { }
      // Render the container with internal search and list region
      const searchId = isFloat ? 'inlineSearchFloat' : 'inlineSearchMain';
      const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
      box.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:6px;">
      <input id="${searchId}" class="modal-search" placeholder="Buscar na lista..." />
      <div style="display:flex;gap:6px;">
        <button class="btn" type="button" onclick="inlineSelectAllVisible('${which}')">Selecionar todos</button>
        <button class="btn" type="button" onclick="inlineClearAllVisible('${which}')">Limpar</button>
      </div>
      <div id="${listId}" style="max-height:320px;overflow:auto;display:flex;flex-direction:column;gap:6px;"></div>
    </div>`;
      box.classList.add('show');
      box.setAttribute('aria-hidden', 'false');
      // match width with the input for a cleaner look
      try {
        const container = isFloat ? document.querySelector('#floatingFiltersInner .header-search') : document.querySelector('.filters-left .header-search');
        const input = isFloat ? document.getElementById('floatSearchInput') : document.getElementById('searchInput');
        if (container && input) {
          const w = Math.max(260, input.offsetWidth);
          box.style.minWidth = w + 'px';
          box.style.width = w + 'px';
        }
      } catch (e) { }
      renderInlineSelectList(which);
      setTimeout(() => { const s = document.getElementById(searchId); if (s) { s.focus(); s.addEventListener('input', () => renderInlineSelectList(which)); } }, 30);
    }

    function closeInlineSelect() {
      ['searchSuggestions', 'floatSearchSuggestions'].forEach(id => {
        const el = document.getElementById(id);
        if (el) { el.classList.remove('show'); el.setAttribute('aria-hidden', 'true'); el.innerHTML = ''; }
      });
    }

    function inlineGetBase() {
      // Always list all clients (independente do mÃªs selecionado)
      return clientes || [];
    }

    function renderInlineSelectList(which) {
      const isFloat = which === 'float';
      const searchId = isFloat ? 'inlineSearchFloat' : 'inlineSearchMain';
      const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
      const listEl = document.getElementById(listId);
      if (!listEl) return;
      const term = (document.getElementById(searchId)?.value || '').toLowerCase().trim();
      const base = inlineGetBase();
      const names = Array.from(new Set(base.map(c => (c.nome || '').toString().trim()).filter(Boolean)))
        .filter(n => !term || n.toLowerCase().includes(term))
        .sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));
      listEl.innerHTML = '';
      if (names.length === 0) {
        const p = document.createElement('div');
        p.style.color = 'var(--tryvia-dark2)'; p.style.fontWeight = '700'; p.style.padding = '8px';
        p.textContent = 'Nenhum cliente disponÃ­vel.';
        listEl.appendChild(p);
        return;
      }
      names.forEach(name => {
        const id = (isFloat ? 'ifl_' : 'im_') + Math.random().toString(36).slice(2, 9);
        const checked = selectedClients && selectedClients.has(name);
        const row = document.createElement('div');
        row.className = 'compare-selector-item';
        row.tabIndex = 0;
        row.innerHTML = `<input type=\"checkbox\" id=\"${id}\" data-name=\"${escapeHtml(name)}\" ${checked ? 'checked' : ''} /> <span class=\"client-name\" title=\"${escapeHtml(name)}\">${escapeHtml(name)}</span> <span class=\"chs-badge\">${getAverageCHSForName(name)}</span>`;
        const input = row.querySelector('input');
        const toggle = () => { input.checked = !input.checked; const n = input.getAttribute('data-name'); if (input.checked) selectedClients.add(n); else selectedClients.delete(n); updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard(); };
        input.addEventListener('change', () => toggle());
        row.addEventListener('click', (ev) => { if (ev.target && ev.target.tagName !== 'INPUT') { toggle(); } });
        row.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); toggle(); } });
        listEl.appendChild(row);
      });
    }

    function inlineSelectAllVisible(which) {
      const isFloat = which === 'float';
      const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
      document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => {
        ch.checked = true; const n = ch.getAttribute('data-name'); if (n) selectedClients.add(n);
      });
      updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard();
    }
    function inlineClearAllVisible(which) {
      const isFloat = which === 'float';
      const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
      document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => {
        ch.checked = false; const n = ch.getAttribute('data-name'); if (n) selectedClients.delete(n);
      });
      updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard();
    }

    /* ========== Toggle extra charts (Ver Mais / Ver Menos) ========== */
    function toggleGraficos() {
      const cont = document.getElementById('graficosIndividuais');
      const btn = document.getElementById('toggleGraficosBtn');
      if (!cont || !btn) return;
      const isHidden = cont.style.display === 'none' || cont.getAttribute('aria-hidden') === 'true' || !cont.classList.contains('expanded');
      if (isHidden) {
        cont.style.display = 'block';
        cont.classList.add('collapsible');
        // Force reflow to enable transition
        void cont.offsetHeight;
        cont.classList.add('expanded');
        cont.setAttribute('aria-hidden', 'false');
        btn.textContent = 'Ver Menos';
        // After expansion, ensure charts size correctly (if created while hidden)
        setTimeout(() => {
          try { chartTrendUp ? chartTrendUp.resize() : createChartTrendUp(); } catch (e) { }
          try { chartIndicadores ? chartIndicadores.resize() : createChartIndicadores(); } catch (e) { }
        }, 380);
      } else {
        cont.classList.remove('expanded');
        cont.setAttribute('aria-hidden', 'true');
        const onEnd = (ev) => { if (ev.target !== cont) return; cont.style.display = 'none'; cont.removeEventListener('transitionend', onEnd); };
        cont.addEventListener('transitionend', onEnd);
        btn.textContent = 'Ver Mais';
      }
    }

    // ====== TV Mode (one-screen view) ======
    function resizeAllChartsForTv() {
      try { chartChsDistrib ? chartChsDistrib.resize() : createChartDistribuicao(); } catch (e) { }
      try { chartChsEvolucao ? chartChsEvolucao.resize() : createChartEvolucao(); } catch (e) { }
      try { chartTrendUp ? chartTrendUp.resize() : createChartTrendUp(); } catch (e) { }
      try { chartNegEvolucao ? chartNegEvolucao.resize() : createChartNEG(); } catch (e) { }
      try { chartIndicadores ? chartIndicadores.resize() : createChartIndicadores(); } catch (e) { }
    }

    function normalizeChartsDPR() {
      const dpr = window.devicePixelRatio || 1;
      const charts = [
        typeof chartChsDistrib !== 'undefined' ? chartChsDistrib : null,
        typeof chartChsEvolucao !== 'undefined' ? chartChsEvolucao : null,
        typeof chartTrendUp !== 'undefined' ? chartTrendUp : null,
        typeof chartTrendDown !== 'undefined' ? chartTrendDown : null,
        typeof chartSlaEvolucao !== 'undefined' ? chartSlaEvolucao : null,
        typeof chartCsEvolucao !== 'undefined' ? chartCsEvolucao : null,
        typeof chartNpsEvolucao !== 'undefined' ? chartNpsEvolucao : null,
        typeof chartNegEvolucao !== 'undefined' ? chartNegEvolucao : null,
        typeof chartIndicadores !== 'undefined' ? chartIndicadores : null,
        typeof chartCompare !== 'undefined' ? chartCompare : null,
        typeof chartClienteDonut !== 'undefined' ? chartClienteDonut : null,
        typeof chartClienteComp !== 'undefined' ? chartClienteComp : null,
        typeof chartClienteTrendDown !== 'undefined' ? chartClienteTrendDown : null,
        typeof chartClienteTrendUp !== 'undefined' ? chartClienteTrendUp : null
      ];
      charts.forEach(ch => { try { if (ch) { ch.options.devicePixelRatio = dpr; ch.resize(0); ch.update('none'); } } catch (e) { } });
    }

    // TV mode scaling state and debounced updater to prevent jitter
    let __tvScaling = false;
    let __tvLastScale = null;
    let __tvResizeTimer = null;
    function scheduleTvLayoutUpdate(delay) {
      const ms = typeof delay === 'number' ? delay : 120;
      if (__tvResizeTimer) clearTimeout(__tvResizeTimer);
      __tvResizeTimer = setTimeout(() => { applyTvScale(); normalizeChartsDPR(); resizeAllChartsForTv(); }, ms);
    }

    function applyTvScale() {
      const body = document.body;
      const cont = document.querySelector('.container');
      if (!cont) return;
      if (!body.classList.contains('tv-mode')) {
        cont.style.transform = '';
        cont.style.height = '';
        cont.style.width = '';
        cont.style.margin = '';
        // restore ranking dynamic heights
        document.querySelectorAll('.dashboard-ranking-container').forEach(rc => { rc.style.height = ''; });
        document.querySelectorAll('.dashboard-ranking-list,#rankingGeralList').forEach(ul => { ul.style.maxHeight = ''; });
        // restore chart container heights
        document.querySelectorAll('.dashboard-chart-container').forEach(cc => { cc.style.height = ''; });
        return;
      }
      // reset to measure (previous behavior: height-based scaling)
      if (__tvScaling) return; // guard re-entrancy
      __tvScaling = true;
      cont.style.transform = '';
      cont.style.height = '';
      const withSidebar = cont.classList.contains('with-sidebar');
      cont.style.width = withSidebar ? 'calc(100vw - 88px)' : '100vw';
      const desiredBottomGap = 12;
      const availH = window.innerHeight;
      let contentH = cont.scrollHeight;
      // If there's vertical gap, increase ranking heights to fill it proportionally
      const ranks = Array.from(document.querySelectorAll('.dashboard-ranking-container'));
      if (ranks.length) {
        const baseH = 420;        // keep in sync with TV CSS
        const baseListH = 352;    // keep in sync with TV CSS
        let extra = availH - desiredBottomGap - contentH;
        if (extra > 0) {
          const per = Math.floor(extra / ranks.length);
          const perClamped = Math.min(per, 140);
          ranks.forEach(rc => { rc.style.height = (baseH + perClamped) + 'px'; });
          document.querySelectorAll('.dashboard-ranking-list,#rankingGeralList').forEach(ul => { ul.style.maxHeight = (baseListH + perClamped) + 'px'; });
          // remeasure after adjustment
          contentH = cont.scrollHeight;
        }
      }
      // Then, if still vertical gap, expand charts heights as well to keep proportions
      const charts = Array.from(document.querySelectorAll('.dashboard-chart-container'));
      if (charts.length) {
        const baseChartH = 420;   // keep in sync with TV CSS
        let extra2 = availH - desiredBottomGap - contentH;
        if (extra2 > 0) {
          const perC = Math.floor(extra2 / charts.length);
          const perCClamped = Math.min(perC, 120);
          charts.forEach(cc => { cc.style.height = (baseChartH + perCClamped) + 'px'; });
          // remeasure after adjustment
          contentH = cont.scrollHeight;
        }
      }
      const parentW = (cont.parentElement && cont.parentElement.clientWidth) ? cont.parentElement.clientWidth : (window.innerWidth || document.documentElement.clientWidth || 0);
      const baseW = Math.max(parentW, 0);
      const vwWidth = Math.max(withSidebar ? (baseW - 88) : baseW, 0);
      const contentW = Math.max(cont.scrollWidth || cont.offsetWidth || 0, 0);
      const sY = (availH - desiredBottomGap) / (contentH || 1);
      const sX = vwWidth / (contentW || 1);
      const scale = Math.min(1, sX, sY);
      if (__tvLastScale !== null && Math.abs(scale - __tvLastScale) < 0.002) {
        __tvScaling = false;
        return;
      }
      cont.style.transformOrigin = 'top center';
      cont.style.transform = 'scale(' + scale.toFixed(3) + ')';
      cont.style.height = (contentH * scale) + 'px';
      // Expand logical width so that after scale the visible width occupies 100vw (avoid side gaps)
      try {
        cont.style.width = (vwWidth / (scale || 1)) + 'px';
      } catch (e) { cont.style.width = '100vw'; }
      cont.style.margin = '0 auto';
      __tvLastScale = scale;
      __tvScaling = false;
    }

    function isFullscreen() { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement); }
    function fsElement() { return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null; }
    function requestFs(el) { if (!el) return; if (el.requestFullscreen) return el.requestFullscreen(); if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen(); if (el.msRequestFullscreen) return el.msRequestFullscreen(); }
    function exitFs() { if (document.exitFullscreen) return document.exitFullscreen(); if (document.webkitExitFullscreen) return document.webkitExitFullscreen(); if (document.msExitFullscreen) return document.msExitFullscreen(); }
    function resizeChartsInside(el) {
      try {
        const ids = Array.from(el.querySelectorAll('canvas[id]')).map(c => c.id);
        try { if (ids.includes('chartChsDistrib') && typeof chartChsDistrib !== 'undefined' && chartChsDistrib) chartChsDistrib.resize(); } catch (e) { }
        try { if (ids.includes('chartChsEvolucao') && typeof chartChsEvolucao !== 'undefined' && chartChsEvolucao) chartChsEvolucao.resize(); } catch (e) { }
        try { if (ids.includes('chartTrendUp') && typeof chartTrendUp !== 'undefined' && chartTrendUp) chartTrendUp.resize(); } catch (e) { }
        try { if (ids.includes('chartIndicadores') && typeof chartIndicadores !== 'undefined' && chartIndicadores) chartIndicadores.resize(); } catch (e) { }
      } catch (e) { }
      try { window.dispatchEvent(new Event('resize')); } catch (e) { }
    }
    function toggleElementFullscreen(btn) { const el = btn && btn.closest ? btn.closest('.dashboard-chart-container, .dashboard-ranking-container') : null; if (!el) return; if (isFullscreen() && fsElement() === el) { exitFs(); } else { requestFs(el); } }
    document.addEventListener('fullscreenchange', function () {
      const el = fsElement();
      if (el) { resizeChartsInside(el); } else { try { resizeAllChartsForTv(); } catch (e) { } }
      // Only adjust Ranking Geral page size while its container is fullscreen
      try {
        const rg = document.getElementById('rankingGeral');
        if (el && rg && el === rg) {
          try { if (typeof window.__rg_fs_prevPageSize === 'undefined' || window.__rg_fs_prevPageSize === null) window.__rg_fs_prevPageSize = rankingPageSize; } catch (e) { }
          try { if (typeof rankingPageSize !== 'undefined' && rankingPageSize < 10) rankingPageSize = 10; } catch (e) { }
          try { renderRankingGeral(); } catch (e) { }
        } else if (!el && (typeof window.__rg_fs_prevPageSize !== 'undefined') && window.__rg_fs_prevPageSize !== null) {
          try { rankingPageSize = window.__rg_fs_prevPageSize; } catch (e) { }
          window.__rg_fs_prevPageSize = null;
          try { renderRankingGeral(); } catch (e) { }
        }
      } catch (e) { }
    });
    document.addEventListener('webkitfullscreenchange', function () {
      const el = fsElement();
      if (el) { resizeChartsInside(el); } else { try { resizeAllChartsForTv(); } catch (e) { } }
      // Only adjust Ranking Geral page size while its container is fullscreen
      try {
        const rg = document.getElementById('rankingGeral');
        if (el && rg && el === rg) {
          try { if (typeof window.__rg_fs_prevPageSize === 'undefined' || window.__rg_fs_prevPageSize === null) window.__rg_fs_prevPageSize = rankingPageSize; } catch (e) { }
          try { if (typeof rankingPageSize !== 'undefined' && rankingPageSize < 10) rankingPageSize = 10; } catch (e) { }
          try { renderRankingGeral(); } catch (e) { }
        } else if (!el && (typeof window.__rg_fs_prevPageSize !== 'undefined') && window.__rg_fs_prevPageSize !== null) {
          try { rankingPageSize = window.__rg_fs_prevPageSize; } catch (e) { }
          window.__rg_fs_prevPageSize = null;
          try { renderRankingGeral(); } catch (e) { }
        }
      } catch (e) { }
    });
    function attachFullscreenHandlers() { /* dblclick to fullscreen disabled intentionally; use button only */ }


    /* Month change function */
    function changeMonth() {
      const sel = document.getElementById('mesSelect');
      if (!sel) return;
      currentMes = sel.value;
      if (currentMes !== 'all') {
        statusFilter = null;
      } else {
        statusFilter = 'all';
      }
      clientesFiltrados = [...clientes];
      renderDashboard();
    }

    /* Month Selection Modal Functions */
    function showMonthSelectionModal() {
      const modal = document.getElementById('monthSelectionModal');
      if (!modal) return;
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');

      // Populate months
      const meses = Array.from(new Set(clientes.map(c => c.dataFmt).filter(Boolean))).sort();
      const select = document.getElementById('monthSelectionSelect');
      if (select && meses.length > 0) {
        select.innerHTML = `<option value="all">Todos</option>` + meses.map(m => `<option value="${m}">${formatMesAno(m)}</option>`).join('');
        select.value = meses[meses.length - 1]; // Seleciona o mais recente por padrÃ£o
      }
    }

    function closeMonthSelectionModal() {
      const modal = document.getElementById('monthSelectionModal');
      if (!modal) return;
      modal.classList.add('fade-out');
      setTimeout(() => {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        modal.classList.remove('fade-out');
      }, 200);
    }

    function confirmMonthSelection() {
      const select = document.getElementById('monthSelectionSelect');
      if (!select || !select.value) return;

      const selectedMonth = select.value;

      // Update main select
      const mainSelect = document.getElementById('mesSelect');
      if (mainSelect) {
        mainSelect.value = selectedMonth;
        currentMes = selectedMonth;

        // Se nÃ£o for "Todos", limpa o statusFilter para mostrar dados do mÃªs especÃ­fico
        if (selectedMonth !== 'all') {
          statusFilter = null;
        } else {
          statusFilter = 'all';
        }

        // ForÃ§a atualizaÃ§Ã£o do clientesFiltrados
        clientesFiltrados = [...clientes];
      }

      // Sincronizar com o select da barra flutuante
      const floatSelect = document.getElementById('floatMesSelect');
      if (floatSelect) {
        floatSelect.value = selectedMonth;
        // Disparar evento change caso exista listener
        const changeEvent = new Event('change', { bubbles: true });
        floatSelect.dispatchEvent(changeEvent);
      }

      // Close modal
      closeMonthSelectionModal();

      // Render dashboard with selected month
      setTimeout(() => {
        renderDashboard();
      }, 100);
    }

    /* Init */
    document.addEventListener('DOMContentLoaded', function () {
      try { carregarDoGoogleSheets(); } catch (e) { }
      clientesFiltrados = [...clientes];
      selectedClients = new Set(Array.from(new Set((clientes || []).map(c => (c.nome || '').toString().trim()))));
      compareSelectedClients = new Set();

      // Configura o select inicialmente vazio para nÃ£o mostrar "Todos"
      const sel = document.getElementById('mesSelect');
      if (sel) {
        sel.innerHTML = '<option value="">Carregando...</option>';
        sel.value = '';
      }

      populateCompareMonthSelects();
      renderSelectModalList();
      renderCompareSelector();

      // initialize floating filters wiring and observer and inject toggle
      initFiltersObserver();

      // Attach autocomplete handlers
      attachSearchHandlers();

      // Close filters menu on outside click and ESC
      document.addEventListener('click', function (e) {
        const wrap = document.getElementById('rankingFiltersWrap');
        const menu = document.getElementById('rankingFiltersMenu');
        if (!wrap || !menu) return;
        if (!wrap.contains(e.target)) closeRankingFiltersMenu();
      });
      document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') closeRankingFiltersMenu();
      });
      // Close indicator filters menu on outside click and ESC
      document.addEventListener('click', function (e) {
        const wrap = document.getElementById('indicatorFiltersWrap');
        const menu = document.getElementById('indicatorFiltersMenu');
        if (!wrap || !menu) return;
        if (!wrap.contains(e.target)) closeIndicatorFiltersMenu();
      });
      document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') closeIndicatorFiltersMenu();
      });
      attachFullscreenHandlers();
    });

    /* small helpers used by pagination buttons - kept as expected */
    function rankingPrev() { if (rankingPage > 1) { rankingPage--; renderRankingGeral(); } }
    function rankingNext() { rankingPage++; renderRankingGeral(); }
    function verDetalhes(name) { abrirClienteModal(name); }
    function editarCliente(name) { alert('Funcionalidade de editar nÃ£o implementada aqui.'); }
    function ligarCliente(name) { alert('Funcionalidade de ligar nÃ£o implementada aqui.'); }


    /* ========== Client Selection Modal Interface ========== */
    function openSelectModal() {
      const modal = document.getElementById('clientSelectModal');
      if (!modal) return;
      // Reset to default selection mode
      const title = document.getElementById('selectModalTitle');
      if (title) title.innerText = 'Selecionar Clientes';

      const btn = document.getElementById('selectModalBtn');
      if (btn) {
        btn.innerText = 'Concluir';
        // Default behavior: just close
        btn.onclick = closeSelectModal;
        btn.className = 'btn btn-primary';
      }

      modal.classList.add('show');
      modal.style.visibility = 'visible';
      renderSelectModalList();
      setTimeout(() => {
        const s = document.getElementById('modalClientSearch');
        if (s) s.focus();
      }, 100);
    }

    function openCompareSelector() {
      const modal = document.getElementById('clientSelectModal');
      if (!modal) return;

      // Set comparison mode
      const title = document.getElementById('selectModalTitle');
      if (title) title.innerText = 'Selecione os Clientes para Comparar';

      const btn = document.getElementById('selectModalBtn');
      if (btn) {
        btn.innerText = 'Gerar ComparaÃ§Ã£o';
        btn.onclick = confirmAndCompare;
        btn.className = 'btn btn-primary';
      }

      modal.classList.add('show');
      modal.style.visibility = 'visible';
      renderSelectModalList();
      setTimeout(() => { const s = document.getElementById('modalClientSearch'); if (s) s.focus(); }, 100);
    }

    function confirmAndCompare() {
      // Close select modal
      const selModal = document.getElementById('clientSelectModal');
      if (selModal) {
        selModal.classList.remove('show');
        setTimeout(() => { selModal.style.visibility = 'hidden'; }, 300);
      }

      // Open comparison modal
      const compModal = document.getElementById('clientCompareModal');
      if (compModal) {
        compModal.classList.add('show');
        compModal.style.visibility = 'visible';
        setTimeout(renderCompareCharts, 200);
      }
    }

    function closeCompareModal() {
      const modal = document.getElementById('clientCompareModal');
      if (!modal) return;
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.visibility = 'hidden';
      }, 300);
    }

    let compareChart = null;

    function populateCompareMonths() {
      const select = document.getElementById('compareModalMonth');
      if (!select) return;

      let months = [];
      // Use global clientes if available
      if (typeof clientes !== 'undefined') {
        months = Array.from(new Set(clientes.map(c => c.dataFmt).filter(Boolean))).sort();
      }

      const current = select.value;
      // Keep existing options if just initializing or check usage
      select.innerHTML = '<option value="all">Todo o PerÃ­odo</option>';
      months.forEach(m => {
        let label = m;
        if (typeof formatMesAno === 'function') label = formatMesAno(m);
        select.innerHTML += `<option value="${m}">${label}</option>`;
      });

      if (current && (current === 'all' || months.includes(current))) select.value = current;
    }

    function renderCompareCharts() {
      const select = document.getElementById('compareModalMonth');
      // Only populate if empty (first run) or we want to ensure fresh data
      if (select && select.options.length <= 1) populateCompareMonths();

      const targets = Array.from(selectedClients || []);
      const container = document.getElementById('compareChartsArea');
      if (!container) return;

      if (targets.length === 0) {
        container.innerHTML = '<div style="width:100%; text-align:center; padding:40px; color:#666; font-size:1.1rem;">Nenhum cliente selecionado.<br><br><button class="btn btn-primary" onclick="closeCompareModal(); setTimeout(openCompareSelector, 300);">Selecionar Clientes Agora</button></div>';
        return;
      }

      const monthFilter = select ? select.value : 'all';

      // Prepare Canvas if needed
      let canvas = document.getElementById('compChartMain');
      if (!canvas) {
        container.innerHTML = `
                <div class="dashboard-chart-container" style="height:450px; padding:20px; box-shadow:none; border:1px solid #eee;">
                    <div class="chart-wrapper" style="position:relative; height:100%; width:100%;">
                        <canvas id="compChartMain"></canvas>
                    </div>
                </div>
            `;

        canvas = document.getElementById('compChartMain');
      }

      // Aggregate Data
      const clientData = targets.map(name => {
        // Filter raw data
        let rows = (typeof clientes !== 'undefined' ? clientes : []).filter(c => c.nome === name);
        if (monthFilter && monthFilter !== 'all') {
          rows = rows.filter(c => c.dataFmt === monthFilter);
        }

        if (rows.length === 0) return null;

        const getVal = (r, k) => {
          if (!k) return 0;
          let v = r[k];
          if (typeof v === 'string') v = v.replace(',', '.').replace(/[^0-9.\-]/g, ''); // Clean non-numeric
          return Number(v) || 0;
        };

        // Use more robust detection for SLA/Negatives by checking array of potential keys
        // or by calculating from raw fields if necessary (like SLA = sla1ok / total)

        let totalCHS = 0, totalSLA = 0, totalNPS = 0, totalCS = 0, totalNeg = 0;
        let countSLA = 0; // SLA is often a calculated percentage from raw counts in some contexts

        rows.forEach(r => {
          // CHS
          totalCHS += (Number(r.chs) || 0);

          // CS
          let cs = r.cs || r.cs_nota || 0;
          if (typeof cs === 'string') cs = cs.replace(',', '.');
          totalCS += (Number(cs) || 0);

          // NPS
          let nps = r.nps || r.nps_nota || 0;
          if (typeof nps === 'string') nps = nps.replace(',', '.');
          totalNPS += (Number(nps) || 0);

          // NEGATIVAS - Check various potential keys based on previous files findings
          let neg = r.neg || r.negativas || r.avNeg || r.av_neg || r.avNegFresh || 0;
          if (typeof neg === 'string') neg = neg.replace(',', '.');
          totalNeg += (Number(neg) || 0);

          // SLA - Often calculated from sla1ok, sla1off, etc. OR just a field 'sla'
          // If 'sla' field exists directly:
          if (r.sla !== undefined || r.sla_nota !== undefined) {
            let s = r.sla || r.sla_nota || 0;
            if (typeof s === 'string') s = s.replace(',', '.');
            totalSLA += (Number(s) || 0);
            countSLA++;
          } else {
            // Try calculating from typical tickets columns if available
            // e.g. sla1ok + sla2ok...
            // Fallback to 0 if not found
            let s = 0; // Default
            // Check if we have ticket counts
            const t1 = Number(r.sla1ok) || 0, f1 = Number(r.sla1off) || 0;
            if (t1 + f1 > 0) {
              s = (t1 / (t1 + f1)) * 100;
              totalSLA += s;
              countSLA++;
            }
          }
        });

        const _chs = totalCHS / rows.length;
        const _nps = totalNPS / rows.length;
        const _cs = totalCS / rows.length;
        // Negativas usually is a SUM if it's a count, but 'average negative score'? 
        // Dashboard "AvaliaÃ§Ãµes Negativas (Qtd)" implies count. 
        // If we are showing "Average per month" or "Total"?
        // If monthFilter is 'all', showing AVERAGE per month is usually better for 'score' types, but TOTAL for 'count' types.
        // However, to keep it simple and consistent with bar chart (0-100 or small numbers), let's use Average per row for scores.
        // For Negativas (Count), Average per row (per month) is also fine.
        const _neg = totalNeg / rows.length;

        let _sla = 0;
        if (countSLA > 0) _sla = totalSLA / countSLA;
        else {
          // If no SLA calculated inside loop, try simpler average logic
          _sla = 0;
        }

        return {
          name: name,
          data: [
            Math.round(_chs),
            Math.round(_nps * 10) / 10,
            Math.round(_sla * 10) / 10,
            Math.round(_neg * 10) / 10,
            Math.round(_cs * 10) / 10
          ]
        };
      }).filter(Boolean);

      if (canvas) {
        if (compareChart) compareChart.destroy();

        const labels = ['CHS', 'NPS', 'SLA', 'Negativas', 'CS'];
        const colors = ['#007bff', '#28a745', '#dc3545', '#ffc107', '#6f42c1', '#17a2b8', '#e83e8c', '#fd7e14'];

        const datasets = clientData.map((d, i) => ({
          label: d.name,
          data: d.data,
          backgroundColor: colors[i % colors.length],
          borderRadius: 4,
          barPercentage: 0.6,
          categoryPercentage: 0.8
        }));

        compareChart = new Chart(canvas, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: {
                top: 40
              }
            },
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  font: { size: 12, weight: 'bold' }
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function (context) {
                    return context.dataset.label + ': ' + context.parsed.y;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                grace: '10%'
              }
            }
          }
        });
      }
    }

    function closeSelectModal() {
      const modal = document.getElementById('clientSelectModal');
      if (!modal) return;
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.visibility = 'hidden';
      }, 300);
    }

    function renderSelectModalList() {
      const listEl = document.getElementById('modalClientList');
      if (!listEl) return;

      const searchInput = document.getElementById('modalClientSearch');
      const term = (searchInput ? searchInput.value : '').toLowerCase().trim();

      // Use unique clients
      const names = Array.from(new Set((clientes || []).map(c => (c.nome || '').toString().trim()).filter(Boolean)))
        .filter(n => !term || n.toLowerCase().includes(term))
        .sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));

      listEl.innerHTML = '';

      if (names.length === 0) {
        listEl.innerHTML = '<div style="padding:10px; text-align:center; color:#666;">Nenhum cliente encontrado.</div>';
        return;
      }

      names.forEach(name => {
        const id = 'modal_chk_' + Math.random().toString(36).slice(2, 9);
        const checked = selectedClients && selectedClients.has(name);
        const avg = getAverageCHSForName(name);
        const statusObj = getStatusCHS(Number(avg));
        const badgeColor = (statusObj && statusObj.cor) ? statusObj.cor : '#006f5a';

        const row = document.createElement('div');
        row.className = 'compare-selector-item';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '10px';
        row.style.padding = '8px 12px';
        row.style.cursor = 'pointer';

        row.innerHTML = `
            <input type="checkbox" id="${id}" data-name="${escapeHtml(name)}" ${checked ? 'checked' : ''} style="transform:scale(1.2); cursor:pointer;">
            <div style="flex:1; font-weight:600; font-size:1rem;">${escapeHtml(name)}</div>
            <div class="chs-badge" style="border:1px solid ${badgeColor}; color:${badgeColor}; background:#fff; padding:2px 8px; border-radius:6px; font-weight:800;">${avg}</div>
          `;

        const input = row.querySelector('input');
        const toggle = () => {
          input.checked = !input.checked;
          const n = input.getAttribute('data-name');
          if (input.checked) selectedClients.add(n);
          else selectedClients.delete(n);

          updateSelectedClientsInputLabel();
          rankingPage = 1;
          renderDashboard();
        };

        input.addEventListener('change', (e) => {
          // Input click handled natively, just sync log
          e.stopPropagation();
          const n = input.getAttribute('data-name');
          if (input.checked) selectedClients.add(n);
          else selectedClients.delete(n);
          updateSelectedClientsInputLabel();
          rankingPage = 1;
          renderDashboard();
        });

        row.addEventListener('click', (ev) => {
          if (ev.target !== input) {
            input.checked = !input.checked;
            // Manually trigger update
            const n = input.getAttribute('data-name');
            if (input.checked) selectedClients.add(n);
            else selectedClients.delete(n);
            updateSelectedClientsInputLabel();
            rankingPage = 1;
            renderDashboard();
          }
        });

        listEl.appendChild(row);
      });
    }

    function modalSelectAll() {
      const listEl = document.getElementById('modalClientList');
      if (!listEl) return;
      const inputs = listEl.querySelectorAll('input[type="checkbox"]');
      inputs.forEach(inp => {
        inp.checked = true;
        const n = inp.getAttribute('data-name');
        if (n) selectedClients.add(n);
      });
      rankingPage = 1;
      renderDashboard();
    }

    function modalClearAll() {
      const listEl = document.getElementById('modalClientList');
      if (!listEl) return;
      const inputs = listEl.querySelectorAll('input[type="checkbox"]');
      inputs.forEach(inp => {
        inp.checked = false;
        const n = inp.getAttribute('data-name');
        if (n) selectedClients.delete(n);
      });
      rankingPage = 1;
      renderDashboard();
    }

    // Attach listener to modal search
    document.addEventListener('DOMContentLoaded', () => {
      const ms = document.getElementById('modalClientSearch');
      if (ms) {
        ms.addEventListener('input', () => {
          renderSelectModalList();
        });
      }
    });
  </script>


  <!-- Client Selection Modal HTML -->
  <div class="plano-acao-overlay" id="clientSelectModal" style="z-index: 20050;">
    <div class="plano-acao-box"
      style="width: 600px; max-width: 90%; display:flex; flex-direction:column; max-height: 85vh;">
      <button class="plano-acao-close" onclick="closeSelectModal()">Ã—</button>
      <h3 id="selectModalTitle" style="margin-top:0;">Selecionar Clientes</h3>

      <div style="margin-bottom: 12px; position:relative;">
        <i class="fas fa-search"
          style="position:absolute; left:12px; top:50%; transform:translateY(-50%); color:#aaa;"></i>
        <input type="text" id="modalClientSearch" class="search-input" placeholder="Buscar na lista..."
          style="width: 100%; padding-left:36px;">
      </div>

      <div style="display:flex; gap: 8px; margin-bottom: 12px; flex-wrap:wrap;">
        <button class="btn" style="flex:1; font-size:0.9rem;" onclick="modalSelectAll()">Marcar Todos
          (VisÃ­veis)</button>
        <button class="btn" style="flex:1; font-size:0.9rem; background:#fff; border:1px solid #ddd;"
          onclick="modalClearAll()">Desmarcar Todos</button>
      </div>

      <div id="modalClientList"
        style="flex:1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; padding-right:4px; min-height:200px;">
        <!-- Items will be injected here -->
      </div>

      <div class="plano-acao-trigger" style="margin-top:16px; border-top:1px solid #eee; padding-top:16px;">
        <button id="selectModalBtn" class="btn btn-primary" onclick="closeSelectModal()"
          style="width:100%;">Concluir</button>
      </div>
    </div>
  </div>

  <!-- Client Comparison Modal -->
  <div class="plano-acao-overlay" id="clientCompareModal"
    style="z-index: 20060; backdrop-filter: blur(5px); background: rgba(0,0,0,0.5);">
    <div class="plano-acao-box"
      style="width: 100%; max-width: 900px; height: auto; max-height:85vh; display:flex; flex-direction:column; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); padding: 24px; animation: modalSlideIn 0.3s ease-out;">

      <div
        style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; padding-bottom:16px; border-bottom:1px solid #eee;">
        <h3 style="margin:0; font-size:1.4rem; font-weight:800; color:#333; letter-spacing:-0.5px;">Comparativo de
          Clientes</h3>
        <div style="display:flex; align-items:center; gap:12px;">
          <div style="position:relative;">
            <select id="compareModalMonth"
              style="appearance:none; padding:8px 32px 8px 12px; border-radius:8px; border:1px solid #e1e4e8; font-size:14px; background:#fff; font-weight:600; color:#555; cursor:pointer;"
              onchange="renderCompareCharts()">
              <option value="all">Todo o PerÃ­odo</option>
            </select>
            <i class="fas fa-chevron-down"
              style="position:absolute; right:10px; top:50%; transform:translateY(-50%); color:#888; pointer-events:none; font-size:12px;"></i>
          </div>
          <button class="plano-acao-close" style="position:static; margin:0;" onclick="closeCompareModal()">Ã—</button>
        </div>
      </div>

      <div id="compareChartsArea" style="flex:1; overflow-y:auto; padding-right:4px;">
        <!-- Charts injected by JS -->
      </div>
    </div>
  </div>
<!-- Ecosystem badges injection -->
<style id="ecos-badges-style">.ecos-nav-badges{display:inline-flex;gap:8px;margin-left:6px}.ecos-badge{width:30px;height:30px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;background:var(--tryvia-accent-gradient);color:#fff;font-weight:800;font-size:12px;border:1px solid rgba(0,212,255,0.2);box-shadow:var(--tryvia-card-shadow);cursor:pointer;user-select:none}.ecos-badge:hover{transform:translateY(-1px)}</style>
<script id="ecos-badges-script">(function(){function onClick(e){const a=e.target.closest('.ecos-badge');if(!a)return;const r=a.dataset.route;try{if(window.top&&window.top!==window){window.top.location.hash=(r==='nps')?'#/nps':'#/chs';return;}}catch(_){}var here=(location.pathname||'').replace(/\\\\/g,'/');if(r==='nps'){location.href=here.includes('/nps/')?location.href:'../nps/okokok.html';}else{location.href=here.includes('/chs/')?location.href:'../chs/padrao.html';}}function ensure(){if(document.getElementById('ecos-badges'))return;var left=document.querySelector('.header-inner .left')||document.querySelector('.left');if(!left)return;var nav=document.createElement('nav');nav.id='ecos-badges';nav.className='ecos-nav-badges';nav.innerHTML='<a class="ecos-badge" data-route="chs" title="Customer Health Score">CHS</a><a class="ecos-badge" data-route="nps" title="Net Promoter Score">NPS</a>';nav.addEventListener('click',onClick);left.appendChild(nav);}if(document.readyState!=='loading')ensure();else document.addEventListener('DOMContentLoaded',ensure);})();</script>
</body>

</html>

